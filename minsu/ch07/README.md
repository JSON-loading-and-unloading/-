# 7 가비지 수집 기초
# 7.1  트레이드오프와 탈착형 수집기
개발자는 가비지 수집기 선정 시 다음 항목을 고려해야한다.  

- 중단 시간(중단 길이 또는 기간이라고도 함)
- 처리율(애플리케이션 런타임 대비 GC 시간 % )
- 중단 빈도(수집기 때문에 애플리케이션이 얼마나 자주 멈추는가?)
- 회수 효율(GC 사이클 당 얼마나 많은 가비지가 수집되는가?)
- 중단 일관성(중단 시간이 고른편인가?)  

성능 엔지니어는 수집기 선정 시 다양한 트레이드 오프와 관심사를 면밀히 검토해야한다.  


# 7.2 동시 GC 이론
그래픽/애니메이션 디스플레이 시스템와 같은 특화된 시스템은 프레임률이 거의 고정되어 있어서 GC를 규칙적으로 수행할 수 있다.   

> 적절한 계산이 지연되는 것은 사실 사소한 단점에 불과합니다. 정작 큰 문제는 가비지 수집이 언제 발생할지 예상할 수 없다는 점이다.
> - 에츠허르 데이크스트라

최신 GC이론은 이러한 불확정적 STW 중단 문제를 해결하려고 한다.  

## 7.2.1 JVM 세이프포인트
핫스팟 병렬 수집기에서 STW 가비지 수집을 실행하려면 애플리케이션 스레드를 모두 중단시켜야한다. JVM은 사실 완전히 선제적인 멀티스레드 환경이 아니다. OS 코어 기능처럼 JVM도 조정 작업이 필요하다. 애플리케이션 스레드마다 **세이프포인트(안전점, safe point)** 라는 특별한 지점을 둔다. 세이프포인트는 스레드의 내부 자료 구조가 보이는 지점이며, 이때 어떤 작업을 하기 위해 스레드는 잠시 중단될 수 있다.    

JVM은 다음 두가지 규칙에 따라 세이프포인트를 처리한다.  

- JVM은 강제로 스레드를 세이프포인트 상태로 바꿀 수 없다.
- JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.
따라서 세이프포인트 요청을 받았을 때 그 지점에서 스레드가 **제어권을 반납하게 만드는 코드** 가 VM 인터프리터 구현체 어디에 있어야 한다. 세이프포인트 상태로 바뀌는 경우는 다음과 같다.  

1. JVM이 전역을 세이프포인트 시간 플래그를 세팅한다.
2. 각 애플리케이션 스레드는 폴링을 하면서 이 플래그가 세팅됐는지 확인한다.
3. 애플리케이션 스레드는 일단 멈췄다가 다시 깨어날 때까지 대기한다.  
**세이프포인트 시간 플래그**를 세팅하면 모든 애플리케이션 스레드는 반드시 멈춰야하며 일찍 멈춘 스레드는 느리게 멈추는 다른 스레드를 기다려야 한다.  
일반 애플리케이션 스레드는 이런 식으로 풀링을 한다. 인터프리터에서 바이트코드 2개를 실행할 때마다 체크한다.

> 폴링: 하나의 장치가 총돌 회피 또는 동기화 처리 등을 목적으로 다른 장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식

다음의 경우, 스레드는 자동으로 세이프포인트 상태가 된다.
- 모니터에서 차단된다.
- JNI 코드를 실행한다.


다음의 경우, 스레드가 꼭 세이프포인트 상태가 되는 것은 아니다.
- 바이트코드를 실행하는 도중(인터프리티드 모드)
- OS가 인터럽트를 걸었다.

## 7.2.2 삼색 마킹

삼색 마킹 알고리즘은 다음 순으로 진행된다.
1. GC 루트를 흰색 표시한다.
2. 다른 객체는 모두 흰색 표시한다.
3. 마킹 스레드가 회색 노드로 랜덤하게 이동한다.
4. 마킹 스레드가 흰색 표시된 자식 노드가 있는 노드를 만나면, 먼저 그 자식 노드를 모두 회색 표시한 뒤, 해당 노드를 검은색 표시한다.
5. 회색 노드가 하나도 남지 않을 때까지 위 과정을 되풀이한다.
6. 검은색 객체는 모두 접근 가능한 것이므로 살아남는다.
7. 흰색 노드는 더 이상 접근 불가한 객체이므로 수집 대상이 된다.

![image](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/86006389/2417de14-cde1-4905-a87e-f08cd8f34265)


동시 수집은 **SATB**라는 기법을 활용합니다. 즉, 수집 사이클을 시작할 때 접근 가능하나 그 이후에 할당된 객체를 라이브 객체로 간주한다. 다만 변경자 스레드가 수집하는 도중에는 검은색 상태, 안하는 동안에는 흰색 상태와 같은 단점이 있다.  
-> 이를 방지하기 위한 방법
1. 업데이트 시 '쓰기 배리어'를 이용하는 방법
2. 삼색 불변의 원칙 (동시 마킹 도중에는 절대로 검은색 객체 노드가 흰색 객체 노드를 가리킬 수 없다)을 위배할지 모를 모든 변경 사항을 큐 형태로 넣어두고, 주 단계가 끝난 다음 부차적인 '조정'단계에서 바로잡는 방법


# 7.3 CMS
CMS 수집기는 중단 시간을 아주 짧게 하려고 설계된 테뉴어드(올드) 공간 전용 수집기 이다. 보통 Parallel GC와 함께 사용한다.  

CMS는 중단 시간을 최소화하기 위해 애플리케이션 스레드 실행 중에 가급적 많은 일을 한다. 따라서 일부 수행 단계는 좀 더 복잡하다.

1. 초기 마킹(STW)
2. 동시 마킹
3. 동시 사전 정리
4. 재마킹(STW)
5. 동시 스위프
6. 동시 리셋

두 차례의 마킹 (1, 4)동안 모든 애플리케이션 스레드가 멈추고, 나머지 단계에서는 애플리케이션 스레드와 병행하여 GC를 수행한다. (한 차례 긴 STW 중단->매우 짧은 두 차례 STW 중단)  

초기 마킹을 통해서 확실한 GC 출발점을 찾는다. 이렇게 접근하면 마킹 단계에서 다른 메모리 영역은 신경 쓸 필요 없이 하나의 GC 풀에만 집중할 수 있기 때문에 유리하다.  

동시 사전 정리 단계의 목표는 재마킹 단계에서 가능한 한 STW 시간을 줄이는 것이다. 재마킹 단계는 카드 테이블을 이용해 변경자 스레드가 동시 마킹 단계 도중 영향을 끼친 마킹을 조정한다.  

워크로드에 CMS을 적용하면 다음과 같은 장단점이 있다.

1. 애플리케이션 스레드가 오랫동안 멈추지 않는다.
2. 단일 풀 GC 사이클 시간이 더 길다.
3. GMS GC 사이클이 살행되는 동안, 애플리케이션 처리율은 감소한다.
4. GC가 객체를 추적해야 하므로 메모리를 더 많이 사용한다.
5. GC 수행에 훨씬 더 많은 CPU 시간이 필요하다.
6. CMS는 힙을 압착하지 않으므로 테뉴어드 영역은 단편화 될 수 있다.

## 7.3.1 CMS 작동 원리
CMS는 대부분 애플리케이션 스레드와 동시에 작동한다. 그렇기 때문에 객체에 할당해서 사용하는데, 이러던 와중에 에덴 공간이 꽉 차버리면 어쩔 수 없이 중단이 되고, 코어 절반만 사용하기에 병렬 수집기의 영 GC보다 느려진다. 영 수집이 끝나고 일부 객체는 테뉴어드로 승격되어야 한다. 아직 CMS가 실행되는 동안에 승격된 객체는 테뉴어드로 이동시켜야 하는데, 그렇기 때문에 CMS는 조금 다른 영 수집기를 사용한다.  

![image](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/86006389/816c3ebb-9a18-44c6-ae87-ddfa3e2a42a1)


영 수집 후 승겨된 객체가 너무 많아 테뉴어드 공간조차 부족한 사태인 CMF(동시 모드 실패, concurrent mode failure)를 나타내며, JVM은 어쩔 수 없이 풀 STW를 유발하는 ParallelOld GC 수집 방식으로 돌아간다(유일한 방법). 할당압이 너무 높은 나머지 새로 승격된 객체를 올드 세대에 수용할 여력이 소진되기 전에 CMS가 올드 세대 처리를 완료할 시간이 없는 상태에 이른 것이다.  
CMF를 방지하기 위해 저지연 애플리케이션에서는 사실상 튜닝 자체가 주요 이슈이다.  


## 7.3.2 CMS 기본 JVM 플래그
CMS는 일반적으로 플래그 가짓수가 엄청 많으며, 이를 실행하는 일종의 플래그가 존재합니다.

```-XX:+UseConcMarkSweepGC```


# 7.4 G1
G1(가비지 우선)은 병렬 수집기나 CMS와는 전혀 다른 스타일의 수집기이다. 다음의 특징이 있다.

- CMS보다 튜닝하기 쉽다.
- 조기 승격에 덜 취약하다.
- 대용량 힙에서 확장성(특히, 중단 시간)이 우수하다.
- 풀 STW 수집을 없앨 수 있다.

## 7.4.1 G1 힙 레이아웃 및 영역
G1 힙은 영역(리전)으로 구성된다.  

![image](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/86006389/a94fa3fe-c247-4611-8814-f1a5a99f7c81)

```
영역 크기 : <힙 크기> / 2048
영역 개수 : <힙 크기> / <영역 크기>
```

## 7.4.2 G1 알고리즘 설계

G1수집기는 다음의 역할을 수행한다.

- 동시 마킹 단계를 이용한다.
- 방출 수집기이다.
- 통계적으로 압착한다.

G1 수집기는 워밍업을 하는 동안, GC 사이클이 한번 돌때마다 많은 '일반' 영역에서 가비지를 수집할 수 있는지 그 수치를 보관한다.  

G1 수집기는 TLAB 할당이나 서바이버 공간으로 방출, 테뉴어드 영역으로의 승격 등은 앞서 나온 다른 핫스팟 수집기와 대동소이하지만, **세대를 구성하는 영역이 연속되지 않는다**는 단점이 있다.  

G1 수집기에도 기억 세트(RSet, remembered set)라는 비슷한 장치로 영역을 추적한다. RSet은 영역별로 하나씩, 외부에서 힙 영역 내부를 참조하는 레퍼런스를 관리하기 위한 장치이다.  

## 7.4.3 G1 단계

G1의 수집단계는 다음과 같습니다.  

1. 초기 마킹 (STW)
2. 동시 루트 탐색
3. 동시 마킹
4. 재마킹 (STW)
5. 정리 (STW)
정리 단계는 어카운팅 및 RSSet '씻기'테스크를 수행하여 STW를 일으킨다.

## 7.4.4 G1 기본 JVM 플래그
```
+XX:UseG1GC
```
G1의 주목표는 중단 시간 단축이다. 따라서 최대 중단 시간을 개발자가 선정할 수 있는데, 값을 너무 잡게 잡으면 GC 서브시스템이 목표에 맞추지 못할 것이다. 

결론적으로는 8u40부터 사용하는 것을 추천하며, 저지연 워크로드에서는 아직 G1은 CMS 중단 시간보다 긴 편이라서, 순사하게 중단 시간만 놓고 봤을 때 과연 CMS류의 수집기에 필정할 정도인지는 아직 의문이다. 다만 여전히 개선되고 있다.


# 7.5 셰난도아

레드햇에서는 OpenJDK 프로젝트 일환으로 셰난도아라는 자체 수집기를 제작했다. 역시 주 목표는 (대용량 힙) 중단 시간 단축으로, 단계는 다음과 같다.  

1. 초기 마킹(STW)
2. 동시 마킹
3. 최종 마킹(STW)
4. 동시 압착  
일부 CMS, G1 단계와 비슷해보이지만 큰 차이점이 있다.

### 브록스 포인터
객체당 메모리 워드를 하나 더 써서 이전 가비지 수집 단계에서 객체가 재배치됐는지 여부를 표시하고 새버전 콘텐츠의 위치를 가리킨다.  
![image](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/86006389/a6c15f1d-e02f-4fe5-9614-cbf6989f1235)

위 그림은 셰난도아의 oop 힙 레이아웃으로, 이런 메커니즘을 '포워딩 포인터'라고 부른다.  
- 재배치되지 않은 객체의 브룩스 포인터는 그냥 메모리 다음 워드를 가리킨다.
- 동시 마킹 단계에서 힙을 죽 훑어 살아 있는 객체를 모두 마킹한다.
    - 포워딩 포인터가 있는 oop를 가리키는 객체 레퍼런스가 있으면 새 oop 위치를 직접 참조하도록 레퍼런스를 수정한다.
- 최종 마킹 단계에서 셰난도아는 STW하고 루트 세트를 재탐색한 후, 방출한 사본을 가리키도록 루트를 복사하고 수정한다.


## 7.5.1 동시 압착
GC 스레드는 다음과 같이 방출한다.  
1. 객체를 TLAB로 복사한다.
2. CAS로 브룩스 포인터가 추측성 사본을 가리키도록 수정한다.
3. 이 작업이 성공하면 압착 스레드가 승리한 것으로, 이후 이 버전의 객체는 모두 브룩스 포인터를 경유해서 액세스하게 된다.
4. 이 작업이 실패하면 압착 스레드가 실패한 것으로, 추측성 사본을 원상보구하고 승리한 스레드가 남긴 브룩스 포인터를 따라간다.
셰난도아는 동시 수집가라서 수집 사이클 동안에는 애플리케이션 스레드가 생성하는 가비지가 더 많다. 그래서 애플리케이션 실행 중에 수집을 할당 페이스에 맞추어야 한다.

## 7.5.2 셰난도아 얻기

일반적으로는 구하기 힘들고, 신경을 써야한다.  
빌드 파일을 얻었다면 다음 스위치로 셰난도아를 작동할 수 있다.
```
-XX:+UseShenandoahGC
```

# 7.6 C4(아줄 징)
Zulu는 다중 플랫폼에서 사용 가능한 OpenJDK 기반의 FOSS 솔루션이다. 징(Jing)은 리눅스에서만 쓸 수 있는 상용 플랫폼이며 OpenJDK에 있는 자바 클래스 라이브러리를 사용하며 완전히 다른 가상 머신이다.  

애플리케이션 스레드에 의해 재배치됐을지 모를 객체의 레퍼런스를 로드할 가능성이 있으므로 브룩스 포인터를 통해 새 위치를 추적한다. 로드값 배리어는 이런 패턴을 지양하고 로드한 레퍼런스 각자의 로딩이 끝나면 현재 객체 위치를 직접가리키게 하는데 이를 자가 치유 배리어라고 부른다.  

전체 GC 단계는 다음과 같다.
1. 마킹
2. 재배치
3. 재매킹
C4는 교대 압착이라는 기술로 연속적으로 압착한다. 평상시 가상 메모리 서브시스템은 프로세스 주소 공간에 가상 페이지와 하부 물리 페이지 사이의 매핑 정보를 관리한다.


# 7.7 밸런스트(IBM J9)
IBM이 제작한 JVM. 다음의 목표를 가진다.

- 대용량 자바 힙에서 중단 시간이 길어지는 현상을 개선한다.
- 중단 시간이 최악인 경우를 최소화한다.
- 불균일 기억 장치 액세스(NUMA< Non-Uniform Memory Access>) 성능을 인지하여 활용한다.  

에덴이 꽉 차면 수집이 일어나며 이를 부분 가비지 수집(Partial Garbage Collection)이라고 한다.


# 7.8 레거시 핫스팟 수집기
여러가지 수집기가 있으나 이들은 운영계 용도로는 적합하지 않으니 가급적 사용하지 않는 것이 좋다. 

## 7.8.1 Serial 및 Serial Old
Serial/SerialOld GC는 Parallel/ParallelOld GC와 작동 원리는 거의 같지만, CPU 한 코어만 사용해 GC를 수행한다. 물론 동시 수집이 안 되고, 풀 STW를 일으킨다. 최신 멀티코어 시스템에서는 절대 사용하지 말자.

## 7.8.2 증분 CMS
```
-XX:+CMSIncrementalMode
```
자바 9부터는 아예 사라졌다.

## 7.8.3 이프리케이트되어 사라진 GC 조합
자바 8부터는 권장하지 않으며 자바 9에서는 제거된 GC 플래그 조합
| 조합 | 플래그 |
| --- | --- |
| DefNew + CMS | -XX:-UseParNewGC  
-XX:+UseConcMarkSweepGC |
| ParNew + SerialOld | -XX:+UseParNewGC |
| ParNew + iCMS | -Xincgc |
| ParNew + iCMS | -XX:+CMSIncrementalMode  <BR>-XX:+UseConcMarkSweepGC |
| ParNew + iCMS | -XX:+CMSIncrementalMode <BR>-XX:+UseConcMarkSweepGC <BR>-XX:-UseParNewGC |
| CMS foreground | -XX:+UseCMSCompactAtFullCollection |
| CMS foreground | -XX:+CMSFullGCsBeforeCompaction |
| CMS foreground | -XX:+UseCMSCollectionPassing |

## 7.8.4 엡실론
엡실론 수집기는 레거시 수집기는 아니지만, **어느 운영계 환경에서건 절대 사용 금물**인 수집기이다.  
엡실론은 테스트 전용으로 설계된, 아무 일도 안 하는 시험 수집기이다. 실제로 가비지 수집 활동을 일체 하지 않는다. 따라서 엡실론이 실행되는 동안 할당된 힙 메모리는 사실상 메모리 누수이다. 절대 회수할 수 없는 메모리라서 JVM은 결구 단시간 내에 메모리가 고갈된다. 
