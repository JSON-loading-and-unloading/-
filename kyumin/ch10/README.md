# 10장 JIT 컴파일의 세계로

## JIT 컴파일 개요

* 핫스팟은 프로파일 기반 최적화(PGO)를 이용해 JIT 컴파일 여부를 판단합니다.
* 내부적으로는 핫스팟이 실행 프로그램 정보를 메소드 데이터 객체(Method Data Object, MDO)라는 구조체에 저장합니다.
* MDO는 바이트코드 인터프리터와 C1 컴파일러에서 JIT 컴파일러가 언제, 무슨 최적화를 할지 결정하는 데 필요한 정보를 기록합니다.
* 프로파일링된 프로퍼티의 '사용 빈도(hotness)'를 카운터에 계속 기록하고 기록한 값들은 프로파일링을 거치면서 차츰 사라집니다. 이로서 컴파일 큐 맨 앞에 이르렀을 때도 아직 핫한 메소드만 컴파일 됩니다.
* 프로파일링 데이터가 모이고 컴파일 결정을 내린 후엔 컴파일러별 세부 처리 절차로 넘어갑니다.
* 컴파일러는 컴파일할 코드의 내부 표현형을 빌드합니다. 물론, 구체적인 표현형은 사용하는 컴파일(C1, C2)에 따라 달라집니다.
* 핫스팟 JIT 컴파일러는 다양한 최신 컴파일러 최적화 기법을 총동원합니다.
    * 인라이닝
    * 루프 펼치기
    * 탈출 분석
    * 락 생략/확장
    * 단일형 디스패치
    * 인트린직

## 인라이닝

* 인라이닝은 호출된 메소드(피호출부)의 콘텐츠를 호출한 지점(호출부)에 복사하는 것입니다.
* 메소드 호출 시 다음과 같은 오버헤드를 제거할 수 있습니다.
    * 전달할 매개변수 세팅
    * 호출할 메소드를 정확하게 룩업
    * 새 호출 프레임에 맞는 런타임 자료 구조(지역 변수 및 평가 스택등) 생성
    * 새 메소드로 제어권 이송
    * 호출부에 결과 반환(결괏값이 있는 경우)
* 인라이닝은 JIT 컴파일러가 제일 먼저 적용하는 최적화이기에, 관문 최적화라고도합니다. 메소드 경계를 없애고 연관된 코드를 한데 모으기 때문입니다.
* 인라이닝 최적화 덕분에 개발자가 잘 조직된 재사용 가능한 코드를 사용할 수 있습니다.
* 핫스팟은 자동으로 통계치를 분석해서 관련된 코드를 어느 시점에 하나로 모을지 결정합니다.
* 인라이닝은 다른 최적화의 범위를 확장시키는 역할을 합니다.
    * 탈출 분석
    * DCE(Dead Code Elimination, 죽은 코드 제거)
    * 루프 펼치기
    * 락 생략

인라이닝 최적화의 예는 다음과 같습니다.

~~~java
public class InliningOpimize {
    public static void main(String[] args) {
//        int result = add(a,b); // 최적화 전
        int result = a + b;
    }

    private int add(int x, int y) {
        return x + y;
    }
}
~~~

### 인라이닝 제한

* 다음과 같은 항목을 VM에서 조정해야하는 경우 인라이닝 서브시스템을 제한을 걸어야 할 경우도 있습니다.
    * JIT 컴파일러가 메소드를 최적화하는 데 소비하는 시간
    * 생성된 네이티브 코드 크기(즉, 코드 캐시 메모리 사용량)
* 제약 조건이 없다면 컴파일러는 아주 깊은 호출 체인까지 인라이닝할 것입니다.
* 핫스팟은 다음 항목을 따져보며 어떤 메소드를 인라이닝할지 결정합니다.
    * 인라이닝할 메소드의 바이트코드 크기
    * 현재 호출 체인에서 인라이닝할 메소드의 깊이
    * 메소드를 컴파일한 버전이 코드 캐시에서 차지하는 공간

### 인라이닝 서브시스템 튜닝

* 매개변수를 바꿔가며 튜닝할 때에는 반드시 측정 데이터를 근거로 삼아야합니다.
* 다음 표는 인라이닝 서브시스템의 작동 방식을 제어하는 기본적인 JVM 스위치들입니다.

| 스위치                     | 디폴트(JDK8, Linux x86_64)                             | 설명                                                                |
|-------------------------|-----------------------------------------------------|-------------------------------------------------------------------|
| -XX:MaxInlineSize=<n>   | 35바이트의 바이트코드                                        | 메소드를 이 크기 이하로 인라이닝합니다.                                            |
| -XX:FreqInlineSize=<n>  | 325바이트의 바이트코드                                       | (자주 호출되는)'핫' 메소드를 이 크기 이하로 인라이닝합니다.                               |
| -XX:InlineSmallCode=<n> | 1000바이트의 네이티브 코드(단계 없음)<br/>2000바이트의 네이티브 코드(단계 있음) | 코드 캐시에 이 수치보다 더 많은 공간을 차지한 최종 단계 컴파일이 이미 존재할 경우 메소드를 인라이닝하지 않습니다. |
| -XX:MaxInlineLevel=<n>  | 9                                                   | 이 수준보다 더 깊이 호출 프레임을 인라이닝하지 않습니다.                                  |

## 루프 펼치기

* 루프 내부의 메소드 호출을 전부 인라이닝하면, 컴파일러는 루프를 한번 순회할 때마다 비용이 얼마나 드는지, 반복 실행되는 코드는 크기가 얼마나 되는지 분명해집니다.
* 이 정보를 통해 컴파일러는 매번 순회할 때마다 루프 처음으로 되돌아가는 횟수를 줄이기 위해 루프를 펼칠 수 있습니다.
* 백 브랜치(한번 순회를 마치고 다시 루프문 처음으로 돌아가는 것)가 일어나면 그때마다 CPU는 유입된 명령어 파이프라인을 덤프하기에 성능상 바람직하지 않습니다.
* 보통 루프 바디가 짧을수록 백 브랜치 비용은 상대적으로 높기에 핫스팟은 다음과 같은 기준으로 루프 펼치기 여부를 결정합니다.
    * 루프 카운터 변수 유형(대부분 객체 아닌 int나 long형을 사용)
    * 루프 보폭(한번 순회할 때마다 루프 카운터 값이 얼마나 바뀌는가)
    * 루프 내부의 탈출 지점 개수(return 또는 break)
* 루프를 돌며 배열 원소에 액세스할 때 핫스팟은 루프를 세 구역으로 나누어 배열 경계 검사를 제거합니다.

| 루프 구역 | 경계 검사? | 설명                                         |
|-------|--------|--------------------------------------------|
| 사전 루프 | 예      | 초기 순회는 경계 검사를 합니다.                         |
| 메인 루프 | 아니오    | 루프 보폭을 이용해 경계 검사를 안 해도 순회 가능한 최대 횟수를 계산한다. |
| 사후 루프 | 예      | 나머지 순회는 경계 검사를 합니다.                        |


### 루프 펼치기 정리

* 핫스팟은 다양한 최적화 기법으로 루프 펼치기를 합니다
  * 카운터가 int,short,char형일 경우 루프를 최적화합니다.
  * 루프 바디를 펼치고 세이프포인트 폴을 제거합니다.
  * 루프를 펼치며 백 브랜치 횟수가 줄고 그만큼 분기 예측 비용도 덜 듭니다.
  * 세이프포인트 폴을 제거하면 루프를 순회할 때마다 하는 일이 줄어듭니다.

## 탈출 분석

* 핫스팟은 어떤 메소드가 내부에서 수행한 작업을 그 메소드 경계 밖에서도 볼 수 있는지, 또는 부수 효과를 유발하지 않는지 범위 기반 분석을 통해 판별합니다. 이를 탈출 분석이라고 합니다.
* 핫스팟은 탈출 분석 단계 중, 잠재적으로 탈출한 객체를 세 가지 유형으로 분류합니다.

~~~
typedef enum {
  NoEscape  = 1,  // 객체가 메소드/스레드를 탈출하지 않고
                  // 호출 인수로 전달되지 않으며,
                  // 스칼라로 대체 가능합니다.
  ArgEscape = 2,  // 객체가 메소드/스레드를 탈출하지 않지만
                  // 호출 인수로 전달되거나 레퍼런스로 참조되며,
                  // 호출 도중에는 탈출하지 않습니다.
  GlobalEscape =3 // 객체가 메소드/스레드를 탈출합니다.
}
~~~

### 힙 할당 제거

* 핫스팟의 탈출 분석 최적화는 개발자가 객체 할당률을 신경 쓰지 않고도 자바 코드를 자연스레 작성할 수 있도록 설계됐습니다.
* 할당된 객체가 메소드를 탈출하지 않는다는 사실을 밝히면(NoEscape) VM은 스칼라 치환이라는 최적화를 적용해 객체 필드를 마치 처음부터 객체 필드가 아닌 지역 변수였던 것처럼 스칼라 값으로 바꿉니다. 그 후 레지스터 할당기라는 핫스팟 컴포넌트에 의해 CPU 레지스터 속으로 배치됩니다.
* 탈출 분석의 목표는 힙 할당을 막을 수 있는지 추론하는 것입니다. 이를 통해 객체는 스택에 자동 할당되며 GC 압박을 조금이나마 덜 수 있습니다.

### 락과 탈출 분석

* 핫스팟은 탈출 분석 및 관련 기법을 통해 락 성능도 최적화합니다.
* 락 최적화의 핵심은 다음과 같습니다.
  * 비탈출 객체에 있는 락은 제거합니다(락 생략)
  * 같은 락을 공유한, 락이 걸린 연속된 영역은 병합합니다(락 확장)
  * 락을 해제하지 않고 같은 반복 획득한 블록을 찾습니다(중첩 락)
* 락 확장 최적화는 기본 활성화되어 있지만, VM 스위치 -XX:-EliminateLocks로 해제하여 그 영향도를 살펴볼 수 있습니다.
* 중찹 락 최적화도 기본 활성화이지만, VM 스위치 -XX:-EliminateNestedLocks로 끌 수 있습니다.

### 탈출 분석의 한계

* 탈출 분석 역시 다른 최적화 기법들처럼 트레이드오프가 있습니다.
* 힙이 아니라도 다른 어딘가에는 할당을 해야 하는데, CPU 레지스터나 스택 공간은 상대적으로 희소한 리소스입니다.
* 기본적으로 원소 64개 이상인 배열은 핫스팟에서 탈출 분석의 혜택을 볼 수 없습니다. 이는 -XX:EliminateAllocationArraySizeLimit=<n>을 통해 조정가능합니다.
* 핫스팟은 부분 탈출 분석(흐름에 민감한 탈출 분석입니다.)을 지원하지 않습니다.
* 객체가 어느 분기점에있든 메소드 범위를 탈출하면 힙에 객체를 할당하지 않는 최적화는 적용되지 않습니다.

## 단형성 디스패치

* 핫스팟 C2 컴파일러가 수행하는 추측성 최적화는 대부분 경험적 연구 결과를 토대로 합니다. 단형성 디스패치 기법도 이런 부류 중 하나입니다.
* '사람이 작성한 코드를 보면 십중팔구 각 호출부마다 딱 한 가지 런타임 타입이 수신자 객체 타입이 된다'가 요지입니다.
* 어떤 객체에 있는 메소드를 호출할 때, 그 메소드를 최초로 호출한 객체의 런타임 타입을 알아내면 그 이후의 모든 호출도 동일한 타입일 가능성이 큽니다.
* 이 추측성 가정이 옳다면 해당 호출부의 메소드 호출을 최적화할 수 있습니다.
* 예로, vtable에서 에둘러 메소드를 찾을 필요가 없습니다. 항상 타입이 같으면 호출 대상을 계산후 invokevirtual 명령어를 퀵 타입 테스트 후 컴파일드 메소드 바디로 분기하는 코드로 치환하면 됩니다.
* 핫스팟은 이형성 디스패치라는 최적화도 지원합니다. 그래서 서로 다른 두 타입을 단형성 디스패치와 같은 방법으로, 호출부마다 상이한 두 klass 워드를 캐시해서 처리합니다.
* 단형도, 이형도 아닌 호출부를 다형성이라고 합니다.

## 인트리직

* 인트리직은 JIT 서브시스템이 동적 생성하기 이전에 JVM이 이미 알고 있는, 고도로 튜닝된 네이티브 메소드 구현체를 가리키는 용어입니다.
* JVM은 기동 직후 런타임에 자신을 실행한 하드웨어의 CPU를 꼼꼼히 살펴보고 사용 가능한 프로세서의 기능을 목록화합니다. 즉, 어떤 식으로 최적화할지 코드 컴파일 타임에 결정할 필요 없이 런타임까지 미룰 수 있습니다.
* 새 인트리직을 추가할 때는 복잡도가 증가하는 것과 유용하게 잘 쓰는 것 사이에서 저울질을 해봐야합니다.
* 인트리직은 정말 자주 쓰이는 작업에 한해서만 성능에 큰 영향을 미칠 수 있습니다.

## 온-스택 치환

* 자바의 main() 메소드와 같이 컴파일을 일으킬 정도로 호출 빈도가 높지는 않지만 메소드 내부에 핫 루프가 포함된 경우가 있습니다.
* 핫스팟은 이런 코드를 온-스택 치환(OSR)을 이용해 최적화합니다.
* 인터프리터가 루프 백 브랜치 횟수를 세어보고 특정 한계치를 초과하면 루프를 컴파일한 후 치환해서 실행합니다.
* 컴파일러는 컴파일 이전의 루프 내에서 액세스하는 지역 변수와 락 등의 상태 변화가 컴파일 이후에도 반영되도록 보장해야 합니다.
* 컴파일드 루프를 벗어난 후 실행을 재개하는 지점에서 모든 상태 변화가 가시적이어야 합니다.
* 핫스팟의 C1,C2 JIT 컴파일러는 모두 OSR 컴파일을 수행합니다.

## 세이프포인트 복습

* 다음의 경우 전체 스레드가 세이프포인트에 걸립니다.
  * GC STW 이벤트
  * 메소드를 역최적화
  * 힙 덤프를 생성
  * 바이어스 락을 취소
  * 클래스를 재정의(가령, 인스트루먼테이션 용도)
* 컴파일드 코드에서 세이프포인트 체크 발급은 JIT 컴파일러가 담당하며, 핫스팟에서는 다음 지점에 세이프포인트 체크 코드를 넣습니다.
  * 루프 백 브랜치 지점
  * 메소드 반환 지점
* 경우에 따라 스레드가 세이프포인트에 도달하려면 어느 정도 시간이 소요될 수 있습니다.

## 코어 라이브러리 메소드

### 인라이닝하기 적합한 메소드 크기 상한

* 인라이닝을 할지 말지는 메소드의 바이트코드 크기로 결정되므로 클래스 파일을 정적 분석하면 인라이닝을 하기에 지나치게 큰 메소드를 걸러낼 수 있습니다.
* 메소드를 작게 만들면 인라이닝 가짓수가 늘어납니다.
* 런타임 데이터가 다양해질수록 여러 가지 상이한 경로를 거치면서 코드가 '핫'하게 될 가능성이 있습니다.

### 컴파일하기 적합한 메소드 크기 상한

* 핫스팟에는 메소드 크기가 어느 이상 초과하면 컴파일되지 않는 한계치(8000바이트)가 있습니다.
* 디버그 JVM에서만 -XX:HugeMethodLimit=<n> 스위치로 컴파일 가능한 메소드 바이트코드의 최대 크기를 설정할 수 있습니다.

> 참조
> 
> int vs long(https://stackoverflow.com/questions/73651465/java-for-loop-using-int-vs-long)
