# 12장 동시 성능 기법

* 애플리케이션 스레드가 하나인 JVM 애플리케이션도 멀티코드어라는 혜택을 누릴 수 있습니다.
* 최신 하드웨어를 오롯이 활용하려면 자바 개발자는 최소한 동시성이란 무엇인지, 그것이 애플리케이션 성능에 끼치는 영향은 무엇인지 최소한의 배경지식은 갖고 있어야 합니다.

## 12.1 병렬성이란?

* 요즘 멀티코어 세상에서는 암달의 법칙이 연산 태스크의 실행 속도를 향상시키는 핵심 요소입니다.
* 순차실행 파트 S, 총 태스크 소요 시간 T 일때 자유롭게 사용할 수 있는 프로세서 개수가 N이라하면 전체 태스크 소요시간은 **S+(1/N)*(T-S)** 라고 할 수 있습니다.
* 위 수식을 통해 프로세서를 늘려도 순차 실행 시간 이상 줄일 수 없습니다.
* 보통 데이터 공유 없이 워크로드를 나누어 여러 워커 스레드에 분산시킵니다.
* 스레드끼리 상태나 데이터를 공유하기 시작하면 워크로드는 점차 복잡해지면서 결국 일부 태스크는 순차 처리하게 되고 통신 오버헤드가 발생합니다.
* 즉, 상태를 공유하는 워크로드는 무조건 정교한 보호/제어 장치가 필요합니다.

### 12.1.1 자바 동시성 기초

* 동기화를 사용할 때에는 아주 신중하게 설계하고 미리 잘 따져봐야 한다는 부담이 따릅니다. Synchronized를 남용한다면 오히려 성능이 더 느려질 수 있습니다.
* 처리율 향상은 동시성을 부여하는 전체 목표와 상충합니다. 코드 베이스를 병렬화하는 작업을 진행할 때에는 복잡도가 늘어난 대가로 얻은 혜택을 충분히 입증할 만한 성능 테스트가 수반되어야 합니다.

## 12.2 JMM의 이해

* 자바 명세에서 JMM은 수학적으로 기술된 메모리 형태로 등장합니다.
* JMM은 다음 질문에 답을 찾는 모델입니다.
  * 두 코어가 같은 데이터를 액세스하면 어떻게 되는가?
  * 언제 두 코어가 같은 데이터를 바라본다고 장담할 수 있는가?
  * 메모리 캐시는 위 두 질문의 답에 어떤 영향을 미치는가?
* 자바 플랫폼은 공유 상태를 어디서 액세스하든지 JMM이 약속한 내용을 반드시 이행합니다. 이 약속은 순서에 관한 보장과 여러 스레드에 대한 업데이터 가시성 보장, 두 가지로 분류됩니다.
* 고수준에서 JMM 같은 메모리 모델은 두 가지 방식으로 접근합니다.
  * 강한 메모리 모델 : 전체 코어가 항상 같은 값을 바라본다.
  * 악한 메모리 모델 : 코어마다 다른 값을 바라볼 수 있고 그 시점을 제어하는 특별한 캐시 규칙이 있다.
* JMM은 최소한의 요건에 불과합니다.
* JMM은 다음 기본 개념을 기반으로 애플리케이션을 보호합니다.
  * Happend-Before(~보다 먼저 발생) : 한 이벤트는 무조건 다른 이벤트보다 먼저 발생한다.
  * Synchronizes-With(~와 동기화) : 이벤트가 객체 뷰를 메인 메모리와 동기화시킨다.
  * As-If-Serial(순차적인 것처럼) : 실행 스레드 밖에서는 명령어가 순차 실행되는 것처럼 보인다.
  * Release-Before-Acquire(획득하기 전에 해제) : 한 스레드가 걸린 락을 다른 스레드가 그 락을 획득하기 전에 해제한다.
* 동기화를 통한 락킹은 가변 상태를 공유하는 가장 중요한 기법으로, 동시성을 다루는 자바의 근본적인 관점을 대변합니다.
* 자바에서 스레드는 객체 상태 정보를 스스로 들고 다니며, 스레드가 변경한 내용은 메인 메모리로 곧장 반영되고 같은 데이터를 액세스하는 다른 스레드가 다시 읽는 구조입니다.
* 기존 자바 synchronized 락은 여러 한계점이 노출됐습니다. 시간이 갈수록 그 증상이 심각해졌습니다.
  * 락이 걸린 객체에서 일어나는 동기화 작업은 모두 균등하게 취급된다.
  * 락 획득/해제는 반드시 메소드 수준이나 메소드 내부의 동기화 블록 안에서 이루어져야 한다.
  * 락을 얻지 못한 스레드는 블로킹된다. 락을 얻지 못할 경우, 락을 얻어 처리를 계속하려고 시도하는 것조차 불가능하다.
* synchronized를 사용할때에는 쓰기 뿐만아닌 읽기에도 락을 걸어야합니다.

## 12.3 동시성 라이브러리 구축

* JMM은 아주 성공적인 작품이지만 이해하기가 어렵고 실제로 응용하는 건 훨씬 더 어렵습니다.
* 자바 5부터 언어 수준에서 지원하는 기능에서 탈피해서 고급 동시성 라이브러리와 툴을 자바 클래스 라이버리의 일부로 표준화하려는 움직임이 확산되는 추세입니다.
* java.util.concurrent 패키지는 멀티 스레드 애플리케이션을 자바로 더 쉽게 개발할 수 있게 세심하게 설계된 라이브러리입니다. 이 라이브러리를 골라 쓰면 '스레드 핫' 성능도 함께 좋아집니다.
* 이 라이브러리를 구성하는 핵심 요소는 몇 가지 일반 카테고리로 분류됩니다.
  * 락, 세마포어
  * 아토믹스
  * 블로킹 큐
  * 래치
  * 실행자

### 12.3.1 Unsafe

* Sun.misc.Unsafe는 내부 구현 클래스입니다. 하지만 표준 자바 플랫폼 API가 아닙니다.
* Unsafe 클래스를 사용하는 코드는 엄밀히 말해 핫스팟 VM에 직접 연결되고 깨질 우려가 높습니다.
* JVM의 표준 로직을 무너뜨리는 수단인 Unsafe는 거의 모든 주요 프레임워크의 구현 핵심부를 차지하게 됐습니다.
* 다음은 Unsafe로 할 수 있는 일들입니다.
  * 객체는 할당하지만 생성하는 실행하지 않는다.
  * 원메모리에 액세스하고 포인터 수준의 연산을 수행한다.
  * 프로세서별 하드웨어 특성을 이용한다.
* 이를 통해 다음과 같은 고수준의 프레임워크 기능을 구현할 수 있습니다.
  * 신속한 (역)직렬화
  * 스레드-안전한 네이티브 메모리 액세스
  * 아토믹 메모리 연산
  * 효율적인 객체/메모리 레이아웃
  * 커스텀 메모리 펜스
  * 네이티브 코드와의 신속한 상호작용
  * JNI에 관한 다중 운영체제 대체물
  * 배열 원소에 volatile하게 액세스

### 12.3.2 아토믹스와 CAS

* 아토믹스는 값을 더하고 증감하는 복합 연산을 하며 get()으로 계산한 결괏값을 돌려받습니다.
* 아토믹 변수는 volatile 확장판이라고 할 수 있지만, volatile보다 더 유연해서 상태 의존적 업데이트를 수행할 수 있습니다.
* 아토믹스를 효과적으로 활용하려면 주어진 기능 외에 임의로 코드를 구현해서 섞어 쓰지 말아야합니다.
* 아토믹은 락-프리하므로 데드락은 있을 수 없습니다. 비교 후 업데이트하는 작업이 실패할 경우를 대비해 내부적인 재시도 루프가 동반됩니다.

### 12.3.3 락과 스핀락

* 인트린직 락은 유저 코드에서 OS를 호출함으로써 작동합니다. OS를 이용해 스레드가 따로 신호를 줄 때까지 무한정 기다리게 만드는 겁니다.
* 블로킹된 스레드를 CPU에 활성 상태로 놔두고 아무 일도 시키지 않은 채 락을 손에 넣을 때까지 'CPU를 태워가며' 계속 재시도하게 만드는 것을 스핀락이라고 합니다.

## 12.4 동시 라이브러리 정리

### 12.4.1 java.util.concurrent 락

* 락은 자바 5부터 개편되어 좀 더 일반화한 락 인터페이스가 java.util.concurrent.locks.Lock에 추가됐습니다. 이 인터페이스를 사용하면 인트린직 락보다 더 많은 일을 할 수 있습니다.
* Lock 클래스의 메소드는 다음과 같습니다.
  * lock() : 기존 방식대로 락을 획득하고 락을 사용할 수 있을 때까지 블로킹합니다.
  * newCondition() : 락 주위에 조건을 설정해 좀 더 유연하게 락을 활용합니다. 락 내부에서 관심사를 분리할 수 있습니다.
  * tryLock() : 락 획득하려고 시도합니다. 덕분에 스레드가 락을 사용할 수 없는 경우에도 계속 처리를 진행할 수 있습니다.
  * unlock() : 락을 해제합니다. lock()에 대응되는 후속 호출입니다.

### 12.4.2 읽기/쓰기 락

* 애플리케이션에 있는 컴포넌트는 대부분 읽기와 쓰기 작업 횟수가 많이 차이납니다.
* ReentrantReadWriteLock 클래스의 ReadLock과 WriteLock을 활용하면 여러 스레드가 읽기 작업을 하는 도중에도 다른 읽기 스레드를 블로킹하지 않게 할 수 있습니다.
* 블로킹은 쓰기 작업을 할 때에만 일어납니다.
* 락을 '공정 모드'로 세팅하면 성능을 떨어지지만 스레드를 반드시 순서대로 처리하게 할 수 있습니다.

### 12.4.3 세마포어

* 세마포어는 풀 스레드나 DB 접속 객체 등 여러 리소스의 액세스를 허용하는 독특한 기술을 제공합니다.
* Semaphore 클래스의 acquire() 메소드는 사용 가능한 퍼밋 수를 하나씩 줄이는데, 더 이상 쓸 수 있는 퍼밋이 없을 경우 블로킹합니다.
* release() 메소드는 퍼밋을 반납하고 대기 중인 스레드 중에서 하나에게 해제한 퍼밋을 전달합니다.
* 세마포어를 사용하면 리소스가 블로킹되거나 리소스를 기다리는 큐가 형성될 가능성이 커서 스레드 고갈을 막기 위해 처음부터 공정모드로 초기화하는 경우가 많습니다.
* 퍼밋이 하나뿐인 세마포어는 뮤텍스와 동등합니다.
* 뮤텍스는 뮤텍스가 걸린 스레드만 해제할 수 있는 반면, 세마포어는 비소유 스레드도 해제할 수 있습니다. 데드락을 강제로 해결해야 할 경우 필요한 방법입니다.

### 12.4.4 동시 컬렉션

* 자바 동시 컬렉션은 시간이 지나면서 스레드 핫 성능을 최고로 뽑아낼 수 있는 방향으로 조금씩 수정/보와돼 왔습니다.
* Map 구현체(ConcurrentHashMap)는 버킷 또는 세그먼트로 분할된 구조를 최대한 활용하여 실질적인 성능 개선 효과를 얻습니다.
  * 각 세그먼트는 자체 락킹 정책, 즉 자신만의 락 세트를 가질 수 있습니다. 
  * 읽기/쓰기 락을 둘 다 소유한 상태에서 여러 읽기 스레드가 ConcurrentHashMap 곳곳을 읽는 동안, 쓰기가 필요한 경우 어느 한 세그먼트만 락을 거는 행위도 가능합니다.
* 이터레이터는 일종의 스냅샷으로 획득하기 때문에 ConcurrentModificationException이 발생할 일이 없습니다.
* 자바 5부터 CopyOnWriteArrayList, CopyOnWriteArraySet이 새로 도입돼서 어떤 사용 패턴에서는 멀티스레드 성능이 향상될 수 있습니다.
  * 이 두 클래스에서 자료 구조를 변경하면 배킹 배열 사본이 하나 더 생성됩니다. 덕분에 기존 이터레이터는 예전 배열을 계속 탐색할 수 있으며, 레퍼런스가 하나도 없게 되면 이 예전 배열 사본은 가비지 수집 대상이 됩니다.

### 12.4.5 래치와 배리어

* 래치와 배리어는 스레드 세트의 실행을 제어하는 유용한 기법입니다.
* 래치는 애플리케이션을 처음 시작하거나 멀티스레드를 테스트하는 도중, 캐시 적재 등의 작업을 할 때 아주 유용합니다.

## 12.5 실행자와 태스크 추상화

* 일반 자바 프로그래머는 저수준의 스레드 문제를 직접 처리하기보다는, java.util.concurrent 패키지에서 적절한 수준으로 추사와된 동시 프로그래밍 지우너 기능을 골라 쓰는 편이 좋습니다.
* 스레딩 문제가 거의 없는 추상화 수준은 동시 태스크, 즉 현재 실행 컨텍스트 내에서 동시 실행해야 할 코드나 작업 단위로 기술할 수 있습니다.

### 12.5.1 비동기 실행이란?

* 자바에서 태스크를 추상화하는 방법은, 값을 반환하는 태스크를 Callable 인터페이스로 나타내는 것입니다.
* Callable<V>은 call() 메소드 하나만 있는 제네릭 인터페이스로, call() 메소드는 V형 값을 반환하되 결괏값을 계산할 수 없으면 예외를 던집니다.
* 스레드가 살아 있는 동안 예외를 처리하는 일은 프로그래밍 세계의 난제 중 하나로, 정확히 관리하지 않으면 자바 프로그램이 엉뚱한 상태에 빠져버릴 수 있습니다.
* 자바 스레드는 OS 수준의 포로세서와 동등하며, 어떤 OS에서는 프로세서 생성 비용이 비싼 경우도 있습니다.
* ExecutorService는 관리되는 스레드 풀에서 태스크 실행 메커니즘을 규정한 인터페이스 입니다.
* Executors는 헬퍼 클래스로, 선택한 로직에 따라 서비스 및 기반 스레드 풀을 생성하는 팩토리 메소드 시리즈를 제공합니다.
  * newFixedThreadPool(int nThreads) : 크기가 고정된 스레드 풀을 지닌 ExecutorService를 생성합니다.
  * newCachedThreadPool() : 필요한 만큼 스레드를 생성하되 가급적 스레드를 재사용하는 ExecutorService를 생성합니다.
  * newSingleThreadExecutor() : 스레드 하나만 가동되는 ExecutorService를 생성합니다.
  * newScheduledThreadPool(int corePoolSize) : 미래 특정 시점에 태스크를 실행시킬 수 있도록 Callable과 지연 시간을 전달받는 메소드들이 있습니다.
* 일단 태스크가 제출되면 비동기로 처리되며, 태스크를 제출한 코드는 스스로를 블로킹할지, 결과를 폴링할지 선택할 수 있습니다.

### 12.5.2 ExecutorService 선택하기

* 올바른 ExecutorService를 선택하면 비동기 프로세스를 적절히 잘 제어할 수 있고, 풀 스레드 개수를 정확히 잘 정하면 성능이 뚜렷이 향상될 수 있습니다.
* 전체 애플리케이션 설정에 따라 ExecutorService를 경험적으로 튜닝해야 할 경우도 있습니다. 어떤 하드웨어에서 서비스가 실행 중인지, 어떤 리소스에서 경합이 발생했는지 파악하는 일이 전체 튜닝 그림을 그리는 데 매우 중요한 역할을 합니다.
* 가장 흔히 사용하는 지표가 코어 수 대비 풀 스레드 수입니다.
* 경합이 어느 한계치에 이르면 동시 처리 모드로 전환하더라도 성능 효과는 반감될 수 있습니다.

### 12.5.3 포크/조인

* 자바는 개발자가 손수 스레드를 제어/관리하지 않아도 되도록 다양한 방식으로 동시성 문제를 처리합니다.
* 자바 7부터 등장한 포크/조인 프레임워크는 멀티 프로세서 환경에서 효율적으로 작동하는 새로운 API를 제공합니다.
* 이 프레임워크는 ForkJoinPool라는 새로운 ExecutorService 구현체에 기반합니다.
* ForkJoinPool 클래스는 관리되는 스레드 풀을 제공하며, 다음과 같은 두 가지 특성이 있습니다.
  * 하위 분할 태스크를 효율적으로 처리할 수 있습니다.
  * 작업 빼앗기 알고리즘을 구현한다.
* 하위 분할 태스크는 표준 자바 스레드보다 가벼운, 스레드와 비슷한 엔티티로, ForkJoinTask 클래스가 지원하는 기능입니다.
* ForkJoinTask의 핵심은 자신을 더 작은 서브태스크로 분할하는 능력입니다.
* ForkJoinPool에 있는 commonPool()이라는 정적 메소드는 전체 시스템 풀의 레퍼런스를 반환합니다. 덕분에 개발자가 직접 자체 풀을 생성해서 공유할 필요가 없고, 공용 풀은 지연 초기화되므로 필요한 시점에 생성됩니다.
* 풀 크기는 Runtime.getRuntime().availableProcessors()-1로 정해집니다.
* -Djava.util.concurrent.ForkJoinPool.common.parallelism=<n>을 통해 직접 설정할 수 있습니다.

## 12.6 최신 자바 동시성

* 원래 자바 동시성은 실행 시간이 긴 블로킹 태스크를 다른 스레드와 함께 실행할 수 있게 인터리빙하는 환경을 염두에 두고 설계됐습니다.

### 12.6.1 스트림과 병렬 스트림

* 자바 8의 가장 큰 변경 사항은 람다와 스트림입니다.
* 람다/스트림은 함께 사용하면 자바 개발자도 함수형 프로그래밍의 혜택을 누릴 수 있습니다.
* 자바 스트림은 데이터 소스에서 원소를 퍼 나르는 불변 데이터 시퀀스로, 모든 타입의 데이터 소스에서 추출할 수 있습니다.
* 스트림의 parallelStream()을 이용하면 병렬로 데이터를 작업 후 그 결과를 재조합할 수 있습니다. 이 메소드를 호출하면 Spliterator를 써서 작업을 분할하고 공용 포크/조인 풀에서 연산을 수행합니다.
* 컬랙션이 작을수록 직렬 연산이 병렬 연산보다 훨씬 빠릅니다. parallelStream()을 사용할 때에는 성능 테스트를 해보고 사용해야 합니다.

### 12.6.2 락-프리 기법

* 락-프리 기법은 블로킹이 처리율에 악영향을 미치고 성능을 저하시킬 수 있다는 전제하에 시작합니다.
* 블로킹의 문제점은, 스레드를 컨텍스트 교환할 기회가 있다는 사실을 OS에 의지해 나타낸다는 점입니다.
* 중단/재개시키는 과정에서도 제법 많은 시간이 소요될 수 있기에 락킹은 락-프리한 기법보다 훨씬 느립니다.
* 락-프리 기법은 CPU 코어를 차지하는 건 사용률, 전력 소비 측면에서 비용이 듭니다.
* 이런 종류의 처리율을 요하는 애플리케이션을 맡은 프로그래머는 소프트웨어를 저수준까지 잘이해하고 실행해야 합니다.

### 12.6.3 액터 기반 기법

* 최근 수년간, 태스크를 스레드 하나보다 더 작게 나타내려는 다양한 접근 방식이 고안됐습니다. 앞선 ForkJoinTask 클래스도 그중 하나지만, 액터라는 패러다임도 아주 유명합니다.
* 액터는 그 자체로 고유한 상태와 로직을 가지고 있습니다. 동시에 다른 액터와 소통하는 메일박스 체계를 갖춘, 작고 독립적인 처리 단위입니다.
* 액터는 가변적인 상태는 일체 공유하지 않고 오직 불변 메시지를 통해서만 상호 통신함으로써 상태를 관리합니다.
* 액터 간 통신은 비동기적이며, 액터는 메시지 수신에 반응하여 정해진 일을 합니다.
* 액터는 병렬 시스템 내부에서 하나의 네트워크를 형성하고 그 속에서 각자 나름대로 작업을 수행함으로써 하부 동시 모델을 완전히 추상화한 모습을 바라봅니다.
* 액터는 동일한 프로세스 내부에서 존재하지만 꼭 그래야 한다는 법은 없습니다. 그래서 다중 처리가 가능하며 심지어 멀티 머신에 걸쳐 있는 상태로도 작동 가능한 멋진 이점이 있습니다.
* 멀티 머신과 클러스터링 덕분에 액터 기반 시스템은 어느 정도 내고장성이 필요한 상황에서 효과적으로 작동합니다.
* 협동 체제에서 액터를 제대로 작동시키기 위해 대부분 페일-패스트 전략을 구사합니다.
* 액터 모델은 대체로 동시성 애플리케이션 개발자에게 유용한 툴인 건 분명하지만, 그렇다고 다른 기법 전체를 대체할 수 있는 범용 툴은 아닙니다.
