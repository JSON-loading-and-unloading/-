# 8장 GC 로깅, 모니터링, 튜닝, 툴

## 8.1 GC 로깅 개요

* GC 로그는 시스템이 내려간 원인의 단서를 찾는 **콜드 케이스** 분석을 할 때 유용합니다.
* 파일에 쓰인 로그르 분석하는 작업이므로 애플리케이션 프로세스가 살아 있지 않아도 됩니다.
* GC 로깅은 오버헤드가 거의 없는 작업이므로 JVM 프로세스는 항상 로깅을 켜두어야 합니다.

## 8.1.1 GC 로깅 켜기

다음 스위치는 필수 GC 로깅 플래그입니다.

~~~
-Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintTenuringDistribution 
-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps
~~~

|플래그| 작용                                           |
|:---|:---------------------------------------------|
|-Xloggc:gc.log| GC 이벤트를 로깅할 파일을 지정합니다.                       |
|-XX:+PrintGCDetails| GC 이벤트 세부 정보를 로깅합니다.                         |
|-XX:+PrintTenuringDistribution| 툴링에 꼭 필요한, 부가적인 GC 이벤트 세부 정보를 추가합니다.         |
|-XX:+PrintGCTimeStamps| GC 이벤트 발생 시간을 (VM 시작 이후 경과한 시간을 초 단위로)출력합니다. |
|-XX:+PrintGCDateStamps| GC 이벤트 발생 시간을 (벽시계 시간 기준으로) 출력합니다.           |

다음은 필수 플래그에서 성능 엔지니어가 주의해야 할 사항입니다.
* 기존 플래그 verbose:gc는 지우고 대신 PrintGCDetails를 사용해야 합니다.
* PrintTenuringDistribution은 다소 독특한 플래그로, 이 플래그가 제공하는 정보를 사람이 이용하기는 어렵습니다. 중요한 메모리압(메모리 할당 압박)효과, 조기 승격 등의 이벤트 계산 시 필요한 기초 데이터를 제공합니다.
* PrintGCDateStamps와 PrintGCTimeStamps는 둘 다 필요합니다. 전자는 GC 이벤트와 애플리케이션 이벤트(로그 파일)를, 후자는 GC와 다른 내부 JVM 이벤트를 각각 연관짓는 용도로 쓰입니다.

로그 순환 관련 플래그는 다음과 같습니다. 운영계 환경에 요긴합니다. 로그 순환 정책은 운영팀과 협의해서 합리적으로 수립해야 합니다.

|플래그|작용|
|:---|:---|
|-XX:+UseGCLogFileRotation|로그 순환 기능을 켭니다.|
|-XX:+NumberOfGCLogFiles=<n>|보관 가능한 최대 로그파일 개수를 설정합니다.|
|-XX:+GCLogFileSize=<size>|순환 직전 각 파일의 최대 크기를 설정합니다.|

### 8.1.2 GC 로그 VS JMX

* VisualGC는 자바 관리 확장(JMX) 인터페이스를 통해 JVM 데이터를 수집하여 힙 상태를 실시간으로 표시하는 툴입니다.
* JMX는 GC에 영향을 주기에 성능 엔지니어는 다음을 숙지해야합니다.
  * GC 로그 데이터는 실제로 가비지 수집 이벤트가 발생해서 쌓이지만, JMX 데이터를 샘플링하여 얻습니다.
  * GC 로그 데이터는 캡쳐 영향도가 거의 없지만, JMX는 프록시 및 원격 메소드 호출(RMI) 과정에서도 암묵적인 비용이 듭니다.
  * GC 로그 데이터에는 자바 메모리 관리에 연관된 성능 데이터가 50가지 이상 있지만, JMX는 10가지도 안됩니다.
* JMX는 성능 데이터 원천으로서 스트리밍된 데이터를 즉시 제공한다는 점에서 GC 로그보다 낮습니다.
* JMX로 가져온 빈은 표준 빈이고 쉽게 액세스 할 수 있습니다.

### 8.1.3 JMX의 단점

* JMX는 대부분 런타임을 샘플링하여 현재 상태를 업데이트 받습니다.
* 가비지 수집은 언제 실행될지 예측할 수 없기에 각 수집 사이클 전후의 메모리 상태 역시 알 수 없습니다. 즉, GC 데이터를 깊이 있게, 정확하게 분석할 수 없습니다.
* JMX로 얻은 데이터는 장기적 추이를 파악하는 정도로 쓸 수 있습니다.
* JMX의 데이터 수집방식으로 인해 메모리압을 분석할 수 없습니다.
* JMXConnector 명세를 구현한 코드는 내부적으로 RMI에 의존하므로 RMI 기반 통신 채널의 고질적인 문제점에 취약합니다.
* JMX 접속은 수명주기 특성으로 풀 GC를 하기 전에는 RMI 객체가 수집되지 않고 남아 있을 수 있으며 RMI를 사용하는 애플리케이션은 기본적으로 1시간에 한번씩 풀 GC가 발생하여 추가적인 부하가 발생합니다.

### 8.1.4 GC 로그 데이터의 장점

* GC 로그는 JVM 구현체 디버깅 용도로 추가됐습니다.
* GC 로그가 점차 런타임에 무슨 일이 발생하는지 정확히 파악하는 데 도움이 됨을 알았습니다.
* GC 로그에 쌓인 기초 데이터는 특정 GC 이벤트와 연관 지을 수 있어서 모든 의미 있는 분석작업을 수행할 수 있습니다.

## 8.2 로그 파싱 툴

* GC 로그는 마이너 릴리즈 간에 포맷이 조금씩 다릅니다.
* GC 로그를 직접 파싱하는것이 아닌 툴을 사용하는것이 좋습니다.

### 8.2.1 샌섬

* 센섬은 jClarity사가 제작한 상용 메모리 분석기입니다.
* 센섬은 최고의 GC 로그 파싱, 정보 추출, 자동 분석 기능을 제공하는 것이 목표입니다.
* 센섬 Saas 모니터링을 이용하면 전체 클러스터 상태를 한눈에 볼 수 있습니다.

### 8.2.2 GCViewer

* GCViewer는 GC 로그 파싱 및 그래프 출력 등 기본 기능을 가진 데스크톱 툴입니다.
* 상용 툴에 비해 빈약한 기능을 가지고 있습니다.
* GCViewer는 분석 기능은 없고 특정 GC 핫스팟 로그 포맷만 파싱할 수 있습니다.

## 8.3 GC 기본 튜닝

다음 사실을 기억하면 실무에서 GC 튜닝을 할 떄 도움이 될것입니다.
* GC 가 성능 문제를 일으키는 근원이라고 확신하거나 그렇지 않다고 배제하는 행위는 저렵합니다.
* UAT에서 GC 플래그를 켜는 것도 저렴한 행위입니다.
* 메모리 프로파일러, 실행 프로파일러를 설정하는 작업은 결코 저렴하지 않습니다.

엔지니어는 튜닝을 수행하면서 다음 네 가지 주요 인자를 면밀히 관찰/측정해야 합니다.
* 할당(가장 중요)
* 중단 민감도
* 처리율 추이
* 객체 수명

힙 크기를 조정하는 기본 플래그입니다.

|플래그| 작용                                  |
|:--|:------------------------------------|
|-Xms<size>| 힙 메모리의 최소 크기를 설정합니다.                |
|-Xmx<size>| 힙 메모리의 최대 크기를 설정합니다.                |
|-XX:MaxPermSize=<size>| 펌젠 메모리의 최대 크기를 설정합니다.(자바 7 이전)      |
|-XX:MaxMetaspaceSize=<size>| 메타스페이스 메모리의 초대 크기를 설정합니다.(자바 8 이후)  |

성능 문제를 일으키는 원인이 GC인지 아닌지 판단하는 방법으로는 vmstat 같은 툴로 고수준의 머신 지표를 체크하고 성능이 떨어진 시스템에 로그인해서 다음을 확인해야합니다.
* CPU 사용률이 100%에 가까운가?
* 대부분의 시간(90% 이상)이 유저 공간에서 소비되는가?
* GC 로그가 쌓이고 있다면 현재 GC가 실행 중이라는 증거입니다.

앞서 설명한 세 조건이 만족한다면 GC가 성능 이슈를 일으키고 있을 가능성이 크고 철저한 조사와 튜닝이 필요합니다.
GC가 성능 문제의 출처라고 밝힌 다음에는 할당과 중단 시간 양상을 파악한 후 GC를 튜닝하고 필요 시 메모리 프로파일러를 이용해야 합니다.

### 8.3.1 할당이란?

* 할당률 분석은 튜닝 방법뿐 아니라 실제로 가비지 수집기를 튜닝하면 성능이 개선될지 여부를 판단하는 데 꼭 필요한 과정입니다.
* 영세대 수집 이벤트 데이터를 활용하면 할당된 데이터양, 단위 수집 시간을 계산할 수 있고, 일정 시간 동안의 평균 할당률을 산출할 수 있습니다.
* 초기 할당 전략은 다음 네 가지 단순 영역에 집중하는 것이 좋습니다.
  * 굳이 없어도 그만인, 사소한 객체 할당(예: 로그 디버깅 메시지)
  * 박싱 비용
  * 도메인 객체
  * 엄청나게 많은 논JDK 프레임워크 객체

도메인 객체가 메모리를 많이 차지하는 일이 있습니다. 다음과 같은 타입이 문제가 됩니다.
* char[]
* byte[]
* double[]
* 맵 엔트리
* Object[]
* 내부 자료 구조(예: methodOop, klassOop)

핫스팟은 TLAB 및 큰 객체의 조기 승격에 관한 튜닝 플래그를 제공합니다
~~~
-XX:PretenureSizeThreshold=<n>
-XX:MinTLABSize=<n
~~~

할당률은 테뉴어드로 승격되는 객체 수에 영향을 끼칩니다.
단명 자바 객체의 수명이 불변이라고 가정하면 할당률이 높을수록 영 GC 발생 주기는 짧아집니다.
너무 자주 수집이 일어나면 단명 객체는 장례를 치를 시간도 없이 테뉴어드로 잘못 승격될 가능성이 큽니다.

조기 승격 문제에는 다음 스위치가 요긴하게 쓰입니다. 테뉴어드 영역으로 승격되기 전까지 객체가 통과해야 할 가비지 수집 횟수를 설정하는 겁니다.
~~~
-XX:MaxTenuringThreshold=<n>
~~~
* 한계치가 높을수록 진짜 장수한 객체를 더 많이 복사합니다.
* 한계치가 너무 낮으면 단명 객체가 승격되어 테뉴어드에 메모리압을 가중시킵니다.

### 8.3.2 중단 시간이란?

중단 시간 튜닝 시 유용한 휴리스틱은 다음과 같습니다.
* '> 1초  : 1초 이상 걸려도 괜찮다.
* 1초 ~ 100밀리초 : 100밀리초 이상 1초 이하 정도는 괜찮다.
* < 100밀리초 : 100밀리초까지는 괜찮다.

중단 민감도를 애플리케이션 힙 크기와 대략 연관 지어보면 어떤 수집기가 가장 적합한지 가늠할 수 있습니다.


|>1s|1s-100ms|<100ms|<2GB|
|:--|:--|:--|:--|
|Parallel|Parallel|CMS|<4GB|
|Parallel|Parallel/G1|CMS|<4GB|
|Parallel|Parallel/G1|G1|<10GB|
|Parallel/G1|Parallel/G1|G1|<20GB|
|Parallel/G1|G1|CMS|>32GB|

### 8.3.3 수집기 스레드와 GC 루트

* GC 루트 탐색 시간은 다음과 같은 요인의 영향을 받습니다.
  * 애플리케이션 스레드 개수
  * 코드 캐시에 쌓인 컴파일드 코드량
  * 힙 크기
* 애플리케이션 스레드가 너무 많으면 스택 프레임을 더 많이 탐색해야 하고 세이프포인트에 도달하는 시간도 길어지는 등 GC 시간에 영향을 끼칩니다. 베어 메탈과 가상 환경에 존재하는 스레드 스케줄러도 압박합니다.
* JNI 프레임과 JIT 컴파일드 코드용 캐시 등 다른 GC 루트 원천들도 있습니다.
* 세 가지 중 스택, 힙 탐색은 비교적 병렬화가 잘 됩니다.

### 8.4 Paralle GC 튜닝

* Parallel GC는 가장 단순한 수집기라 튜닝 역시 제일 쉽습니다.
* 이 수집기의 트레이드 오프는 다음과 같습니다.
  * 풀 STW
  * GC 처리율이 높고 계산 비용이 싸다.
  * 부분 수집이 일어날 가능성은 없다.
  * 중단 시간은 힙 크기에 비례하여 늘어난다.

과거에는 다음과 타은 플래그를 통해 다양한 메모리 풀의 상대적 크기를 조정했던 적이 있습니다.

|플래그|작용|
|:--|:--|
|-XX:NewRatio=<n>|영 세대/전체 힙 비율|
|-XX:SurvivorRatio=<n>|서바이버 공간/영 세대 비율|
|-XX:NewSize=<n>|최소 영 세대 크기|
|-XX:MaxNewSize=<n>|최대 영 세대 크기|
|-XX:MinHeapFreeRatio=<n>|팽창을 막기 위한 GC 이후 최소 힙 여유 공간 비율(%)|
|-XX:MaxHeapFreeRatio=<n>|팽창을 막기 위한 GC 이후 최대 힙 여유 공간 비율(%)|

다음은 SurvivorRatio, NewRatio, 전체 힙 크기의 관계를 나타낸 수식입니다.

~~~
플래그 세트:

-XX:NewRatio=N
-XX:SurvivorRatio=K

영 세대 = 1 / (N + 1) x 힙
올드 세대 = N / (N + 1) x 힙

에덴 = (K - 2) / K x 힙
서바이버1 = 1 / K x 힙
서바이버2 = 1 / K x 힙

~~~

대부분의 최신 애플리케이션은 크기를 알아서 잘 결정하기 때문에 명시적으로 크기를 설정하는 일은 삼가는 게 좋습니다. 어쩔 수 없는 경우의 최후의 수단입니다.

## 8.5 CMS 튜닝

* CMS로 최상의 성능을 얻는 과정에는 여러 가지 복잡성과 트레이드오프가 있습니다.
* CMS처럼 중단 시간이 짧은 수집기는 정말로 STW 중단 시간을 단축시켜야 하는 유스케이스에 한해 어쩔 수 없을 때만 사용해야 합니다.
* CMS 수집이 발생하면 기본적으로 코어 절반은 GC에 할당되므로 애플리케이션 처리율은 그만큼 반토막납니다. 이때 한 가지 유용한 경험 법칙은 CMF 발생 직전의 수집기 상태를 살펴보는 것입니다.
* CMS 수집이 끝나자마자 곧바로 새 CMS 수집이 시작되는 백투백 수집 현상은 동시 수집기가 얼마 못가 고장날 거라는 신호입니다.
* 백투백 현상이 일어난다면 괜찮지 않을 때 호스트에 코어 수를 늘리는 해결 방안을 모색해야 합니다.

CMS 수집 중 GC에 할당된 코어 수를 줄이는 방법도 있습니다.
CMF에 취약해지는 위험을 감수해야합니다.
~~~
-XX:ConcGCThreads=<n>
~~~

CMS에서 STW는 두 단계에서 발생합니다.
* 초기 마킹
* 재마킹
따라서 모든 애플리케이션 스레드는 CMS가 한번 일어날 때마다 반드시 2회 멈추는데, 세이프 포인트에 예민한 저지연 애플리케이션에서는 중요한 영향을 미칠 수 있습니다.

다음 두 플래그를 함께 적용하면 도움이 됩니다.
~~~
-XX:CMSInitiatingOccupancyFraction=<n>
-XX:+UseCMSInitiatingOccupancyOnly
~~~

CMSInitialingOccupancyFraction은 CMS가 언제 수집을 시작할지 설정하는 플래그입니다. CMS가 실행되면 영 수집을 통해 올드 영역으로 승격되는 객체들을 수용할 여유 공간이 필요합니다.

UseCMSInitiatingOccupancyOnly는 플래그를 함께 설정하면 초기 점유 공간을 동적 크기 조정하는 기능이 꺼집니다. 이 플래그는 함부로 켜면 안됩니다. 실제로 여유 공간을 줄일 일은 거의 없습니다.

할당률이 심하게 튀는 애플리케이션이라면 여유 공간을 늘리고 능동적 크기 조정 기능을 끄는 전략을 구사합니다. CMS 동시 GC를 더 자주 일으키는 대가로 CMF를 줄이는것이 목표인겁니다.

### 8.5.1 단편화로 인한 CMF

* CMS가 관리하는 프리 리스트로 인해 발생하는 CMF를 단편화로 인한 CMF라고 합니다.

다음 JVM 스위치를 추가하면 GC로그에 다음과 같은 정보가 추가됩니다.
* Total Free Space
* Max Chunk Size
* Number of Blocks
* Av. Block Size
* Tree Height

## 8.6 G1 튜닝

* 엔드 유저가 최대 힙 크기와 최대 GC 중단 시간을 설정하면 나머지는 수집기가 알아서 처리하게 하는 것이 G1 튜닝의 최종 목표입니다. 그러나 아직 현신은 조금 동떨어져 있습니다.
* CMS처럼 G1도 구성 옵션이 꽤 많지만, 실험적이고 VM 내부에서 잘 드러나지 않는 것들이 있습니다.
* 이러한 옵션들을 지정해서 튜닝해야 할 경우 다음 스위치를 지정해야합니다.
  * > -XX:+UnlockExperimentalVMOptions
* 이 스위치는 -XX:G1NewSizePercent=<n>나 -XX:G1MaxNewSizePercent=<n> 같은 G1 튜닝 옵션을 사용할 수 있게 해줍니다.
* G1 튜닝에서 가장 큰 문제는 이 수집기가 등장하고 내부적으로 많이 변화가 일어났다는것입니다.
* G1은 자바 9부터 디폴트 수집기로 격상되기에 성능 엔지니어는 어쩔 수 없이 G1 튜닝 문제도 함께 다루어야 합니다.
* G1은 CMS와 다르게 압착을 하기에 CMF가 일어날 가능성이 없습니다.
* 애플리케이션에서 할당률이 계속 높은 상태로 대부분 단명 객체가 생성되고 있다면 다음 튜닝을 교려해볼만 합니다.
  * 영 세대를 크게 설정한다.
  * 테뉴어드 한계치를 최대 15 정도로 늘려 잡는다.
  * 애플리케이션에서 수용 가능한 최장 중단 시간 목표를 정한다.

> 참조
> 
> 자바 최적