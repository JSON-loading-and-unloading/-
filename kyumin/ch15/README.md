# 15장 자바 9와 미래

* 자바 8이 람다와 그 결과물(스트림, 디폴트 메소드, 함수형 프로그래밍 요소)에 중점에 두었다면 자바 9는 거의 모듈에 관한 버전입니다.
* 모듈은 아키텍처가 잘 갖추어진 애플리케이션을 구축하는 최신 방법론이지만, 개발 프로젝트에 모듈을 적용해서 장기적인 효과를 보려면 시간이 걸릴 수 있습니다.

## 15.1 자바 9에서 소소하게 개선된 성능

* 성능 측면에서 자바 9부터 개선된 사항입니다.
    * 코드 캐시 세그먼트화
    * 컴팩트 스트링
    * 새로운 스트링 연결
    * C2 컴파일러 개선
    * G1 새 버전

### 15.1.1 코드 캐시 세그먼트화

* 자바 9부터 코드 캐시 성능을 개선코자 다음 항목별 영역으로 분리했습니다.
    * 인터프리터 등의 논메소드 코드
    * 프로파일드 코드
    * 논프로파일드 코드
* 스위퍼 가동 시간이 짧아지고 풀 최적화 코드에 대한 코드 지역성이 향상됩니다.
* 다른 영역은 공간이 남아도는데 특정 영역이 꽉 채워질 수 있는 단점이 있습니다.

### 15.1.2 콤팩터 스트링

* 자바에서 스트링 콘텐츠는 항상 char[] 타입으로 지정됩니다. 하지만 char는 16비트 타입이라서 ASCII 스트링을 저장하려면 실제로 필요한 공간의 2배 정도를 더 차지합니다.
* 자바 9 이후는 컴팩트 스트링 덕분에 스트링 단위로 최적화할 수 있습니다.
* 자바 9부터는 value 필드 타입이 이전 버전과 달리 char[]가 아닌 byte[]입니다.


~~~java
// jdk-8
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
}

// jdk-11
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final byte[] value;
}
~~~

### 15.1.3 새로운 스트링 연결

* 자바 9부터는 StringConcatFactory.makeConcatWithConstants()라는 팩토리 메소드로 스트링 연결 레시피를 제공합니다.

### 15.1.4 C2 컴파일러 개선

* 현대 CPU에 선보인 SIMD 확장 기능을 자바/JVM 플랫폼 특성 덕분에 효과적으로 활용하기 좋은 조건을 갖고 있습니다.
    * 바이트코드는 플랫폼과 무관하다
    * JVM은 시동 시 CPU를 탐색하므로 자신이 어떤 능력을 지닌 하드웨어에서 실행되고 있는지 런타임에 파악할 수 있습니다.
    * JIT 컴파일은 코드를 동적 생성하기 때문에 사용 가능한 모든 명령을 호스트에서 사용할 수 있습니다.
* 핫스팟은 다음과 같은 x86 SIMD 명령어를 지원합니다.
    * 자바 코드의 자동 벡터화
    * 순차 코드에서 SIMD 코드를 얻기 위해 C2에서 슈퍼워드 최적화
    * 배열 복사/적재/비교 등의 JVM SIMD 인트린직
* 자바 9버전은 SIMD의 장점 및 그와 연관된 프로세서 특성을 더 잘 활용하고자 기존 인트리직을 개선하거나 새로운 인트린직을 탑재했습니다.
    * 마스킹된 벡터 포스트 루프
    * 슈퍼워드 루프 펼치기 분석
    * 멀티비저닝으로 범위 체크 제거
    * 배정도 제곱근 벡터화 지원
    * 병렬 스트림의 백터화 개선
    * 슈퍼워드를 개선하여 인텔 AVX CPU상에서 벡터 조건부 이동(CMovVD) 지원

### 15.1.5 G1 새 버전

* G1은 중단 시간을 쉽게 튜닝하려고 더 효과적으로 제어하는 특성을 지닌, 여러 가지 문제를 한꺼번에 해결하고자 설계된 수집기입니다.
* 자바 9부터는 디폴트 수집기가 되었습니다.
* 자바 9의 G1과 자바 8 G1은 버전이 다릅니다.
* 자바 9로 이전한 애플리케이션은 별다른 문제는 없는지 성능 테스트를 꼼꼼히 해야 합니다.

## 15.2 자바 10과 그 이후 버전

### 15.2.1 새로운 릴리즈 절차

* 자바 10부터는 정확한 시기에 릴리즈되는 모델로 개편됐습니다. 앞으로는 자바 새 버전이 6개월마다 한번씩 릴리즈됩니다. 이른바 특성 릴리스라고 합니다.
* 오라클은 일부 특정 릴리즈에 대해서 장기 지원을 제공합니다.

### 15.2.2 자바 10

* JVM의 새로운 특성 및 개선 사항은 자바 개선 프로세스를 통해 관리하며, JDK 개선 제안서마다 관리 번호를 하나씩 매깁니다.
    * 286 : 지역 변수 타입 추론(var)
    * 296 : JDK 포레스트를 단일 리파지터리로 통합
    * 304 : 가비지 수집기 인터페이스
    * 307 : G1에서 풀 병렬 GC 구현
    * 310 : 애플리케이션 클래스 데이터 공유
    * 312 : 스레드 로컬 핸드쉐이크

## 15.3 자바 9 Unsafe 그 너머

* Unsafe는 표준 API는 아니지만 자바 8부터 사실상 표준이 됐습니다.
* 라이브러리 개발자 입장에서 Unsafe에는 다양한 안전 기능이 버무려져 있습니다.
* 이처럼 '전혀 안전하지 않은' 기능을 다른 방법으로는 얻을 수 없기에 오라클은 이런 기능을 핵심 내부 API라고 부릅니다.
* 문제는 sun.misc.Unsafe와 관련 클래스에 구현된 기능을 대체할 마땅한 기술이 없다면 주요 프레임워크와 라이브러리는 더 이상 제대로 작동하지 않을 거란 사실입니다.
* 자바 9에는 --illegal-access라는 스위치가 추가되어 이 API에 대한 런타임 액세스를 조정할 수 있습니다.

### 15.3.1 자바 9의 VarHandle

* 메소드 핸들은 실행 가능한 메소드의 레퍼런스를 직접 조작할 수 있게 해주지만, getter/setter 엑세스만 지원하고 필드까지 100% 지원하는 것은 아닙니다.
* 자바 플랫폼은 단순한 유스케이스를 뛰어넘는 데이터 액세스 모드를 제공하므로 이 정도로는 불충분합니다.
* 자바 9부터 메소드 핸들은 JEP 193 가변 핸들까지 포괄하도록 확장됐습니다. 이 제안서의 의도는 Unsafe에 있는 API 일부를 안전하게 대체하여 간극을 메우자는 것입니다.

## 15.4 발할라 프로젝트와 값 타입

* 발할라 프로젝트의 사명 선언문에는 이 프로젝트가 '고급 자바 VM 및 언어의 특성 후보를 탑구/배양하는 장'이라고 합니다.
    * JVM 메모리 레이아웃을 최신 하드웨어의 비용 모델에 맞게 조정한다.
    * 제네릭스가 기본형, 값 심지어 void까지 포함하도록 모든 타입에 추상화한다.
    * 기존 라이브러리, 특히 JDK가 이러한 특성을 최대한 활용하는 방향으로 호환성을 유지하며 진화하도록 한다.

## 15.5 그랄과 트러플

* 핫스팟에 내장된 C2 컴파일러는 매우 큰 성공을 거두었습니다.
* 그랄은 JVM용 JIT 컴파일러를 자바 언어로 개발 방식으로 접근합니다. 이 프로젝트의 사상은, JIT 컴파일러는 JVM 바이트코드를 받아 기계어를 생성하기만 하면 된다는 것입니다.
* 자바를 자바로 접근하는 방식은 단순함, 메모리 보안 등 여러 면에서 좋습니다.
* C2가 아닌 그랄로 부분 탈출 분석 등의 새로운 최적화 기법을 구현할 수 있게 되었으며 개발자가 인트린직 또는 최적화 패스 개발 등 자신의 애플리케이션에 맞게 그랄의 일부를 수정할 수 있는 유연성이 있습니다.
* 트러플은 JVM에 기반한 언어 전용 인터프리터를 개발하는 프레임워크로, 입력 언어에 대한 고성능 JIT 컴파일러를 인터프리터에서 자동 생성하는 라이브러리입니다.
* 위 모든것은 메트로폴리스 프로젝트라는 새로운 프로젝트의 일부로 진행 중입니다.
* 서브스트레이트VM은 지금까지 둘러본 기능을 더욱 확장시켜 아예 자바 애플리케이션과 JVM을 통째로 컴파일하여 정적으로 링크된 하나의 네이티브 실행 코드를 생성하려는 연구 프로젝트입니다.

## 15.6 바이트코드의 향후 발전 방향

* 지금까지 VM에서 가장 큰 변화는 invokedynamic 명령어의 등장입니다.
* invokedynamic은 JVM 바이트코드 작성 방법을 다시 생각하게 만든 도화선 역할을 했습니다.
* 앞으로는 이 옵코드에 적용된 기술을 확장하여 플랫폼에 더욱 유연하게 만들려는 시도가 줄을 이을겁니다.

## 15.7 동시성의 향후 발전 방향

* 자바가 일으킨 가장 큰 혁신 중에는 자동 메모리 관리 기능을 빼놓을 수 없습니다.
* 자바 스레딩 모델은 프로그래머가 모든 스레드를 직접 관리하고 가변 상태는 락으로 보호해야 한다는 설계 사상에 근거했습니다. 그래서 코드 한 부분이라도 락킹을 정확히 구현하지 않으면 객체 상태가 무너질 수있는 구조였습니다.
* 이와 반대로 나중에 등장한 자바 버전은 좀 더 고수준의, 개발자 손이 덜 가고 일반적으로 더 안전하게, 사실상 런타임이 동시성을 관리하는 방향으로 진화했습니다.
* 룸 프로젝트도 그러한 노력의 일환입니다.
* 룸 프로젝트는 지금까지 동시성을 JVM상에서 지원헀던 것과 달리, 더 저수준에서 지원하는 방안을 모색합니다.(Virtual Thread)