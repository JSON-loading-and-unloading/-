## 9.1 바이트 코드의 해석

JVM 인터프리터는 일종의 **스택 머신**처럼 작동한다.

작업할 값은 모두 **평가 스택**에 놓고 스택 머신 명령어로 스택 최상단에 위치한 값을 변환하는 식으로 작동한다.

JVM은 다음 3공간에 데이터를 저장한다.
* 평가 스택 : 메서드별로 하나씩 생성된다.
* 로컬 변수 : 결과를 임시 저장한다.
* 객체 힙 : 메서드끼리, 스레드끼리 공유된다.

### 9.1.1 JVM 바이트코드 개요

JVM에서 각 스택 머신 작업 코드(Opcode)는 1바이트로 나타낸다.
따라서 0부터 255까지 총 256개의 옵코드가 가능하다. 그중 약 200개를 사용하고 있다.(자바 10기준)

Opcode 는 스택 상단에 위치한 두 값의 기본형을 구분할 수 있게 표시된다.
* ex) iadd : int 값, dadd : double

Opcode 는 대부분 한쪽은 기본형, 한쪽은 참조형으로 쓸 수 있게 **패밀리 단위** 로 구성된다.
* ex) store 패밀리중, dstore는 '스택 상단을 double 형 지역 변수로 스토어하라', astore 는 '스택 상단을 참조형 지역 변수로 스토어하라'는 뜻이다.

load 같은 옵코드 군에는 단축형이 있어 인수를 생략할 수 있고, 그만큼 클래스 파일의 인수 바이트 공간을 절약할 수 있다.
* 특히, aload_0 같은 명령어는 워낙 자주 쓰여 클래스 파일 크기가 상당히 줄어든다.
* 자바 초창기에는 자바 클래스 파일의 크기를 최대한 압축시키는 것이 중요했다.

### 바이트코드 유형

1. 스택에 데이터를 넣고 빼는 옵코드로 구성된 load/store 카테고리

    <img width = "500" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/95271a7b-df30-4ac2-9f75-af75fc9b752e">
    
    * lds vs. const 구별해야 한다.
        * lds : 현재 클래스의 상수 풀에 있는 상수를 로드하는 바이트코드
        * const : 매개변수 없이 진짜 상수만 로드하는 옵코드

2. 산술 바이트코드

    기본형에만 적용되며 순수하게 스택 기반으로 연산을 수행하므로 인수는 없다.

    <img width = "500" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/2ca4c8b2-5601-47a4-a6fc-bcfea553ce1b">

3. 흐름을 제어하는 바이트코드

    <img width = "500" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/1476965c-70b9-4a12-8fc2-f21b9dc75af3">

    * jsr, ret 역시 흐름 제어 패밀리에 속한 바이트코드지만 자바 6 이후로 deprecated 되었다.

3. 메서드 호출 바이트코드

    <img width = "500" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/d6ce2a2a-647c-4587-96c1-fb2a3c9d9d33">

    * invokevirtual : 주로 인스턴스 메서드 호출
    * invokeinterface : 자바 인터페이스에 선언된 메서드를 호출한 경우
    * invokespecial : 컴파일 타임에 디스패치할 메서드를 특정할 수 있는 경우

4. 플랫폼 옵코드

    객체별로 힙 저장 공간을 새로 할당하거나, 고유 락을 다루는 명령어들이다.

    <img width = "500" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/f63eada9-ab6e-4174-bbe4-c4ba2f535b94">

### 세이프포인트
* JVM 이 어떤 관리 작업을 수행하고 내부 상태를 일관되게 유지하는 데 필요한 지점

바이트코드 사이사이가 애플리케이션 스레드를 멈추기에 이상적인 시점이자, 가장 단순한 세이프포인트이다.

### 9.1.2 단순 인터프리터

가장 단순한 인터프리터는 switch 문이 포함된 while 루프 형태일 것이다.

<img width = "500" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/302bea68-4099-4d9b-97ec-d104e9bed7e4">

<br>

<img width = "500" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/2a5af646-74d1-4270-b91d-09ef48d0b164">

메서드에서 한번에 한 바이트코드씩 읽어들여 옵코드별로 분기하는 코드이다.

임시값은 execMethod() 메서드에서 지역 변수인 EvaluationStack에서 평가된다. 산술 옵코드는 이 스택 위에서 정수 계산을 한다.

### 9.1.3 핫스팟에 특정한 내용

핫스팟은 인터프리티드 모드에서도 빠르게 실행될 수 있도록 여러 고급 확장 기능을 가지고 있다.

* 핫스팟은 단순 인터프리터와 달리 **템플릿 인터프리터**라서 시작할 때마다 동적으로 인터프리터를 구축한다.
* 네이티브 플랫폼의 스택 프레임 레이아웃을 최대한 활용하여 성능을 높이기 위해 상당히 많은 **어셈블리어 코드**로 작성되어 있다.
* VMSpec에 없는 핫스팟 전용 바이트코드까지 정의해서 쓴다. 특정 옵코드의 일반적인 유스케이스와 핫하게 쓰는 경우를 차별화하려는 의도이다.

## 9.2 AOT와 JIT 컴파일

### 9.2.1 AOT 컴파일

AOT 컴파일은 사람이 읽을 수 있는 프로그램 소스 코드를 외부 프로그램에 넣고 바로 실행 가능한 기계어를 뽑아내는 과정이다.

AOT의 목표는 프로그램을 실행할 플랫폼과 프로세서 아키텍처에 딱 맞는 실행 코드를 얻는 것이다. 하지만 대부분의 실행 코드는 자신이 어떤 플랫폼에서 실행될지 모르는 상태에서 생성되므로 AOT 컴파일은 보수적인 선택을 한다. 이는 CPU 기능을 최대한 활용하지 못하게 한다.

### 9.2.2 JIT 컴파일

JIT 컴파일은 런타임에 프로그램을 고도로 최적화한 기계어로 변환하는 기법이다.

프로그램의 런타임 실행 정보를 수집해서 어느 부분이 자주 쓰이고, 어느 부분을 최적화해야 가장 효과가 좋은지 프로파일을 만들어 결정한다. 이러한 기법을 **PGO(프로파일 기반 최적화)** 라고 한다.

이때, 프로파일링 정보는 재사용되지 않고 VM이 꺼지면 일체 폐기한다. 프로파일리 정보는 항상 처음부터 다시 만들어진다.

### 9.2.3 AOT 컴파일 vs JIT 컴파일

AOT 컴파일
* 상대적으로 이해하기 쉽고 성능 특성이 그리 복잡하지 않다.
* 해당 프로세스에 최적화된 실행 코드가 만들어진다. 따라서 저지연 또는 극단적으로 성능이 중요한 유스케이스에는 유용한 기법일 것이다.
* 문제는 확장성이다. 다양한 아키텍처에서 최대 성능을 내지는 못한다.

핫스팟
* 새로 릴리즈할때마다 새로운 프로세서 기능에 관한 최적화 코드를 추가할 수 있다.
* 기존 클래스 및 JAR 파일을 다시 컴파일하지 않아도 신기능을 활용할 수 있다.

자바 9부터 핫스팟 VM은 AOT 컴파일 옵션을 제공하기 시작했다.

## 9.3 핫스팟 JIT 기초

### 핫스팟 기본
* 기본 컴파일 단위는 전체 메서드이다. 따라서 한 메서드에 해당하는 바이트 코드는 한꺼번에 네이티브 코드로 컴파일된다.
* OSR(온-스택 치환) 기법을 이용해 컴파일하는 기능도 지원된다.
    * OSR은 어떤 메서드가 컴파일할만큼 자주 호출되지는 않지만, 컴파일하기 적합한 루프가 포함돼 있고 루프 바디 자체가 메서드인 경우 사용한다. (?)
* klass 메타데이터 구조체에 있는 vtable을 이용해 JIT 컴파일을 구현한다.

### 9.3.1 klass워드, Vtable, 포인터 스위즐링

JIT 컴파일 서브시스템을 구성하는 스레드는 핫스팟 내부에서 가장 중요한 스레드들이다.

* 프로파일링 스레드 : 컴파일 대상을 찾아낸다.
* 컴파일러 스레드 : 실제 기계어를 생성한다.

컴파일 대상으로 낙점된 메서드는 컴파일러 스레드에 올려놓고 백그라운드에서 컴파일한다.

최적화된 기계어가 생성되면 해당 klass의 vtable은 새로 컴파일된 코드를 가리키도록 수정된다. 이렇게 vtable 포인터를 업데이트하는 작업을 **pointer swizzling(포인터 스위즐링)** 이라고 한다.

### 9.3.2 JIT 컴파일 로깅

해당 스위치를 켜면 컴파일 이벤트 로그가 표준 출력 스트림에 생성되므로 어떤 메서드가 컴파일되고 있는지 파악할 수 있다.
```
-XX:+PrintCompilation
```

### PrintCompilation 출력 결과

<img width = "500" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/c2bb652e-a9aa-4652-9e08-6deaf4c74092">

* 메서드가 컴파일된 시간
* 이번차례에 컴파일된 메서드의 순번
* 그 밖의 필드
    * n : 네이티브 메서드
    * s : 동기화 메서드
    * ! : 예외 핸들러를 지닌 메서드
    * % : OSR을 통해 컴파일된 메서드

더욱 자세한 정보를 파악하기 위해서는 아래의 플래그가 필요하다.

```
-XX:+UnlockDiagnosticVMOptions
```
VM이 바이트코드를 네이티브 코드로 어떻게 최적화했는지, 큐잉은 어떻게 처리했는지 관련 정보를 XML 태그 형태로 제공한다.

### 9.3.3 핫스팟 내부의 컴파일러

핫스팟 JVM 내부에는 C1(클라이언트 컴파일러), C2(서버 컴파일러) 라는 두 JIT 컴파일러가 있다.

C1은 주로 GUI 애플리케이션 및 기타 '클라이언트' 프로그램에, C2는 실행 시간이 긴 '서버' 애플리케이션에 주로 사용되었지만 요즘은 기준이 뚜렷하지 않다.

* 공통점
    * 핵심 측정값, 즉 메서드 호출 횟수에 따라 컴파일이 트리거링된다. 호출 횟수가 특정 한계치에 이르면 해당 메서드를 컴파일 큐에 넣는다.
    * SSA (단일 정적 할당) 방식을 사용한다.
        * 변수를 일체 재할당하지 않는 코드로 변환한다.

* 차이점
    * 같은 코드라도 C1, C2가 생성한 내부 표현형은 전혀 다르다. C1은 C2보다 컴파일 시간도 더 짧고 단순하게 설계된 까닭에 C2처럼 풀 최적화는 안 한다.

### 9.3.4 핫스팟의 단계별 컴파일

자바 6부터 JVM은 tiered compilation(단계별 컴파일) 모드를 지원한다.

tiered compilation 이란 인터프리터 모드로 실행되다가 단순한 C1 컴파일 형식으로 바뀌고, 다시 이를 C2가 보다 고급 최적화를 수행하는 방식으로 단계를 바꾸는 것이다.

성능 튜닝 시 이 부분을 조정할 일은 거의 없지만 작동 원리 정도를 알아두는게 좋다.

## 9.4 코드 캐시

JIT 컴파일드 코드는 **코드 캐시** 라는 메모리 영역에 저장된다.

코드 캐시는 설정된 값으로 최대 크기가 고정되어 확장이 불가능하다. 코드 캐시가 꽉 차면 그때부터 더 이상 JIT 컴파일은 안 되며, 컴파일되지 않은 코드는 인터프리터에서만 실행된다.

코드 캐시는 **미할당영역**과 **프리 블록 연결 리스트**를 담은 힙으로 구성된다. 네이티브 코드가 제거될 때마다 해당 블록이 프리 리스트에 추가된다.

네이티브 코드 캐시가 제거되는 경우
* 역최적화 될 때
* 다른 컴파일 버전으로 교체됐을 때
* 메서드를 지닌 클래스가 언로딩될 때

코드 캐시의 최대 크기를 조정하는 VM 스위치
```
-XX:ReservedCodeCacheSize=<n>
```

### 9.4.1 단편화

C1 컴파일러를 거친 중간 단계 컴파일드 코드가 C2 컴파일로 치환된 후 삭제되는 일이 잦아지면 코드 캐시는 단편화되기 쉽다. 결국 미할당 영역이 모두 소진되고 여유 공간은 전부 프리 리스트에 있는 것으로 나타난다.

압착을 안 하면 코드 캐시는 단편화되고 컴파일은 중단될 것이다.

## 9.5 간단한 JIT 튜닝법

JIT 튜닝의 대원칙
* 컴파일을 원하는 메서드에게 아낌없이 리소스를 베풀라

1. 먼저, PrintCompilation 스위치를 켜고 애플리케이션을 실행한다.
2. 어느 메서드가 컴파일됐는지 기록된 로그를 수집한다.
3. ReservedCodeCacheSize를 통해 코드 캐시를 늘린다.
4. 애플리케이션을 재실행한다.
5. 확장된 캐시에서 컴파일드 메서드를 살펴본다.

다음 2가지 사실을 관찰할 수 있다.
* 캐시 크기를 늘리면 컴파일드 메서드 규모가 유의미한 방향으로 커지는가 ?
* 주요 트랜잭션 경로상에 위치한 주요 메서드가 모두 컴파일되고 있는가 ?

캐시를 늘려도 정작 컴파일드 메서드 개수는 그대로이고 로딩 패턴이 뚜렷하담녀 JIT 컴파일러의 리소스가 부족한 것이 아니다. 이때 주요 트랜잭션이 몰리는 경로에 있는 메서드가 컴파일 로그에 전부 나타나는지 확인하고, 그렇지 않다면 그 근본 원인을 찾아야 한다.





