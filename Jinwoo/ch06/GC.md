GC가 처음 나왔을때 언어 수준에서 의도적으로 수집기 작동을 제어하지 못하도록 했다는 점에서 여론이 좋지 않았다. 그러나 세월이 지나면서 GC가 사람의 손이 아닌 직접 메모리를 수집하는 것에 이견이 없어졌다.

* 자바 가비지 수집의 요체
    
    런타임이 대신 객체를 추적하며 쓸모없는 객체를 알아서 제거하는 것이다.

* 2가지 기본 원칙
    * 알고리즘은 반드시 모든 가비지를 수집해야 한다.
    * 살아 있는 객체는 절대로 수집해서는 안 된다. 
        * 살아있는 객체를 수집했다가는 세그먼테이션 결함이 발생하거나 프로그램 데이터가 더렵혀지는 문제가 발생한다.

## 6.1 마크 앤 스위프
마크 앤 스위프(mark and sweep) 알고리즘이 GC의 기초이다.

이 절에서는 GC 알고리즘의 기본 개념과 이를 응용해 어떻게 메모리를 자동 회수하는지 알아본다. 실제로 운영계 JVM 에서는 더 복잡하고 어렵지만 여기서는 매우 단순화하여 설명한다.

마크 앤 스위프 알고리즘은 할당은 되었지만, 아직 회수되지 않은 객체의 포인터를 포함하는 할당 리스트(allocated list) 를 사용한다.

전체적인 GC의 알고리즘은 다음과 같다.

1. 할당 리스트를 순회하면서 mark bit 를 지운다.
2. GC root 부터 살아있는 객체를 찾는다.
3. 2에서 찾은 객체마다 mark bit 를 세팅한다. **(mark)**
4. allocated list 를 순회하면서 mark bit 가 세팅되지 않은 객체를 찾는다.
    a. heap 에서 memory 를 회수해 free list 에 되돌린다.
    b. allocated list 에서 객체를 삭제한다. **(sweep)**

살아 있는 객체는 대부분 깊이 우선(depth-first) 방식으로 찾는다.

![단순 메모리 레이아웃](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/b8c6acc4-a156-4237-8f0f-ce68b4ea70b9)

heap 의 상태를 시각화하긴 어렵지만 다행히 jmap -histo 라는 명령어로 각 type 별 할당된 bytes 수를 볼 수 있다.
![jmap](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/91c1b284-bbe2-4c77-a07c-a6c73dd7ab33)

그때 그때 힙 모습만 봐서는 정확한 분석이 불가능하기 때문에 8장의 GC로그를 이용해야 한다.

### 6.1.1 가비지 수집 용어

### STW(stop-the-world)
GC 사이클이 발생하여 가비지를 수집하는 동안에는 모든 애플리케이션 스레드가 중단된다.

### 동시
GC 스레드는 애플리케이션 스레드와 병행 실행될 수 있다. 이는 계산 비용 면에서 아주 어렵고 비싼 작업인데다, 100% 동시 실행을 보장하는 알고리즘은 없다. 7.3 절에 나오는 핫스팟의 CMS 는 사실상 '준 동시' 수집기이다.

### 병렬
여러 스레드를 동원해서 가비지 수집을 한다.

### 정확
정확한 GC 스킴(scheme) 은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 가지고 있다.

### 보수
보수적인 스팀은 정확한 스팀의 정보가 없다. 그래서 리소스를 낭비하는 일이 잦고 근본적으로 타입 체계를 무시하기 때문에 비효율적이다.

### 이동
이동 수집기에서 객체는 메모리를 여기저기 오고 갈 수 있다. 객체 주소는 고정된 것이 아니고 raw pointer로 직접 access 하는 환경은 이동 수집기와 잘 맞지 않다.

### 압착
살아남은 객체들은 GC 사이클 마지막에 연속된 단일 영역으로 배열되며, 객체 쓰기가 가능한 여백의 시작점을 가리키는 포인터가 있다. 압착 수집기는 메모리 단편화를 방지한다.

* 메모리 단편화 : RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태

### 방출
수집 사이클 마지막에 할당된 영역을 완전히 비우고, 살아남은 객체는 모두 다른 메모리 영역으로 이동한다.

## 6.2 핫스팟 런타임 개요

가비지 수집의 작동 원리를 온전히 이해하기 위해서는 핫스팟 내부도 어느 정도 알아야 한다.

자바 언어는 다음 두가지 값만 사용한다.
* 기본형(int, byte 등)
* 객체 레퍼런스

자바의 특징
* 오프셋 연산자(.연산자) 만으로 필드에 액세스하거나 객체 레퍼런스의 메서드를 호출할 수 있다.
* call-by-value 방식으로만 메서드를 호출한다. (call-by-reference 아님!!)

### 6.2.1 객체를 런타임에 표현하는 방법

핫스팟은 런타임에 oop(ordinary object pointer)라는 구조체로 자바 객체를 나타낸다. oop를 구성하는 자료 구조는 여러가지가 있는데 그중 instanceOop 는 자바 클래스의 인스턴스를 나타낸다.

* instanceOop 의 메모리 레이아웃
    * 모든 객체에 대해 기계어 워드 2개로 구성된 헤더로 시작한다.
    * Mark 워드 (인스턴스 관련 메타데이터를 가리키는 포인터)
    * Klass 워드 (클래스 메타데이터를 가리키는 포인터)
        * java 7까지는 klass 가 힙의 일부인 펌젠을 가리켰다.
        * java 8부터는 klass 가 자바 힙의 주영역 밖으로 빠지게 되면서 객체 헤더가 필요 없어졌다.

oop 는 기계어이기 때문에 32bit 머신에선 32, 64bit 머신에선 64bit 를 차지하는데 여기서 메모리를 조금이라도 절약하기 위해 압축 oop 라는 기능을 제공한다.

> -XX:+UseCompressedOops

위의 옵션을 주면 힙에 있는 다음 oop가 압축된다.
* 힙에 있는 모든 객체의 Klass 워드
* 참조형 인스턴스 필드
* 객체 배열의 각 원소

## 6.2.2 GC 루트 및 아레나

GC루트는 메모리의 '고정점' 으로, 메모리 풀 외부에서 내부를 가리키는 포인터이다.

GC 루트는 다음과 같이 종류가 다양하다.
* JNI
* 스택 프레임
* 레지스터
* 전역 객체
* 코드 루트
* 로드된 클래스의 메타데이터

힙에 있는 객체를 가리키는 참조형 지역변수는 가장 단순한 형태의 GC 루트이다.

아레나(arena) 는 핫스팟 GC 가 작동하는 메모리 영역이다.

* 핫스팟은 자바 힙을 관리할 때 시스템 콜을 하지 않는다.

다음 장에서는 가비지 수집을 일으키는 두가지 주요 특성에 대해 자세히 살펴본다.

## 6.3 할당과 수명

자바 애플리케이션에서 가비지 수집이 일어나는 주된 원인은 2가지이다.
* 할당률 : 일정 기간 새로 생성된 객체가 사용한 메모리량
* 객체 수명
    * 객체 수명을 제대로 파악하기 너무 복잡하기 때문에, 객체 수명이 할당률보다 더 핵심적인 요인이다.

객체가 생성된 후 잠시 존재하고 그 상태를 보관하는 데 사용한 메모리를 다시 회수한다는 발상이 핵심이다. 가비지 수집기는 여러 가지 트레이드오프가 있는데, 그중 가장 중요한 것은 대개 할당 및 수명과 연관되어 있다.

### 6.3.1 약한 세대별 가설
> 1. 거의 대부분의 객체는 아주 짧은 시간만 살아 있지만, 나머지 객체는 기대 수명이 훨씬 길다.

결론은 '가바지를 수집하는 힙은, 단명 객체를 쉽고 빠르게 수집할 수 있게 설계해야 하며, 장수 객체와 단명 객체를 완전히 떼어놓는 게 가장 좋다.' 는 것이다.

핫스팟의 약한 세대별 가설을 이용한 메커니즘
* 객체마다 '세대 카운트(객체가 지금까지 무사 통과한 가비지 수집 횟수')를 센다.
* 큰 객체를 제외한 나머지 객체는 에덴(Eden) 공간에 생성한다. 여기서 살아남은 객체는 다른 곳으로 옮긴다.
* 오래 살아남은 객체는 별도의 메모리 영역(올드 old, 또는 테뉴어드 Tenured) 에 보관한다.

이 그림은 이 접근 방식을 간단히 나타낸 것이다.

![세대별 단위 수집](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/25bb2390-8b6c-435b-8824-6d1322de9be6)


여기서 중요한건 외부에서 young 세대 내부를 가리키는 pointer 를 계속 추적하는 것이다.
덕분에 GC 사이클에서 살아남은 젊은 객체들을 찾아내기 위해 전체 객체 그래프를 확인할 필요가 없다.

> 2. 늙은 객체가 젊은 객체를 참조할 일은 거의 없다.

하지만 Old 영역의 객체가 Young 영역의 객체를 참조하는 경우도 존재할 것이다.
이러한 경우를 대비하여 Old 영역에는 512 bytes의 덩어리로 되어 있는 카드 테이블이 존재한다.

카드 테이블에는 Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 그에 대한 정보가 표시된다. Young 영역에서 Minor GC 가 일어날 때, 모든 Old 영역에 존재하는 객체를 검사하여 참조되지 않는 Young 영역의 객체를 식별하는 것이 비효율적이기 때문에 카드 테이블만 조회하여 GC 의 대상인지 식별할 수 있도록 하고 있다.

## 6.4 핫스팟의 가비지 수집

JVM 은 메모리를 할당하고, 유저 공간에서 연속된 단일 메모리 풀을 관리한다.

이 메모리풀은 각자의 목적에 따라 서로 다른 영역으로 구성되며, 객체는 보통 에덴 영역에 생성된다. 수집기가 줄곧 객체를 이동시키기 때문에 객체가 차지한 주소는 시간이 흐르면서 바뀌게 되고, 이처럼 객체를 이동시키는 것을 '방출'이라고 한다.

핫스팟 수집기는 대부분 방출 수집기이다.

### 6.4.1 스레드 로컬 할당

HotSpot JVM 에서는 Eden 영역에 객체를 빠르게 할당하기 위해 bump the pointer와 TLABs(Thread-Local Allocation Buffers)라는 기술을 사용한다.

bumpt the pointer : Eden 영역에 마지막으로 할당된 객체의 주소를 캐싱해두는 것.

TLAB : 각각의 쓰레드마다 Eden 영역에 객체를 할당하기 위한 주소를 부여함으로써 동기화 작업없이 빠르게 메모리를 할당하도록 하는 기술이다. 각각의 쓰레드는 자신이 갖는 주소에만 객체를 할당함으로써 동기화 없이 bump the pointer 를 통해 빠르게 객체를 할당하도록 하고 있다.

### 6.4.2 반구형 수집

두 공간을 사용하는 독특한 방출 수집기이다. 핫스팟에서는 Young 힙의 반구부를 survivor 공간이라고 한다. 

* 수집기가 라이브 반구를 수집할 때 객체들은 다른 반구로 압착시켜 옮기고 수집된 반구는 비워서 재사용한다.
* 절반의 공간은 항상 완전히 비운다.

이 방식을 사용하면, 수집기 반구 내부에 실제로 보관 가능한 메모리 공간보다 2배를 더 사용하게 되어 낭비지만, 공간이 너무 크지 않다면 유용한 기법이다.

## 6.5 병렬 수집기

자바 8 이전까지는 parallel collector (병렬 수집기)가 디폴트 가비지 수집기이다.

병렬 수집기는 처리율에 최적화되어 있고, 영 GC, 풀 GC 모두 풀 STW 를 일으킨다. 병렬 수집기에도 여러가지 종류가 있는데, 여러 스레드를 이용해 가급적 빠른 시간 내에 살아있는 객체를 식별하고 기록작업을 최소화하도록 설계된 점은 비슷하다.

### 6.5.1 영 세대 병렬 수집

* 영세대 수집 발생 이유

    스레드가 에덴에 객체를 할당하려는데, 자신이 할당받는 TLAB 공간이 부족하고 JVM 은 새 TLAB 를 할당할 수 없을 때 영 세대 수집이 발생한다.

* Parallel GC 동작 방식

    1. 영 세대 수집이 일어나면 JVM 은 전체 애플리케이션 스레드를 중단시킨다.
    2. 스레드가 중단되면 핫스팟은 영 세대를 뒤져서 가비지 아닌 객체를 골라낸다. 이때 GC 루트를 병렬 마킹 스캔 작업의 출발점으로 삼는다.
    3. 그리고 Parallel GC 는 살아남은 객체를 현재 비어 있는 survivor 공간으로 모두 방출한 후, 세대 카운트를 증가시킨다.
    4. 에덴과 이제 막 객체들을 방출시킨 서바이버 공간을 재사용 가능한 빈 공간으로 표시하고 애플리케이션 스레드를 재시작해 TLAB 를 애플리케이션 스레드에 배포하는 프로세스를 재개한다.

### 6.5.2 올드 세대 병렬 수집

Parallel GC 는 객체를 방출하는 반구형 수집기라면, ParallelOld GC 는 하나의 연속된 메모리 공간에서 압착하는 수집기이다.

올드 세대에 더 이상 방출할 공간이 없으면 병렬 수집기는 올드 세대 내부에서 객체들을 재배치해서 늙은 객체가 죽고 빠져 버린 공간을 회수한다. 따라서 메모리 사용 면에서 아주 효율적이고, 메모리 단편화가 일어날 일도 없다.

### 6.5.3 병렬 수집기의 한계

병렬 수집기는 전체를 대상으로 한번에, 가능한 효율적으로 GC 를 수행함을 목적으로 한다.

이러한 설계 방식의 단점은 풀 STW를 유발한다는 것이다. 영 영역에서는 극 소수의 객체만 살아남기 때문에 STW가 별 문제는 없지만, 올드 세대는 디폴트 크기 자체가 영 세대의 7배나 되기 때문에 STW 시간이 영 수집보다 훨씬 길다. 

또한 영역 내 살아있는 객체 수만큼 마킹 시간이 늘어난다. 

그리고 올드 수집의 가장 큰 약점은 STW 시간이 힙 크기에 거의 비례한다는 것이다. 힙이 계속 커질 수록 ParallelOld GC의 중단 시간도 함께 나빠지기 시작한다.

parallel GC는 40년 넘게 사용되었기 때문에 이렇게 해볼까? 수준으론 절대 개선되지 않는다.

## 6.6 할당의 역할

> GC 사이클은 어떤 고정된, 예측 가능한 일정에 맞춰 발생하는 게 아니라, 하나 이상의 힙 메모리 공간이 꽉 채워져 더 이상 객체를 생성할 공간이 없을 때 일어난다. (규칙성 X)

할당의 중요성을 설명하기 위해 힙 크기를 다음과 같이 가정해보자.

<img width = "300" alt = "힙크기" src = "https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/63db40f5-1922-42ae-8369-68f8dde653cc">

다음은 애플리케이션이 정상 상태에 도달한 이후 측정한 몇가지 GC 지표이다.

<img width = "300" alt = "GC 지표" src = "https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/54a9cb3c-9c68-4d1d-9a62-6492a2c44469">

에덴은 4초면 채워지므로(400MB/100MB) 4초마다 한번씩 영 GC가 발생한다.

대부분의 객체는 사망하지만, 마지막 200밀리초 이내에 생성된 객체는 살아남아 서바이버 공간으로 방출된다. (200ms * 100MB/s = 20MB)

<img width = "500" alt = "GC" src = "https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/40015311-a858-485c-9b0b-3a98b4c5962c">

다시 에덴은 채워지고 객체를 방출시켜야 되지만, GC0때 살아남아 SS1으로 승격된 객체는 하나도 생존하지 못한다. 객체 수명이 200밀리초인데 4초가 더 경과했기 때문이다.

위와 같은 이상적인 단순 모형에서는 어느 객체도 테뉴어드 세대로 승격될 수 없고 이 공간은 실행하는 동안 계속 빈 상태일 것이다.(현실과 동떨어진 모형이다.)

---
실제로는 할당률이 심하게 변하거나 치솟기도 한다.

1. 처음 2초동안 200MB 객체가 에덴에 할당된다.
2. 장수 객체가 없다면, 이 객체의 수명은 100ms 이다.
3. 그리고 할당률이 확 치솟아 불과 0.2초만에 200MB 가 다시 에덴에 추가 할당된다. 그 결과 나이가 100ms 이하인 객체는 다 합쳐 100MB 이다.
4. 살아남은 객체 용량이 survival 보다 크기 때문에 JVM 은 테뉴어드로 보낸다.

<img width = "500" alt = "GC" src = "https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/c3e0b568-f5a7-4db6-82f9-4829f2d7772b">

100MB가 생존했지만 모두 금새 죽을 객체이기 때문에 테뉴어드는 지저분해진다. 이런 가비지는 풀 수집이 일어나기 전까지 회수되지 않기 때문이다.

몇번 더 수집을 진행해보자.

<img width = "500" alt = "GC" src = "https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/45d91709-3c16-4cc7-ac47-ec8490d9c260">

살펴보면 일정하게 실행된 것이 아니라 GC는 필요할 때 마다 실행된다.
할당률이 높다면 GC는 더 자주 발생하고, 너무 높다면 객체는 테뉴어드로 승격된다.

이러한 현상을 조기 승격 이라 한다. 조기 승격은 가비지 수집에서 가장 중요한 간접 효과이자, 많은 튜닝 활동의 출발점이다.



