성능을 진지하게 고민하는 자바 프로그래머는 가용 리소스를 최대한 활용할 수 있도록 자바 플랫폼의 근간 원리와 기술을 잘 알고 있어야 한다.

## 3.2 메모리

### 문제1. 프로세서/메모리 간 성능 차이
무어의 법칙에 따라 트랜지스터 개수가 증가하면서 클록 속도가 증가했다. 초창기 IBM PC 칩의 클록 속도가 4.77Hz 이었던 것에 비하면 요즘은 2GHz로 수백 배 더 빨라졌다. 이에 따라 메모리 전송 속도도 빨라져야하는데 메인 메모리가 그 속도를 따라가지 못해 문제가 발생한다.

![메모리 속도](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/62f67b60-3bab-459d-baf3-b3c9692b6207)

## 3.2 메모리 캐시

* 위의 문제에 대한 해결방안으로 CPU 캐시가 등장한다.
* CPU 캐시는 자주 액세스하는 메모리 위치를 CPU가 메인 메모리를 재참조하지 않도록 사본을 떠서 CPU 캐시에 보관한다.

### CPU캐시 계층
* 액세스 빈도가 높은 캐시일수록 프로세서 코어와 더 가까이 위치한다.
* CPU와 가장 가까운 캐삭 L1, 그다음 캐시가 L2이다.
* 일반적으로 각 실행 코어에 전용 프라이빗 캐시 L1, L2 를 두고, 일부 또는 전체 코어가 공유하는 L3캐시를 둔다.
![캐시레벨](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/759805f1-81aa-4ebb-9012-da4962d41767)

### 문제2. 캐시 일관성
캐시 덕분에 프로세서 처리율은 현저히 개선됐지만, 공유된 데이터는 캐쉬를 사용할 때 새로운 문제를 야기한다. 두개의 서로 다른 프로세서는 각자 자신의 캐쉬를 통하여 메모리를 접근하게 되고, 주의하지 않으면 두 개의 다른 값을 갖게 된다.

### 캐시 일관성 프로토콜 : 스누핑 프로토콜(=MESI 프로토콜)
* 각각 CPU의 캐시들은 공유되는 캐시 데이터를 파악하고 있으며, 공유되는 캐시 데이터가 갱신 되었을 경우 이를 기반으로 갱신되지 않은 나머지 데이터를 무효화한다. 
* 캐시는 자신이 가진 라인이 다른 캐시와 공유되는지를 파악하고 있으며 공유 캐시 라인이 갱신되었을 때 각 캐시 제어기는 Broadcasting 된 캐시 갱신 소식을 받아 해당 캐시를 무효화한다.
* 이 방법은 모든 캐시 라인의 상태를 Modified, Exclusive, Shared, Invalid로 표현하기에 MESI 프로토콜이라고도 한다.

* ex) CPU A가 메모리 상의 X의 데이터를 쓰기할 경우, 쓰기 전에 CPU B가 캐쉬에 가지고 있던 X의 값을 없는 값으로 무효화한다. 이후 CPU B가 다시 X에 읽기 요청하면 캐시 실패가 일어나고 메모리값에서 정확한 값을 읽어보게 되어 캐시 일관성을 유지한다. 


참고 : https://www.crocus.co.kr/1381#:~:text=멀티%20프로세서에서%20일

https://goodgid.github.io/Cache-Coherence/


## 3.3 최신 프로세서의 특징

### 3.3.1 변환 색인 버퍼(TLB)
> 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 수행한다.

* 페이지 테이블은 메인 메모리에 존재하는데 그렇다면 CPU는 메인 메모리에 최소 2번 접근해야 원하는 데이터를 얻을 수 있다.
    1. 페이지 테이블 접근

    2. 페이지 테이블 기반으로 실제 메모리 접근

* TLB 는 최근에 읽었던 페이지 테이블을 매핑하여 저장한다. 

### 3.3.2 분기 예측과 추측 실행
> 성능을 위해서 다음 실행될 명령어 예측하여 먼저 실행하는 기법이다. 분기 예측은 추측 실행의 한 종류라고 할 수 있다.

```
if(a>16)
    b = 32
```
* 위의 조건문에서 a > 16 을 판단하기 위해 a 값을 읽어오는데 시간이 걸린다. 이때 미리 b = 32 를 실행시켜둔다. 예측이 맞으면 미리 실행한만큼 성능이 좋아진다.

### 3.3.3 하드웨어 메모리 모델
* JIT 컴파일러인 javac와 CPU는 일반적으로 코드 실행 순서를 바꿀 수 있다.
* JMM 은 약한 모델로 설계되었다. 따라서 멀티스레드 코드가 제대로 작동하게 하려면 락과 volatile 을 정확히 알고 사용해야 한다.


## 3.4 운영체제
* OS의 역할은 여러 실행 프로세스가 공유하는 리소스 액세스를 관장하는 것이다.
* 한정된 리소스 가운데서 메모리와 CPU 시간이 가장 중요하다.

### 3.4.1 스케줄러
> 스케줄러는 인터럽트에 응답하고 CPU 코어 액세스를 관리한다. 이때 실행큐라는, 실행 대상이지만 CPU 차례를 기다려야 하는 스레드 혹은 프로세스 대기 장소인 큐를 이용한다.

* 스케줄러는 할당시간 끝 무렵에 실행 큐로 스레드를 되돌려 큐의 맨 앞으로 가 다시 실행될 때가지 대기시킨다.
* 스레드가 자신이 할당받은 시간을 자발적으로 포기하려면, sleep() 메서드나 wait () 메서드로 대기 조건을 명시할 수 있다. 또한 I/O , 소프트웨어 락에 걸려 블로킹될 수도 있다.

![스케줄링](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/9b77a208-fe60-4a14-adee-8cb3ebbaa5b9)

* 스케줄러의 움직임을 확인하기 가장 쉬운 방법은 오버헤드를 관측하는 것이다.
    * OS 마다 결과는 다르지만, 유닉스는 대략 10~20% , 윈도우는 180%에 이른다.

### 3.4.2 시간문제
* POSIX 같은 업계 표준이 있어도 OS는 저마다 다르게 작동한다.

### 3.4.3 컨텍스트 교환
> OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기 중인 다른 스레드/태스크로 대체하는 프로세스

* 유저모드에서 커널모드로 바뀌면서 일어나는 컨텍스트 교환은 매우 비싼 작업이다.
    * 유저모드 : 유저(사용자)가 접근할 수 있는 영역을 제한적으로 두고, 프로그램의 자원에 함부로 치범하지 못하는 모드이다.
    * 커널모드 : 모든 자원(메모리, CPU 등) 에 접근하고 명령할 수 있다.
    * I/O 장치를 보호하기 위해 두 가지 모드가 존재한다.
* 유저모드 -> 커널 모드로 바뀔 때 유저 공간에 있는 코드가 액세스하는 메모리 영역은 커널 코드와 공유할 부분이 없기 때문에 모드가 바귀면서 명령어와 TLB를 비롯한 다른 캐시까지도 무효화된다. 이후 시스템 콜 반환 시 다시 채워야 하므로 상당한 비용이 발생한다.

* 리눅스에서는 이를 만회하기 위해 가상 동적 공유 객체(vDSO) 를 제공한다. 커널 모드로 컨텍스트를 교환하지 않으므로 그만큼 속도가 빠르다.

참고 : https://jhnyang.tistory.com/190

https://blockdmask.tistory.com/69

## 3.6 기본 감지 전략
* 애플리케이션이 잘 돌아가는 것은 CPU 사용량, 메모리, 네트워크, I/O 대역폭 등 시스템 리소스를 효율적으로 잘 이용하고 있다는 뜻이다.
* 성능 진단의 첫 단추는 어느 리소스가 한계에 다다랐는지 밝히는 것이다.

### 3.6.1 CPU 사용률
* CPU의 효율적인 사용은 성능 향상의 지름길이다.
* vmstat 를 통해 현재 가상 메모리 및 I/O 서브시스템 상태에 관한 유용한 데이터를 제공받을 수 있다.

![vmstat](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/a4de277f-3859-4c27-9097-50cf2bc6f724)

|섹션|내용|
|------|---|
|pro 섹션|실행 가능한(r) 프로세스, 블로킹된(b) 프로세스 개수|
|memory 섹션|스왑 메모리(swpd), 미사용 메모리(free), 버퍼로 사용한 메모리(buff), 캐시로 사용한 메모리(cache)|
|swap 섹션|디스크로 교체되어 들어간(스왑-인) 메모리(si), 디스크에서 교체되어 빠져나온(스왑-아웃) 메모리(so)|
|io 섹션|블록-인(bi), 블록-아웃(bo) 개수|
|system 섹션|인터럽트(in) 및 초당 컨텍스트 교환(cs) 횟수|
|cpu 섹션|CPU와 연관된 지표를 CPU 사용률(%)로 표기한다. 유저 시간(us), 커널 시간(sy), 유휴 시간(id), 대기 시간(wa), 도둑맞은 시간(st)|

* 튜닝이 잘 된 프로그램은 리소스를 최대한 활용한다. 계산을 많이 하는 워크로드는 유저 공간의 CPU 사용률을 100%에 가깝게 유지하는 것이 목표이다.
* 따라서 측정 결과 CPU 사용률이 100%에 근접하지 않았다면 I/O 경합이 일어나 블로킹이 발생했는지, 스레드 락 경합 상황이 벌어졌는지 생각해봐야 한다.

### 3.6.2 가비지 수집
* 핫스팟 JVM은 시작 시 메모리를 유저 공간에 할당/관리한다. 따라서 메모리 할당을 위해 시스템 콜, 즉 커널 교환을 할 일이 거의 없다.
* GC 자체는 CPU 사용률의 주범이 아니다.
* 반면, 어떤 JVM 프로세스가 유저 공간에서 CPU를 100% 가까이 사용하고 있다면 GC 를 의심해야 한다.

### 3.6.3 입출력
* 파일 I/O는 적절히 추상화할 장치가 없기 때문에 전체 시스템 성능에 많은 악영향을 준다.
* 다행히 자바 프로그램은 대부분 단순한 I/O만 처리하고 I/O 서브시스템을 심하게 가동하거나 CPU, 메모리 어느 한쪽과 I/O를 동시에 고갈시키는 애플리케이션은 거의 없다.
* 성능 분석 시 애플리케이션에서 I/O가 어떻게 일어나는지 인지하는 것으로 충분하다.

### 3.6.4 기계 공감
* 성능을 향상시키기 위해서는 하드웨어를 폭넓게 이해하고 공감할 수 있는 능력이 무엇보다 중요하다.
* JVM이 하드웨어를 추상화했음에도, 고성능, 저지연이 필수인 분야에서 개발자가 자바/JVM 을 효과적으로 사용하려면 JVM이란 무엇이고 하드웨어와는 어떻게 상호작용하는지 이해해야 한다.

## 3.7 가상화

### 가상화의 특징
* 가상화OS에서 실행하는 프로그램은 베어 메탈(비가상화OS)에서 실행할 때와 동일하게 작동해야 한다.
* 하이퍼바이저는 모든 하드웨어 리소스 액세스를 조정해야 한다.
* 가상화 오버헤드는 가급적 작아야 하며 실행 시간의 상당 부분을 차지해선 안 된다.
---
* 게스트OS가 하드웨어에 직접 액세스할 수 없기 때문에 프리빌리지드 명령어를 언프리빌리지드 명령어로 고쳐 쓴다.
* 컨텍스트 교환이 발생하는 동안 지나친 캐시 플러시가 일어나지 않도록 일부 OS 커널의 자료 구조를 섀도한다.

$ \rightarrow $ 가상 환경 내에서 프로그램을 실행하는 것 자체가 성능 분석 및 튜닝을 한층 더 복잡하게 만든다.

## 3.8 JVM과 운영체제
* JVM은 자바 코드에 공용 인터페이스를 제공하여 OS 독립적 실행 환경을 제공한다.
* 하부 OS에 액세스하기 위해서는 native 키워드를 붙인 네이티브 메서드가 구현되어 있어야 한다.
* native 메서드는 C 언어로 작성하며 자바 네이티브 인터페이스(JNI) 가 이를 일반 자바 메서드처럼 접근할 수 있게 한다.

예시) 시스템에 특정한 OS :: javaTimeMillis()함수 호출 과정
1. 네이티브 메서드 System.currenttimeMillis()는 JVM_CurrentTimeMillis()라는 JVM 엔트리 포인트 메서드에 매핑된다. 
    * .java/lang/System.c 파일에 포함된 JNI에 이러한 매핑 관계가 설정되어 있다.
2. JVM_CurrentTimeMillis()는 VM 진입점에 해당하는 메서드를 호출한다. C 함수지만 본모습은 C++ 함수이다.
3. 결국 OpenJDK 매크로 2개로 감싼 OS :: javaTimeMillis() 를 호출한다.

![native](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/c2111a72-5ead-4e00-ae88-51a3df02505b)




