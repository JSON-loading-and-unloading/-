## 8.1 GC 로깅 개요

GC 로그는 시스템이 내려간 원인의 단서를 찾는 **콜드 케이스** 분석을 할 때 매우 유용하다. 파일에 쓰인 로그를 분석하는 작업이므로 애플리케이션 프로세스가 살아 있지 않아도 된다.

GC 로깅은 오버헤드가 거의 없기 때문에 주요 JVM 프로세스는 항상 로깅을 켜놓아야 한다.

### 8.1.1 GC 로깅 켜기

```
-Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintTenuringDistribution
-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps
```

* -Xloggc:gc.log
    * GC 이벤트에 로깅할 파일을 지정한다.
* -XX:+PrintGCDetails
    * GC 이벤트 세부 정보를 로깅한다.
* -XX:+PrintTenuringDistribution
    * 툴링에 꼭 필요한 부가적인 GC 이벤트 세부 정보를 추가한다.
* -XX:+PrintGCTimeStamps
    * GC 이벤트 발생 시간을 출력한다.
* -XX:+PrintGCDateStamps
    * GC 이벤트 발생 시간을 출력한다.

다음은 필수 플래그에서 주의해야 할 사항이다.
* 기존 플래그 verbose:gc 대신 **PrintGCDetails**를 사용한다.
* PrintTenuringDistribution의 정보는 사람이 이용하기 어렵다. 중요한 메모리압 효과, 조기 승격 등의 이벤트 계산시 필요한 기초 데이터를 제공한다.
* PrintGCDateStamps & PrintGCTimeStamps 둘 다 필요하다.

로그를 많이 남겨도 JVM 성능에 영향을 미치지 않는다.

### 8.1.2 GC 로드 vs JMX

자바 관리 확장(JMX) 인터페이스를 통해 JVM 데이터를 수집한다.

JMX는 스트리밍된 데이터를 즉시 제공한다는 점에서 GC 로그보다 낫지만, 요즘은 jClarity 센섬같은 툴도 GC 로그 데이터를 스트리밍하는 API를 제공하므로 큰 차이가 없다.

### 8.1.3 JMX의 단점

JMX 는 대부분 런타임을 샘플링하여 현재 상태를 업데이트 받는다.

* 클라이언트가 각 수집 사이클 전후의 메모리 상태를 알 수가 없으므로 GC 데이터를 깊이 있게, 정확하게 분석할 수 없다.
* 매우 중요한 활동인 메모리압 분석이 JMX가 데이터를 수집하는 방식 때문에 불가능하다.
* RMI(Remote Method Invocation)에 의존하므로 RMI 기반 통신 채널의 고질적인 문제점에 취약하다.
    * RMI : 분산되어 존재하는 객체 간의 메시지 전송(메소드를 호출하는 것 포함)을 가능하게 하는 프로토콜
    * 방화벽에 포트를 열어야 하기 때문에 부차 소켓 접속이 맺어질 수 있다.
    * 프록시 객체를 이용해 Remove() 메서드 호출을 대행한다.
    * 자바 종료화에 츼존한다.
    * RMI 사용하면 기본 1시간에 한번씩 풀 GC가 발생한다.

### 8.1.4 GC 로그 데이터의 장점

처음에 GC 로깅은 JVM 디버깅 용도로 추가되었지만, GC 튜닝 시 GC 로깅이 유용하다는 사실을 깨달았다.

GC 로그에 쌓인 기초 데이터는 특정 GC 이벤트와 연관 지을 수 있어서 모든 의미 있는 분석 작업을 수행할 수 있다.

## 8.2 로그 파싱 툴

스스로 GC 로그를 파싱하려고 하지 말고 반드시 툴을 사용하자.

### 8.2.1 센섬
* jClarity 사가 제작한 상용 메모리 분석기
* 서비스 모니터링 용도
* GC 로그 파싱, 정보 추출, 자동 분석 기능을 제공

### 8.2.2 GCViewer
* GC 로그 파싱 및 그래프 출력 기능을 가지고 있다.
* 분석 기능은 없고 GC 핫스팟 로그 포맷만 파싱할 수 있다.

## 8.3 GC 기본 튜닝

"GC는 언제 튜닝해야 할까?"

-> 전체 진단 과정의 일부여야 한다. 다만, 리스크에 비해 얻는 부분이 적기 때문에 GC를 건드리는 것보다 애플리케이션 코드로써 메모리 최적화를 더 신경 쓸 것을 권장하는 의견도 있다. 가장 마지막에 하는 작업임을 잊지말자.

튜닝시 다음 4가지 주요 인자를 면밀히 관찰/측정해야 한다.
* 할당
* 중단 민감도
* 처리율 추이
* 객체 수명

JVM의 힙 메모리는 크기에 따라 GC 발생 횟수와 수행 시간에 영향을 끼치기 때문에 옵션을 통해 조절하면 어플리케이션 성능 향상 효과를 가져올 수 있다.
여기서 말하는 메모리 크기는 JVM의 시작 크기(-Xms)와 최대 크기(-Xmx)를 말한다.

튜닝시 GC 플래그는 다음과 같이 추가한다.
* 한번에 한 플래그씩 추가한다.
* 각 플래그가 무슨 작용을 하는지 숙지해야 한다.
* 부수 효과를 일으키는 플래그 조합도 있음을 명시한다.

### 8.3.1 할당이란?

할당률 분석은 GC를 튜닝하면 성능이 개선될지 여부를 판단하는 데 반드시 필요한 과정이다.

초기 할당 전략은 다음 4가지 영역에 집중하자

* 굳이 없어도 그만인, 사소한 객체 할당
    * 단순히 불필요한 객체를 제거한다.
    * ex) 로그 디버깅 메시지, JSON 직렬화/역직렬화용 자동 생성 코드, ORM 코드
* 박싱 비용
    * 박싱은 int나 float같은 값을 객체 안에 넣어주는 일.
* 도메인 객체
    * 다음 타입의 도메인 객체는 메모리를 많이 먹을 수 있으니 참고하자.
    * char[ ] : 스트링을 구성하는 캐릭터
    * byte[ ] : 바이너리 데이터
    * double[ ] : 계산 데이터
    * Map Entry
    * Object[ ]
    * 내부 자료구조
* 엄청나게 많은 논JDK프레임워크 객체

TLAB는 스레드 당 크기가 동적으로 조정되며, 일반 객체는 남은 TLAB 공간에 할당된다. 만약 여유 공간이 없다면 스레드는 VM에게 새로운 TLAB를 달라고 요청한다.

객체 크기가 너무 커서 빈 TLAB에 들어가지 않으면 VM은 에덴에 직접 객체 할당을 시도하고, 이마저도 실패하면 영 GC를 수행한다. 만일 여기서도 실패하면 테뉴어드 영역에 객체를 직접 할당한다.

관련 튜닝 플래그는 다음과 같다.
* -XX:PretenureSizeThreshold=<n>
    * 여기서 지정한 크기를 넘어가는 객체는 Young Genreation을 거치지 않고 Old Generation으로 바로 들어간다.
* -XX:MinTLABSize=<n>
    * TLAB의 최소 크기를 설정한다
* -XX:MaxTenuringThreshold=<n>
    * 테뉴어드 영역으로 승격되기 전까지 객체가 통과해야할 GC 횟수다. 디폴트는 4회이고 1~15사이의 값을 가질 수 있다.

매사 그렇듯 논디폴트 값으로 성능이 확실히 나아진 벤치마킹 사례가 없는 한 스위치를 함부로 변경하지 말자.

### 8.3.2 중단시간이란?

대부분의 애플리케이션에서 100밀리초 정도의 중단 시간은 무시할 만하다. 초당 100~200밀리초 정도의 중단은 눈치채기도 어렵다.

중단 시간 튜닝 시 유용한 휴리스틱
* > 1초 : 1초 이상 걸려도 괜찮다.
* 1초 ~ 100 밀리초 : 100밀리초 이상 1초 이하 정도는 괜찮다.
* < 100밀리초 : 100밀리초까지는 괜찮다.

중단 민감도를 애플리케이션 힙 크기와 연관지어보면 어떤 수집기가 적합한지 알 수 있다.

## 8.4 Parallel GC 튜닝

Parallel GC는 가장 단순한 수집기라 튜닝이 쉽다.

Parallel GC의 목표와 트레이드 오프
* 풀 STW
* GC 처리율이 높고 계산 비용이 싸다.
* 부분 수집이 일어날 가능성은 없다.
* 중단 시간은 힙 크기에 비례하여 늘어난다.

힙이 4GB 이하로 작을 경우 Parallel GC는 아주 효과적인 선택이다.

과거에는 다양한 메모리 풀 상대적 크기를 조정하기도 했지만 최신 애플리케이션은 사람보다 프로그램이 크기를 알아서 잘 결정하기 때문에 명시적으로 크기를 설정하는 일은 삼가는 게 좋다.

## 8.5 CMS 튜닝

CMS는 튜닝이 까다롭기로 소문난 수집기이다.

CMS처럼 중간 시간이 짧은 수집기는 정말 STW 중단 시간을 단축시켜야 할 필요가 있을 때에 한해서만 사용해야 한다. 그렇지 않으면 앞서 설명한 여러 안티패턴의 늪에 빠질 우려가 있다.

---

그럼에도 CMS 성능 개선이 필요하다면 **처리율**부터 보자.

CMS 수집이 일어나면 코어의 절반이 GC에 할당되므로 애플리케이션 처리율은 반토막이 난다. 이때, CMF(Concurrent Mode Failure) 발생 직전의 수집기 상태를 살펴보는 것이 중요한 지표를 가져다 준다.

CMS 수집이 끝나자 바로 새 CMS 수집이 시작되면 (이를 **백투백 현상**이라고 한다.) 애플리케이션의 메모리 할당 속도가 회수 속도를 능가하면서 결국 CMF가 발생한다.

백투백 현상이 일어나면 전체 애플리케이션 실행 처리율은 50% 떨어진다. 성능 엔지니어는 튜닝 시 이런 상황이 발생해도 괜찮은지 고민해보고, 괜찮지 않다면 코어 수를 늘리는 해결 방안을 모색해야 할 것이다.

CMS 수집 중 GC에 할당된 코어 수를 줄이는 방법도 있다.(결국 CMF에 더 취약해지지만) ..?

동시 GC 스레드 개수는 다음 스위치로 조정한다.
* -XX:ConcGCThreads=<n>

다음으로, CMS에서 STW는 두 단계에서 발생한다.

* 초기 마킹 : GC 루트가 직접 가리키는 내부 노드를 마킹한다.
* 재마킹 : 카드 테이블을 이용해 조정 작업이 필요한 객체를 식별한다.

모든 애플리케이션 스레드는 CMS가 한 번 일어날때마다 반드시 2회 멈추는데, 이는 중요한 영향을 미칠 수 있다.

다음의 두 플래그를 적용하자.

* -XX:CMSInitiatingOccupancyFraction=<n>
    * CMS 가 언제 수집을 시작할지 설정하는 플래그이다. 기본적으로 최초의 CMS 풀 GC는 힙이 75% 찼을 때 시작된다.
* -XX:+UseCMSInitiatingOccupancyOnly
    * 초기 점유 공간을 동적 크기 조정하는 기능이 꺼진다. 이 플래그는 함부로 켜면 안 된다. 
    * 할당률이 심하게 튀는 CMS 애플리케이션이라면 여유 공간을 늘리고 능동적 크기 조정 기능을 끄는 전략을 구사할 수 있다.

### 8.5.1 단편화로 인한 CMF

**프리 리스트 통계치** 를 바탕으로 힙 단편화로 인한 CMF 발생을 미리 알 수 있다.

* -XX:PrintFLSStatistics=1

다음의 스위치를 추가하면 GC 로그에 몇몇 추가 정보가 표시된다.

* Total Free Space : 총 프리 공간
* Max Chunk Size : 최대 청크 크기
* Number of Blocks : 블록 개수
* Av. Block Size : 평균 블록 크기
* Tree Height : 트리 높이

덩치 큰 라이브 객체를 테뉴어드로 옮기려고 하는데 그만한 크기의 청크가 바닥난 경우, GC 승격이 악화되어 결국 CMF 로 이어진다. 실시간으로 분석하면 이러한 시간이 긴 중간이 임박했음을 알 수 있다.

## 8.6 G1 튜닝

G1 은 처음 등장한 이후로 내부적으로 상당히 많이 변화를 겪었기 때문에 초창기와 맞지 않는 내용이 많아 섣불리 민간 튜닝을 하면 심각한 문제가 발생할 수 있다. 

G1 은 자바 9부터 디폴트 수집기로 격상되기 때문에 성능 엔지니어는 어쩔 수 없이 G1 튜닝 문제도 함께 다루어야 한다.

어떤 애플리케이션에서 할당률이 높은 상태로 대부분 단명 객체가 생성되고 있다면 다음  튜닝을 고려해봄 직하다.
* 영 세대를 크게 설정한다.
* 테뉴어드 한계치를 최대 15 정도로 늘려 잡는다.
* 애플리케이션에서 수용 가능한 최장 중단 시간 목표를 정한다.

## 8.7 jHiccup

JVM이 연속적으로 실행되지 못하는 지점, 즉 히컵을 보여주는 계측 도구이다. 히컵을 일으키는 가장 흔한 원인은 GC STW 중단이지만, OS나 플랫폼 관련 문제 때문에 발생하기도 한다.




