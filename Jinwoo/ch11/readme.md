## CH11 자바 언어의 성능 향상 기법

## 11.1 컬렉션 최적화

## 11.2 List 최적화

자바에서는 리스트를 ArrayList와 LinkedList 두 가지 형태로 나타낸다.

### 11.2.1 ArrayList

ArrayList는 **고정 크기 배열**에 기반한 리스트이다. 

배열이 꽉 차면 더 큰 배열을 새로 할당한 다음 기존 값을 복사하기 때문에 성능에 민감할수록 크기 조정 작업 비용과 유연성을 잘 저울질해야 한다.

1. 생성자에 크기 지정
    ```
    List<String> list = new ArrayList<>(1_000_000);
    for(int i=0; i < 1_000_000; i++>) {
        list.add(item);
    }
    return list;
    ```

2. 크기 지정 X
    ```
    List<String> list = new ArrayList<>();
    for(int i=0; i < 1_000_000; i++>) {
        list.add(item);
    }
    return list;
    ```

테스트를 수행했을 때 1번이 초당 약 100회 더 처리했다. ArrayList 크기를 정확히 결정하고 시작하는 게 성능이 더 낫다.

### 11.2.2. LinkedList

LinkedList는 동적으로 증가하는 리스트이다. 이중 연결 리스트로 구현되어 있어 리스트에 덧붙이는 작업은 항상 O(1)이다.

### 11.2.3 ArrayList vs LinkedList

둘 중 어느 것을 쓸지는 데이터 접근/수정 패턴에 따라 다르다.

* 특정 인덱스에 원소 추가
    * ArrayList : 다른 원소들을 모두 한 칸씩 움직여야 한다.
    * LinkedList : 노드를 하나 생성한 후 두 레퍼런스를 세팅하면 간단히 끝난다.
* 원소 삭제
    * ArrayList : 삭제할 원소 오른편에 있는 원소들을 모두 한칸씩 옮겨야 한다.
    * LinkedList : 많아야 레퍼런스 2개만 바꾸면 되므로 훨씬 저렴하다.
* 랜덤 액세스
    * ArrayList : 모든 원소를 O(1) 시간만에 가져올 수 있다.
    * LinkedList : 처음부터 인덱스 카운트만큼 원소를 방문해야 한다.

## 11.3 Map 최적화

### 11.3.1 HashMap

indexFor() 메서드를 키 객체의 hashCode() 메서드를 사용하는 코드로 교체하고, 마스크를 적용해 상위 비트를 아랫쪽 해시 부분에 분산시켰다. 즉, '해시 충돌'을 막기 위해 시프트(shift) 및 XOR 연산을 적용했다.

생성자에 전달하는 **initialCapacity** 와 **loadFactor** 두 매개변수는 HashMap의 성능에 가장 큰 영향을 미친다.

용량을 2배 늘리고 저장된 데이터를 다시 배친한 다음, 해시를 다시 계산하는 과정을 **재해시** 라고 한다.

최대 원소 개수를 loadFactor로 나눈 값을 initialCapactiy로 설정하면 재해시가 발생하지 않는다.

initialCapacity와 loadFactor를 높게 잡으면 순회 시 성능에 상당한 영향을 받는다.

버킷이 금세 채워지는 경우, 원소를 LinkedList로 구현하면 원소 하나를 찾으러 리스트를 훑어보는 작업도 크기가 커질수록 평균 비용이 더 든다.
하나의 버킷에 TREEIFY_THRESHOLD에 설정한 개수만큼 키/값 쌍이 모이면 버킷을 TreeNode로 바꿔버린다.

값이 잘 분포되는 해시 함수를 쓰면 버킷을 TreeNode로 바꿀 일이 거의 없다.

### LinkedHashMap

이중 연결 리스트를 사용해 원소의 **삽입 순서**를 관리한다.

기본 관리 모드는 삽입 순서이지만, 생성자의 세 번째 인수를 true로 지정하면 접근 모드로 전환된다. 접근 모드로 지정하면 가장 과거에 접근한 원소부터 가장 최근에 접근한 원소 순서로 정렬된다. 

Map을 사용하는 코드에서는 삽입/접근 크게 순서가 중요하지 않기 때문에 사용할 일이 거의 없다.

### 11.3.2 TreeMap

이진탐색트리의 문제점을 보완한 레드-블랙 트리로 이루어져 있다.

TreeMap은 다양한 키가 필요할 때 아주 유용하며, 정렬된 데이터를 조회해야 하는 범위 검색이 필요한 경우 사용하는 것이 효율성 측면에서 좋다.

대부분은 HashMap을 사용하는 것으로 충분하지만, 스트림이나 람다로 Map 일부를 처리할 때는 데이터 분할이 주특기인 구현체를 쓰는 것이 바람직하다.

### 11.3.3 MultiMap 없음

하나의 키에 여러 값을 묶은 MultiMap 구현체를 제공하지 않다. 사용할 일이 드물고 대부분 Map< K, List<V> > 형태로도 충분히 구현 가능하다.

## 11.4 Set 최적화

HashSet은 **HashMap**으로 구현되어 있다.

Set은 중복값을 허용하지 않는데, Map의 키 원소도 똑같다. HashSet의 add() 메서드가 내부적으로 사용하는 HashMap은 키가 원소 E, 값이 PRESENT라는 더미 객체로 구성된다. PRESENT는 한번 만들어 참조하는 객체라서 오버헤드는 무시할 정도이다.

두 번째 protected 생성자는 LinkedHashMap 객체를 받는데, 이로써 삽입 순서를 유지하는 LinkedHashMap 로직을 그대로 따라할 수 있다.

삽입/삭제, contains 작업은 복잡도가 O(1)이고 원소 순서는 유지하지 않으며(LinkedHashSet을 사용하지 않는 한), 순회비용은 initialCapactiy, loadFactor에 따라 달라진다.

TreeSet 역시 TreeMap을 활용한다. Comparator에 정의한 순서대로 정렬된 키 순서를 유지하므로 TreeSet에 더 알맞게 범위 기반 작업 및 순회 작업을 할 수 있다.

## 11.5 도메인 객체

도메인 객체는 애플리케이션에 유의미한 비즈니스 컨셉트를 나타낸 코드이다. 도매인 객체는 대부분 타입 간에 연관되어 있다. 예를 들어 하나의 Order에는 여러 OrderItem 인스턴스가 매핑된다.

```jmap -histo``` 와 같은 명령을 실행하면 힙 상태를 살펴볼 수 있고 메모리 누수 현상을 효과적으로 진단할 수 있다.

도메인 객체는 애플리케이션에서 일차적인 비즈니스 관심사를 나타내고 어느 정도 유일한 상태값을 지니고 있기 때문에 메모리 누수 같은 버그를 찾는 과정에서 쉽게 눈에 띈다.

자바 힙에 관한 기본적인 팩트를 보면 그 이유를 알 수 있다.
* 가장 흔히 할당되는 자료 구조는 스트링, char 배열, byte 배열, 자바 컬렉션 타입의 인스턴스이다.
* jmap에서 누수되는 데이터는 비정상적으로 비대한 데이터셋으로 나타난다.

즉, 메모리 점유량과 인스턴스 개수 모두 보통 코어 JDK에 있는 자료구조가 상위권을 형성하는게 보통인데 애플리케이션에 속한 도메인 객체가 jmap 결과치의 상위 30위 정도 안에 든다면 메모리 누수가 발생한 신호라고 볼 수 있다.

메모리 누수를 일으키는 도메인 객체의 또 다른 특징은 '전체 세대'효과이다. 이에 신속히 대처하려면 도메인 객체에 대응되는 데이터셋의 크기를 살피고 그 수치가 온당한지, 그리고 작업 세트에 존재하는 도메인 객체 수가 예상 범위 내에 들어 있는지 확인해야 한다.

많은 애플리케이션에서 도메인 객체는 탄광 속의 카나리아와 같은 역할을 한다. 사실 도메인 객체는 비즈니스 관심사를 가장 분명하게, 자연스럽게 나타낸 객체라서 메모리 누수에 더 취약하다. 성능을 중요시하는 개발자는 도메인 객체의 도메인을 인식하고 그에 알맞은 크기의 작업 세트가 배정되도록 해야 한다.

## 11.6 종료화 안 하기

자바 finalize() 메서드는 C++의 RAII 패턴과 마찬가지로 자동으로 리소스를 관리하려고 만든 장치이다. 

기본 유스케이스는 간단하다. 어떤 객체가 생성되면 이 객체는 리소스를 소유하고 그 소유권은 객체가 살아있는 한 지속된다. 그러다 객체가 죽음을 맞이하면 리소스 소유권을 자동으로 내어준다.

리소스 소유권은 객체 수명과 단단히 묶는 것이 타당하며 객체가 지닌 리소스를 자동으로 없애는 일은 프로그래머가 아닌, 플랫폼의 몫이다.

### 11.6.1 무용담 : 정리하는 걸 깜빡하다

타 서비스에 TCP로 접속해서 권한 및 자격 정보를 받아오는 서비스

close() 함수가 호출되지 않아 TCP 접속이 계속 열려 있었고 이는 파일 핸들러 리소스를 고갈시키고 같은 머신에 상주한 다른 프로세스에도 영향을 미쳤다.

### 11.6.2 왜 종료화로 문제를 해결하지 않을까 ?

Object 의 finalize() 메서드는 자바 태동기부터 있었지만 기본적으로 노옵메서드이고 또 그래야만 한다.

다음과 같은 문제점이 있다.

* 종료화 스레드 실행 도중 메서드 예외가 발생하면 유저 애플리케이션 내부에는 아무런 컨텍스트도 없기 때문에 발생한 예외는 그냥 무시된다.
* 종료화에 블로킹 작업이 있을 수도 있어 JVM이 스레드를 하나 더 만든데, 새 스레드를 생성/실행하는 오버헤드를 감수해야 한다.

자바 9부터 Object.finalize()는 디프리케이트 됐다.

### 11.6.3 try-with-resources

자바 7 이전까지는 리소스를 닫는 일은 개발자의 몫이었다.

자바 7부터 언어 자체에 추가된 try-with-resources 생성자를 이용하면 try 키워드 다음의 괄호 안에 리소스를 지정해서 생성할 수 있다. try 블록이 끝나는 지점에 개발자가 close() 메서드 호출을 깜빡 잊고 빠드려도 자동으로 호출된다.

### 종료화 vs. try-with-resources

* 종료화

    * 런타임 내부 깊숙한 곳에 있는 어셈블리 코드에 기반해 객체를 미리 등록하고 특별한 GC 작업을 수행한다. 
    * 그런 다음, 가비지 수집기를 이용해 레퍼런스 큐와 별도의 전용 종료화 스레드를 동원해 정리 작업을 한다.
    * 따라서 바이트코드에서 종료화 흔적을 찾아보기 어렵고 VM 내부에 이런 일을 담당하는 특수한 장치가 준비돼 있다.

* try-with-resources

    * 순수한 컴파일 타입 기능이다. 컴파일하면 평범한 바이트코드로 바뀐다.
    * 상당히 큰 바이트코드로 변환되므로 JIT 컴파일러가 인라이닝하고 메서드를 컴파일하는 과정에 좋지 않은 영향을 끼칠 수 있다.

## 11.7 메서드 핸들

자바 7에 등장한 invokedynamic 명령어 덕분에 호출부에서 실행할 메서드를 아주 유연하게 결정할 수 있게 되었다. 

invokedynamic 호출부가 실제로 어느 메서드를 호출할지 런타임 전까지 결정되지 않는다. 대신, 호출부가 인터프리터에 이르면 특수한 보조 메서드(BSM)이 호출되고, 이 BSM은 호출부에서 호출됐어야 할 실제 메서드를 가리키는 객체를 반환한다. 

여기서 호출부에 의해 호출되는 메서드를 나타낸 객체를 **메서드 핸들(method handle)** 이라고 한다.

메서드 핸들은 리플렉션으로 할 수 없는 신선한 기능을 갖추고 있다.

메서드 핸들 API는 룩업 컨텍스트라는 방식으로 접근한다. 일단 MethodHandles.lookup() 메서드를 호출해 컨텍스트 객체를 생성하는데, 이 메서드가 반환한 불변 객체에는 컨텍스트 객체를 생성한 지점에서 액세스 가능한 메서드 및 필드를 기록한 상태 정보가 있다. 이 컨텍스트 객체는 바로 사용해도 되고 나중에 써도 되는데 이런 유연성 덕분에 클래스에 있는 프라이빗 메서드를 선택적으로 액세스할 수 있다.

반면 리플렉션은 setAccessible()라는 꼼수를 사용하는데 자바의 안전한 액세스 제어 체계에 큰 허점을 노출시킨다.

대부분 개발자에게 메서드 핸들이란 코어 리플렉션과 기능은 비슷하나 최대한 정적 타입을 안전하게 지키는 요즘 방식의 리플렉션이라고 생각하면 된다.
