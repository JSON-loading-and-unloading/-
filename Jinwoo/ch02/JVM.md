JVM이 자바 코드를 실행하는 방법을 소개한다.

## 2.1 인터프리팅과 클래스 로딩

### 클래스 로더
자바 클래스들은 시작 시 한번에 로드되지 않고, 애플리케이션에서 필요할 때 로드된다. 클래스 로더는 JRE 의 일부로써 **런타임에 클래스를 동적으로 JVM에 로드하는 역할을 수행** 하는 모듈이다. 자바의 클래스들은 자바 프로세스가 새로 초기화되면 클래스로더가 차례차례 로딩되며 작동한다.

* 부트스트랩 로더 : 제일 먼저 실행되는 클래스로더이다. 다른 클래스로더가 나머지 시스템에 필요한 클래스를 로드할 수 있게 최소한의 필수 클래스(예 : java.lang.Object, Class, ClassLoader)만 로드한다.
    
    java8 기준으로 ${JAVA_HOME}/jre/lib 에 위치한 자바 런타임 코어 클래스를 로드한다. 특히 rt.jar 파일에는 java.lang, java.util 등의 필수 패키지들이 들어 있는 것을 확인할 수 있다.

* 확장 클래스 로더 : 부트스트랩 클래스로더를 부모로 갖는 클래스로더로써, 확장 자바 클래스들을 로드한다.

* 애플리케이션 클래스 로더 : 자바 프로그램 실행 시 지정한 Classpath 에 있는 클래스 파일 혹은 Jar 에 속한 클래스들을 로드한다.

ClassNotFoundException : 클래스를 찾지 못한 클래스로더는 기본적으로 자신의 부모 클래스로더에게 대신 찾기를 넘긴다. 이렇게 부모의 부모로 거슬러 올라가 결국 부트스트랩도 찾지 못하면 해당 예외가 발생한다.

## 2.2 바이트코드 실행

### 자바 소스코드의 실행
> 첫 단계 : 자바 컴파일러 **javac** 를 이용해 컴파일
* 자바 소스 코드를 바이트코드로 가득 찬 .class 파일로 변환
* 바이트코드 특징 : 특정 컴퓨터 아키텍처에 특정하지 않은 중간 표현형이다. 컴퓨터 아키텍처의 지배를 받지 않으므로 이식성이 좋아 JVM 지원 플랫폼 어디에서든 실행할 수 있다.

### 클래스 파일 해부도
* 매직넘버 : 클래스 파일임을 나타내는 4바이트 16진수
* 클래스 파일 포맷 버전 : 클래스 파일의 메이저/마이너 버전. 실행하는 대상 JVM 이 컴파일한 JVM 보다 버전이 낮아 호환되지 않으면 **UnsupportedClassVersionError** 예외가 발생한다.
* 상수 풀 : 클래스 상수들이 모여 있는 위치
* 액세스 플러그 : 추상 클래스, 정적 클래스 등 클래스 종류를 표시
* this 클래스 : 현재 클래스명
* 슈퍼 클래스 : 슈퍼(부모)클래스명
* 인터페이스 : 클래스가 구현한 모든 인터페이스
* 필드 : 클래스에 들어 있는 모든 필드
* 메서드 : 클래스에 들어 있는 모든 메서드
* 속성 : 클래스가 지닌 모든 속성

## 2.3 핫스팟 입문

* C ++ -> 제로-오버헤드 원칙 준수 / 특정 플랫폼에 종속된다.
    * **제로 오버헤드**를 가진 코드 또는 기능은 최소한의 리소스와 연산만을 사용하여 최적의 성능을 달성하는 것을 목표한다. 
* 핫스팟 -> 런타임 동작을 분석하고 성능에 유리한 방향으로 영리한 최적화를 적용하는 가상 머신
    * 목표 : 자연스럽게 자바 코드를 작성하고 바람직한 설계 원리를 따르도록 하는 것.

## JIT 컴파일이란?

> 애플리케이션을 모니터링하면서 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일을 수행한다.

* JVM은 바이트 코드를 인터프리터를 사용하여 한 줄씩 실행한다.
* 하지만 핫스팟은 인터프리터만을 사용하는 것보다 더 나은 성능을 위해 동적 컴파일 기술인 JIT(Just-In-Time) 컴파일러를 도입한다.
* 핫스팟의 JIT 컴파일러는 프로그램의 실행 패턴을 분석하고, 자주 실행되는 코드를 식별하여 해당 부분을 컴파일하여 네이티브 코드로 변환한다.

### JIT 컴파일의 이점
* 미리 프로그래밍한 추적 정보가 취합되면서 더 정교한 최적화가 가능하다.
* '상식적인' 추론으로 애플리케이션이 실제로 동작하는 방식을 단순히 넘겨짚지 않도록 주의해야 한다.

## JVM 메모리 관리
* C, C++, 오브젝티브-C 개발자는 직접 메모리 할당/해제 작업을 수행하였다.
* 사람이 관리하면 조금 더 확정적인 성능을 낼 수 있지만 그만큼 개발자의 부담이 커진다.

### 가비지 수집 (Garbage Collection)
* 프로세스를 이용해 힙 메모리를 자동 관리
* JVM 이 더 많은 메모리를 할당해야 할 
때 불필요한 메모리를 회수하거나 재사용하는 불확정적 프로세스이다.

## 2.7 JVM 모니터링과 툴링
### JVM과 관련된 툴
* JMX
* 자바 에이전트
* JVMTI
* SA
### 2.7.1 VisualVM
> JVM CPU 메모리, Heap, Thread 의 상태와 GC 수행 등 다양한 기능들에 대해 시각화를 제공해주는 툴

### 5가지 기본 탭

1. 개요(Overview)

    : 자바 프로세스에 관한 요약 정보 표시

2. 모니터(Monitor)

    : CPU, 힙 사용량 등 JVM을 고수준에서 원격 측정한 값 표시

3. 스레드(Thread)

    : 실행 중인 애플리케이션 각 스레드가 시간대별로 표시된다. 스레드별 상태와 짧은 변화 추이를 보면서 필요시 스레드 덤프를 뜰 수 있다.

* 스레드 덤프(Thread Dump) : 프로세스에 속한 모든 스레드들의 상태를 기록(snapshot)한 것이다. 스레드 덤프는 프로그램이 멈추거나 느려지는 등의 문제가 발생할 때 디버깅 및 분석 목적으로 사용된다.

4. 샘플러 및 프로파일러(Sample and Profiler)

    : CPU 및 메모리 사용률에 관한 단순 샘플링 결과가 표시된다.


