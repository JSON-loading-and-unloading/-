## Ch 01

## 1.4 성능 분류
---

### 처리율(Throughput)
> 일정 시간동안 완료한 작업 단위 수 ex) TPS (초당 처리 가능한 트랜잭션 수)
* 시스템이 수행 가능한 작업 비율
* 의미 있는 지표가 되기 위해서는 수치를 얻은 기준 플랫폼에 대해서도 내용을 기술해야 한다.

    ex) 하드웨어 스펙, OS, 소프트웨어 스택
* 처리율 테스트시 워크로드 역시 일정하게 유지해야 한다.

    * 워크로드 : 시스템이 주어진 시간 내에 처리해야 할 작업 할당량

[TPS 참고 자료](https://www.whatap.io/ko/blog/14/)

<br>

### 지연(Latency)
> 수도관 자체의 길이
* 1초에 100리터 흘려보내는 수도관의 처리율은 1초에 부피(100리터)이다.
* 이때 수도관 자체의 길이를 지연이라고 한다.
* 즉, 하나의 트랜잭션을 처리하고 그 결과를 반대편 수도관 끝에서 바라볼 때까지 소요된 시간(=종단시간)

<br>

### 용량(Capacity)
> 시스템이 동시 처리 가능한 단위(=작업 병렬성의 총량)
* 처리율 또는 지연 값을 전제로 가능한 처리량을 표시

<br>

### 사용률(Utilization)
> 시스템 리소스 활용률
* 워크로드에 따라서 리소스별로 사용률이 들쑥날쑥할 수 있다. 
* 예를 들어 컴퓨터 시스템이나 프로세서에 대한 높은 계산 요구 사항을 가지고 있는 작업, 이를테면 암호화 작업을 주면 CPU 를 많이 사용하게 된다. 이때 CPU 사용률은 100% 에 육박하지만, 다른 리소스의 사용률은 상대적으로 낮다.

<br>

### 효율(Efficiency)
> 처리율 / 리소스 사용률
* 동일 처리율 처리를 위해 더 많은 리소스를 사용한다면 효율이 낮은 것.
* 혹은 비용 측면에서 볼 때, 처리율이 동일할 때 총소유비용(TCO) 값이 더 크다면 효율이 낮은 것.

<br>

### 확장성(Scalability)
> 리소스 추가에 따른 처리율 변화
* 리소스 추가에 따른 처리율 변화는 시스템의 확장성을 가늠하는 척도이다.
* 서버 클러스터 기반으로 구축된 시스템에서, 클러스터(리소스)를 2배 확장했을 때 트랜잭션 처리량도 2배 늘었다면 이 시스템은 '완벽한 선형 확장'을 달성한 것이다.
* 리소스를 어느 정도까지 늘리면 거의 선형적으로 확장되지만 대부분 부하가 높아지면 완벽한 확장을 저해하는 한계점에 도달한다.

<br>

### 저하(Degradation)
> 지연이 증가하는 양상
* 시스템이 부하를 받으면 지연과 처리율에 변화가 생긴다. 이는 사용률에 따라 다른데, 시스템이 풀 가동된 상태라면 **처리율이 더 늘어나지 않고 지연이 증가하는 양상**을 띄게 된다. 이런 현상을 부하 증가에 따른 저하라고 한다.

<br>

### 측정값 사이의 연관 관계
* 부하가 증가할 때, 

    확장성을 감안하면 가용 리소스도 함께 늘려야 한다. 하지만 시스템이 이렇게 확장한 리소스를 제대로 활용할 수 있을지가 관건이다.

    반면 부하는 늘었는데 리소스가 그대로라면 지연이 발생할 것이다.
* 부하 증가로 반직관적인 결과를 얻는 경우도 있다.

    핫스팟 JIT 컴파일러의 경우, JIT 컴파일 대상이 되는 메서드는 '충분히 빈번하게' 인터프리티드 모드로 실행되어야 한다. 
    
    따라서 오히려 부하가 많을 때 메서드 호출 빈도가 증가하면서 JIT 컴파일 대상이 될 수 있다. 결국 같은 메서드이지만 부하 증가로 인해 처음보다 훨씬 빨리 실행되게 된다.


## 1.5 성능 그래프 읽기
---
> 성능 테스트에서 자주 등장하는 패턴 소개

<br>

### 성능 엘보(performance elbow)
* 부하가 증가하면서 예기치 않게 지연이 발생한 그래프

<img width = "300" alt="스크린샷 2023-07-04 오후 5 28 59" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/2e27520a-07d3-4580-8ad0-b67150fd383c">

<br>

### 준-선형적 확장(near-linear)
* 반면 부하가 증가했을 때 리소스를 추가함에 따라 거의 선형적으로 처리율이 확장되는 모습을 보여준다.

<img width = "300" alt="스크린샷 2023-07-04 오후 5 28 59" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/a9bb3e09-734e-4e57-aec1-b5671ac3039c">

<br>

### 암달의 법칙(Amdahl's law)
* 일반적으로 서버를 추가할 때 **얼마만큼의 속도 향상**이 있을 것인지 등을 체크하기 위해서 활용된다.
* 대규모의 연산이 필요하여 병렬프로그램을 만들어야 한다고 가정할 때, 필연적으로 **절대적인 직렬 시간**이 필요하다.

     예를 들어, 데이터를 읽거나 초기화 작업을 할 수 있다. 이러한 직렬 프로그램은 서버를 확충해도 절대적인 시간을 소비한다.

    <img width="250" alt="스크린샷 2023-07-04 오후 5 29 40" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/441243bd-d2a2-4bb1-b96b-790051d9cf63">

     따라서 CPU 가 1개 -> 2개로 늘린다고 속도가 2배가 되지는 않는다. 
     
     <img width="250" alt="스크린샷 2023-07-04 오후 5 30 44" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/8c9f9f17-e332-4f93-9ea9-7c0d202226d1">

     이와 같이 암달의 법칙은 직렬 프로그램이 어쩔 수 없이 존재하는 한, 아무리 병렬로 컴퓨터 성능을 향상시켜도 성능이 향상되는 한계가 존재한다는 법칙이다.

* 해당 그림에서 프로그램의 95% 를 병렬화 할 수 있으면 병렬 컴퓨팅을 사용한 이론상 최대 속도는 20배가 된다. 아무리 코어를 많이 늘린다 해도 그 이상의 시간 단축은 어렵다.

    <img width="300" alt="스크린샷 2023-07-04 오후 5 28 59" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/c19436e7-fa5a-4a35-ae18-36f4d396ecbe">


참고 : https://needjarvis.tistory.com/522

### 건강한 메모리 사용
* JVM 가비지 수집 서브시스템의 메모리 사용 패턴은 그 하부 기술 때문에 부하가 별로 없는 건강한 애플리케이션도 톱니 모양을 나타낸다. 

<img width = "300" alt="스크린샷 2023-07-04 오후 5 28 59" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/da422a7a-249f-4b7c-a997-8b4beb0ae615">

### 문제가 있는 할당률 분포
* 피보나치 수열을 계산하는 애플리케이션을 실행하여 얻은 그래프
* 90초 분근에서 갑자기 할당률이 떨어지고 있는데, 이 지점에서 애플리케이션에 심각한 가비지 수집 문제가 발생했고, 가비지 수집 스레드들이 서로 CPU 경합을 벌인 탓에 메모리를 충분히 할당받지 못했다.

<img width = "300" alt="스크린샷 2023-07-04 오후 5 28 59" src="https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/98975580/f3744080-7bf3-4133-89c9-18e71a756dc5">