## 13.1 프로파일링 개요

넓은 의미에서 모니터링 툴, 경고 시스템, 프로파일러 개념을 명확히 구분해야 한다.

* 모니터링 툴  : 주로 시스템과 그 현재 상태를 살핀다.
* 경고 시스템 : 비정상적/변칙적인 움직임을 감지한다.
* 프로파일러 : 실행 중인 애플리케이션의 심층 정보를 제공한다.

프로파일링의 목표는 리팩터링 및 성능 최적화 대상 코드를 식별하는 것이다. 성능 문제를 진단하고 바로잡는 첫걸음은 문제를 일으키는 리소스를 찾아내는 것이다.

## 13.2 샘플링과 세이프포인팅 편향

실행 프로파일링에서 스택 트레이스는 대부분 샘플링을 통해 획득한다.

샘플링을 너무 자주하면 오버헤드가 크고, 너무 적게하면 중요한 장면을 놓칠 가능성이 크기 때문에 샘플링 주기는 성능 엔지니어의 갈등을 일으키는 문제이다.

**뉴 렐릭 스레드 프로파일러** 가 100밀리초마다 수행하는 샘플링 주기는 최적 주기로 알려져 있다. 

대부분의 샘플링은 세이프포인트에서만 일어난다는 점이 문제가 된다. 이를 **세이프포인팅 편향** 이고 하며 2가지 문제를 수반한다.

* 모든 스레드는 샘플을 뜨기 전에 세이프포인트에 다다라야하기 때문에 그만큼 오버헤드가 가중된다.
* 세이프포인트 지점에 있는 애플리케이션 상태만 샘플링할 수 있기 때문에 표본점 분포가 왜곡될 소지가 있다.

세이프포인팅 편향이 일으키는 문제는 **카운티드 루프**로도 설명할 수 있다.

```
for (int i=0; i < LIMIT; i++) {
    // 루프 바디에는 '단순' 작업만 있다.
}
```

LIMIT 값이 클 경우, JIT 컴파일러는 자바 코드를 루프 처음으로 되돌리는 백 브랜치를 포함해서 즉시 동등한 컴파일드 코드로 옮길 것이다. JIT 컴파일러는 루프 백 끝부분에 세이프포인트 체크를 삽입하므로, 루프가 커질수록 매 루프마다 세이프포인트를 하게 된다.

LIMIT 값이 작은 경우 세이프포인트를 하지 않고, 대신 JIT 컴파일러가 루프를 펼친다.

따라서 세이프포인트에서만 샘플링하면 루프 크기와 우리가 작성한 코드에 크게 좌우되는 편향된 작동 모습을 보이게 된다. 

## 13.3 개발자용 프로파일링 툴

### 13.3.1 VisualVM 프로파일러

* 실행 프로파일러, 메모리 프로파일러가 모두 들어 있고 사용하기 쉬운 무료 툴이다.
* 기능이 한정적이라 입문용으로 훌륭한 툴이다.

### 13.3.2 JProfiler

* 에이전트에 기반한 유명한 상용 프로파일러
* GUI 모드뿐만 아니라 헤드리스 모드로 로컬 또는 원격 애플리케이션을 프로파일링 할 수 있다.
* 다음 스위치를 실행 설정에 추가해 사용한다.
    ```
    -agentpath:<에이전트 라이브러리 설치 경로>
    ```
    
### 13.3.3 YourKit

* GUI 컴포넌트를 제공하고 에이전트를 동적으로 어태치하거나 애플리케이션 시작 시 설정하는 측면에서 JProfiler와 비슷하다.
* YourKit, JProfiler 둘 다 사용하면 애플리케이션의 다양한 모습을 관찰할 수 있어 진단 시 유용하다.

### 13.3.4 JFR/JMC

* 오라클이 BEA 시스템즈사를 인수하면서 손에 넣은 프로파일링/모니터링 기술
* 자바 8기준으로 JFR/JMC는 오라클 JVM에서만 쓸 수 있는 상용 툴이어서 OpenJDK를 비롯한 다른 JVM에서는 사용하지 못했는데, OpenJDK 11 이후부터는 오픈소스로 내장되었다.

### 13.3.5 운영 툴

* 원래 프로파일러는 개발자가 문제점을 진단하거나 애플리케이션이 런타임에 저수준에서 어떻게 작동하는지 파악하려고 사용하지만, 운영계 모니터링 툴로도 많이 사용된다.

* 레드햇 서모스탯
    * 핫스팟 기반의 JVM 전용 오픈 소스 서비서빌리티/모니터링 솔루션
    * 서모스탯 아키텍처는 확장이 가능해서 다음과 같은 용도로 쓸 수 있다.
        * 유저가 직접 만든 커스텀 지표를 수집, 분석한다.
        * 필요 시 인스트루먼테이션용 커스텀 코드를 주입한다.
        * 커스텀 플러그인을 작성하고 툴링을 통합한다.

* 뉴 렐릭
    * 클라우드 기반 애플리케이션용 SaaS 제품으로 비단 JVM 뿐만 아니라 사용 범위가 넓은 범용 툴 세트이다.
    * 범용 툴인 까닭에 JVM 기술만 특별히 초점을 두지 않는다.

* jClarity 일루미네이트
    * 기존 샘플링 프로파일러와는 다르며, 메인 자바 애플리케이션을 관찰하는 별도의 외부 데몬 프로세스를 이용한 모니터링 모드로 작동한다.
    * 일루미네이트의 머신 러닝 알고리즘은 OS, GC로그, JVM에서 긁어모은 데이터를 분석해서 성능 문제를 야기한 근본 원인을 밝힌다. 그리고 상세 보고서를 작성해 유저에게 알리고 문제 해결에 필요한 다음 조치 방안을 제시한다.

## 13.4 최신 프로파일러

### 어니스트 프로파일러

다음의 2가지를 목표를 가진다. 

* 다른 대부분의 프로파일러에 있는 세이프포인트 편향을 없앤다.
* 오버헤드가 아주 낮은 상태로 작동시킨다.

어니스트 프로파일러는 핫스팟 내부의 **AsyncGetCallTrace**라는 프라이빗 API를 활용한다. 스레드만 따로 인터럽트하므로 전역 동기화 이벤트 따위는 없다. 따라서 과거 프로파일러에서 고질적이었던 경합과 오버헤드 현상은 거의 나타나지 않는다.

실무에서 어니스트 프로파일러 같은 툴은 보통 헤드리스 모드로 실행시켜 데이터 수집 용도로 쓰고 시각화는 다른 툴을 쓰거나 커스텀 스크립트로 제공한다.

### perf

* 리눅스 애플리케이션의 경량급 프로파일링 툴
* 특정 자바/JVM 애플리케이션에 구애받지 않으며, 하드웨어 성능 카운터를 읽는다.
* 리눅스 커널 tools/perf에 포함되어 있다.

### Async 프로파일러

* 어니스트 프로파일러를 대체할만한 툴이다.
* 어니스트 프로파일러와 같은 내부 API를 쓰며 핫스팟 JVM에서만 실행 가능한 오픈 소스 툴이다.
* perf에 전적으로 의존하는 툴이어서 perf를 실행할 수 있는 OS에서만 주로 작동한다.

## 13.5 할당 프로파일링

대부분의 애플리케이션은 일정 수준의 메모리 프로파일링도 병행해야 한다. 할당 프로파일링은 애플리케이션의 할당 동작을 살피는 표준 메모리 프로파일링이다.

JVM에서 메모리 할당을 지시하는 바이트코드는 NEW, NEWARRAY, ANEWARRAY 3가지이다.
할당을 일으키는 옵코드는 이 셋뿐이라 인스트루먼테이션할 바이트코드도 이들뿐이다.

가장 단순한 인스트루먼테이션은 할당 옵코드를 지닌 인스턴스를 하나하나 찾아내 실제 할당 옵코드가 실행되기 직접에 로깅하는 정적 메서드 호출부를 삽입하는 것이다.

TLAB를 이용해 할당 프로파일링하는 방법도 있다. Async 프로파일러는 핫스팟 전용 콜백을 이용해 다음 시점에 알림을 수신하는 TLAB 샘플링 기능을 지원한다.

* 새로 만든 TLAB에 객체가 할당될 때
* TLAB 밖에 객체가 할당될 때

객체 할당을 일일이 전부 다 세지 않고, 매 n 킬로바이트 단위로 뭉뚱그려 할당을 기록한다.

## 13.6 힙 덤프 분석

힙 덤프 분석은 전체 힙의 스냅샷을 툴로 자세히 뜯어보면서 어떤 객체가 살아 있는지, 그 개수와 타입은 어떤지 등의 중요한 팩트와 객체 그래프 형상/구조를 파악하는 일이다.

힙 덤프는 크기가 문제이다. 덤프한 메모리 크기의 300~400% 에 달하는 경우도 흔하다.

힙 파일 생성은 힙을 샅샅이 뒤져 덤프 파일을 쓰는 과정이므로 STW 이벤트도 불가피하다.

### 13.6.1 hprof

JDK 5부터 내장된 hprof 프로파일러는 제품급 프로파일러라기보다는 처음부터 JVMTI 기술의 기준 구현체로 의도한 툴이다. 자바 9 이루노느 JDK에서 사라졌다.