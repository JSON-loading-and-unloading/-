<h1>가비지 수집 기초</h1>

자바 가비지 수집의 요체 : 시스템에 있는 모든 객체의 수명을 정확히 몰라고 런타임이 대신 객체를 추적하며 쓸모없는 객체를 알아서 제거하는 것.</br>
가비지 수집 구현체 기본 원칙!
 - 알고리즘은 반드시 모든 가비지를 수집해야 한다.
 - 살아 있는 객체는 절대로 수집해선 안 된다.

   => 두 번째 원칙에서 살아 있는 객체를 수집했다간 세그먼테이션 결함이 발생하거나 데이터가 더럽혀진다.

   <h3>마크 앤 스위프</h3>

   마크 앤 스위프는 표시하고 쓸어 담기

   GC 전체 알고리즘
    1. 할당 리스트를 순회하며 마크 비트를 지운다.
    2. GC 루트부터 살아 있는 객체를 찾는다.( 깊이-우선 방식)
    3. 이렇게 찾은 객체마다 마크 비트를 세팅한다.
    4. 할당 리스트를 순회 하면서 마크 비트가 세팅되지 않는 객체를 찾는다.
        - 힙에서 메모리를 회수해 프리 리스트에 되돌린다.  => 왜?
        - 할당 리스트에서 객체를 삭제한다.

   <h3>가비지 수집 용어</h3>
     <h4>STW</h4>
     GC사이클이 발생하여 가비지를 수집하는 동안에는 모든 애플리케이션 스레드가 중단된다.
     <h4>동시</h4>
     GC스레드는 애플리케ㅔ이션 스레드와 동시 실행될 수 있다.
     <h4>병렬</h4>
     여러 스레드를 동원해서 가비지 수집을 한다.
     <h4>정확</h4>
     GC스킴은 전체 가비지를 한벙에ㅔ 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 지니고 있다.     
     <h4>보수</h4>
     보수적인 스킴은 정확한 스킴의 정보가 없다. ( 리소르를 낭비하는 일이 잦고 근본적으로 타입 체계를 무시하기 때문에 비효율적이다.
     <h4>이동</h4>
     이동 수집기에서 객체는 메모리를 여기저기 오갈 수 있다.
     <h4>압착</h4>
     할당된 메모리는 GC사이클 마지막에ㅔ 연속된 단일 영역으로 배열되며, 객체 쓰기가 가능한 여백의 시작점을 가리키는 포인터가 있다.(압착 수집기는 메모리 단편화를 방지한다.)
     <h4>방출</h4>
     수집 사이클 마지막에ㅔ 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 이동한다.

     
      <h3>핫스팟 런타임 개요</h3>
      자바는 c++과 달리 주소를 역참조하는 일반적인 메커니즘이 없고 오직 오프셋 연산자만으로 필드에 엑세스하거나 객체 레퍼런스의 메소드를 호출할 수 있다.</br>

   핫스팟은 런타임에 oop라는 구조체로 자바 객체를 나타낸다.</br>
   instanceOop : 자바 클래스의 인스턴스</br>
   메모리 레이아웃이 Mark워드(인스턴스 관련 메타데이터를 가리키는 포인터), Klass워드(클래스 메타데이터를 가리키는 포인터)가 나온다.</br>
   자바 8부터는 Klass가 자바 힙 주 영역 밖으로 빠지게 된다. => 자바는 Klass워드가 자바 힙 밖을 가리키므로 객체 헤더가 필요없다.</br>
   https://eminentstar.tistory.com/72</br>

   핫스팟은 조금이라도 메모리를 절약할 수 있게 압축oop라는 기법을 제공한다.</br>
   oop압축 내용</br>
   - 힙에 있는 모든 객체의 Klass워드
   - 참조형 인스턴스 필드
   - 객체 배열의 각 원소
   핫스팟 객체 헤더 구성</br>
    - Mark워드
    - Klass워드
    - 객체가 배열이면 length워드
    - 32비트 여백
  
 
      <h3>GC 루트 및 아레나</h3>

      GC 루트는 메모리의 고정점으로, 메모리 풀 외부에서 내부를 가리키는 포인터이다.(외부 포인터)</br>
      GC루트 종류</br>
      - 스택 프레임
      - JNI
      - 레지스터
      - 코드 루트
      - 전역객체
      - 로드된 클래스의 메타데이터
     
        ※핫스팟 GC는 아레나라는 메모리 영역에서 작동한다.</br>
        ※핫스팟은 자바 힙을 관리할 때 시스템 콜을 하지 않습니다.</br>
   
   <h2>할당과 수명</h2>
   가비지 수집이 일어나는 주된 원인</br>
    - 할당률
    - 객체 수명
=> 객체가 생성된 후 잠시 존재하고 그 상태를 보관하는데 사용한 메모리를 다시 회수한다는 발상이 핵심</br>
    할당률 : 일정기간 새로 생성된 객체가 사용한 메모리량이다.</br>

  
      <h3>약한 세대별 가설</h3>
       약한 세대별 가설은 소프트웨어 시스템의 런타임 작용을 관찰한 결과 알게 된 경험 지식으로, JVM 메모리 관리의 이론적 근간을 형성</br>
       => 가비지를 수집하는 힙은, 단명 객체를 쉽고 빠르게 수집할 수 있게 설계해야 하며, 장수 객체와 단명 객체를 완전히 떼어놓는 게 가장 좋다.</br>
</br>
       핫스팟이 응용한 약한 세대별 가설</br>
       - 객체마다 '세대 카운트'를 센다
       - 큰 객체를 제외한 나머지 객체는 에덴 공간에 생성한다. 여기서 살아남은 객체는 다른 곳을 옮긴다.
       - 장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역에 보관한다.
       
![KakaoTalk_20230806_214524915](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/9461830a-b1fe-4adf-8dee-2ff7d4c3f75d)

=> 세대별 수집 목적에 따라 메모리를 상이한 영역으로 나누면 핫스팟의 마크 앤 스위프 수집의 구현에 따라서 그 결과가 더 세분화된다.</br>
※외우에서 영세대 내부를 가리키는 포인터를 계속 추적하는 기법</br></br>
🧨약한 세대별 가설 두 번째 포인트 : 늙은 객체가 젊은 객체를 참조할 일은 거의 없다.</br>
핫스팟은 카드 테이블이라는 자료 구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록</br></br>
핵심 로직 </br>
  1. 늙은 객체 0에 있는 참조형 필드값이 바뀌면 0에 해당하는 instanceOop가 들어 있는 카드를 찾아 해당 엔트리를 더티 마킹한다.
  2. 핫스팟은 레퍼런스 필드를 업데이트할 때마다 단순 쓰기 베리어를 이용한다.

       
       
   
      
   
      
   
