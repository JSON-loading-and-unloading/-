<h1>GC 로깅, 모니터링, 튜닝, 툴</h1><br>

<h2>GC 로깅 개요</h2>

모든 중요한 애플리케이션에서 설정해야할 두 가지!!<br>
1. GC로그를 생성
2. 애플리케이션 출력과는 별도로 특정 파일에 GC로그를 보관한다.
   =>GC로깅은 오버헤드가 거의 없는 것으므로 항상 로깅을 켜놓는다.<br>


![KakaoTalk_20230819_150717023](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/799ce70e-6857-4454-a1ca-3d16ac49c417)


   

<h4>GC 로깅 켜기</h4>
   플래그 주의사항<br>
   - 기존 플래그 verbose:gc는 지우고 대신 printGCDetails를 사용한다.<br>
   - PrintTenuringDistributiondms 다소 독특한 플래그로, 이 플래그가 제공하는 정보를 사람이 이용하기는 어렵다. 중요한 메모리압 효과, 조기 승격 등의 이벤트 계산 시 필요한 기초 데이터를 제공한다.
   - PrintGCDateStamps와 PrintGCTimeStamps는 둘 다 필요하다. 전자는 GC 이벤트와 애플리케이션 이벤트를, 후자는 GC와 다른 내부 JVM 이벤트를 각각 연관짓는 용도로 쓰인다.

![KakaoTalk_20230819_150717023_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/cf436a93-0126-45d5-9401-af64a7ab9cab)


로그 순환 정책은 운영팀과 협의해서 합리적으로 수립해야 한다.


<h4>GC 로그 vs JMX</h4>

- GC 로그 데이터는 실제 가비지 수집 이벤트가 발생해 쌓이지만, JMX는 데이터를 샘플링하여 얻는다.
- GC 로그 데이터는 캡쳐 영향도가 거의 없으나, JMX는 프록시 및 원격 메소드 호출(Remote Method Invocation) 과정에서 비용이 발생한다.
- GC 로그 데이터는 자바 메모리 관리에 연관된 성능 데이터가 50가지 이상이지만, JMX는 10가지도 안된다.
- JMX는 스트리밍된 데이터를 즉시 제공하지만 위와 같은 이유에서 GC 로그가 성능 관점에서 조금 더 좋아보일 수 있다. 추가로 요즘은 jClarity 센섬같은 툴도 GC 로그 데이터를 스트리밍하는 API를 제공하므로 큰 차이는 없다.

- <h4>JMX의 단점</h4>

- JMX를 이용해 애플리케이션을 모니터링하는 클라이언트는 대부분 런타임을 샘플링해 현재 상태를 업데이트 한다. 클라이언트는 데이터를 계속 넘겨받기 위해 런타임에있는 JMX 빈을 폴링한다. 문제는 GC가 언제 실행될지 클라이언트는 알 수 없으므로, GC 전후의 메모리 상태 역시 알 수 없으며 따라서 GC 데이터를 깊이있게 정확히 분석하기 힘들다.
- JMXConnector를 구현한 코드는 내부적으로 RMI에 의존하는데, RMI기반 통신은 방화벽에 포트를 열어야하므로 secondary socket connection이 발생하며, 프록시 객체를 이용해 remove() 메소드 호출을 대행하고 Java finalization에 의존한다는 고질적인 문제점이 존재한다. 
- 접속을 해제하는 작업은 finalize에 의존하는데 이는 GC를 돌려 객체를 회수해야하므로 종료화가 GC에 미치는 영향을 고려하지 않을 수 없다.
- RMI를 사용하는 애플리케이션은 기본 1시간에 한번씩 full GC가 발생하는데, JMX를 사용하는 순간부터 추가적인 부하는 피할수 없을 것이다.
<br>
RMI : 분산되어 존재하는 객체 간의 메시지 전송(메소드를 호출하는 것 포함)을 가능하게 하는 프로토콜.<br>
JMS : Java EE 를 기반으로 하는 애플리케이션 컴포넌트가 메시지를 작성, 전송, 수신 및 읽을 수 있도록 하는 API.<br>


<h2>로그 파싱 툴</h2>

<h3>센섬</h3>

- jClarity사가 제작한 상용 메모리 분석기이다.
- 데스크톱 툴로 써도 되고 서비스 모니터링 용도로도 사용할 수 있다.
- 센섬은 최고의 GC 로그 파싱, 정보 추출, 자동 분석 기능을 제공하는 것이 목표이다.

  센섬 최신 버전이 지원하는 자동 분석 기능<br>
  - 정확한 할당률
  - 조기 승격
  - 공격적인 할당
  - 유저 이탈
  - 메모리 누수 감지
  - 힙 크기 조정 및 용량 계획
  - vm에 대한 os 간섭
  - 크기를 잘못 잡은 메모리 풀

<h3>GCViewer</h3>

- GCViewer는 GC 로그 파싱 및 그래프 출력 등 기본 기능을 갖춘 데스크톱 툴이다.
- GCViewer는 분석 기능은 없고 특정 GC 핫스팟 로그 포맷만 파싱할 수 있다.
- GCViewer를 파싱 라이브러리로 쓰고 결과 데이터를 시각화 툴로 내보내는 방법도 있지만, 기존 오픈 소스 코드 베이스에 추가 개발을 해야 하는 부담이 있다.

<h2>GC 기본 튜닝</h2>

1. GC가 성능 문제를 일으키는 근원이라고 확인하거나 그렇지 않다고 배제하는 행위는 저렴하다.
2. UAT에서 GC플래그를 켜는 것도 저렴한 행위이다.
3. 메모리 프로파일러, 실행 프로파일러를 설정하는 작업은 결코 저렴하지 않다.

  
![KakaoTalk_20230820_145143428_02 (1)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/a776a5d0-065b-4315-8882-e4196dc54bf2)



튜닝을 수행하며 관찰/측정 해야할 주요 인자<br>
- 할당
- 중단 민감도
- 처리율 추이
- 객체 수명

<br>

  튜닝 시 GC 플래그 추가 방법<br>
  - 한번에 한 플래그씩 추가한다.
  - 각 플래그가 무슨 작용을 하는지 숙지해야 한다.
  - 부수 효과를 일으키는 플래그 조합도 있음을 명심한다.

  성능이 떨어졌을 시 확인해야할 것<br>
  1. CPU 사용률이 100%에 가까운가?
  2. 대부분의 시간이 유저 공간에서 소비되는가?
  3. GC로그가 쌓이고 있다면 현재 GC가 실행 중이라는 증가다.
 
     <br>

<h3>할당이란</h3>
     
가비지 수집기를 튜닝하면 성능이 개선될지 여부를 판단하는데 꼭 필요한 과정<br>

필자의 경험ㅎ : 할당량의 수치가 1GB/s 이상으로 일정 시간 지속된다면 십중팔구 가비지 수집기 튜닝만으로는 해결할 수 없는 성능 문제가 터진거다.<br>
=> 성능을 향상시키려면 애플리케이션 핵심부의 할당 로직을 제거하는 리팩터링을 수행하여 메모리 효율을 개선하는 방법밖에 없다.<br>

초기 할당 전략은 네 가지 단순 영역에 집중하는 것이 좋다.<br>
- 굳이 없어도 그만인, 사소한 객체 할당
- 박싱 비용
- 도메인 객체
- 엄청나게 많은 논JDK 프레임워크 객체


  도메인 객체에는<br>
  - char[]
  - byte[]
  - double[]
  - 맵 엔트리
  - Objext[]
  - 내부자료구조


  스레드 로컬 할당 기법<br>
=> 여유 공간이 없으면 스레드는 vm에게 새 TLAB을 달라고 요청한 다음 재시도한다.<br>
=> 객체가 너무 뚱뚱해서 빈 TLAB에 안들어가면 vm은 TLAB 외부 영역에 위치한 에덴에 직접 객체를 할당 시도한다.<br>
=> 위도 실패 시 영 GC를 수행하는 다음 단계로 넘어감.<br>
=> 위 경우도 공간이 부족하면 테뉴어드 영역에 객체르 직접 할당한다.<br><br>

핫스팟은 TLAB 및 큰 객체의 조기 승격에 관한 튜닝 플래그를 제공<br>

![KakaoTalk_20230820_145143428_01 (1)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/2a32493a-1e27-4c13-baf8-5ed5a5657084)


할당률은 테뉴어드로 승격되는 객체 수에 영향을 끼친다.<br>
=> 단명 자바 객체의 수명이 불변이라고 가정하면 할당률이 높을수록 영 GC발생 주기는 짧아진다.<br>
=> 너무 자주 수집이 일어나면 단명 객체는 장례를 치를 시간도 없이 테뉴어드로 잘못 승격될 가능성이 크다.<br>


![KakaoTalk_20230820_145143428](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/35e6aa87-b777-4d07-921a-7683096e0037)


<br>
테뉴어드 영역으로 승격되기 전까지 객체가 통과해야할 가비지 수집 횟수를 설정하는 플래그<br>
디폴트 4회, 1 ~ 15 사이의 한계치를 설정<br>

<h3>수집기 스레드와 GC 루트</h3>

GC루트 탐색 시간에 영향을 주는 요인<br>
- 애플리케이션 스레드 개수
- 코드 캐시에 쌓인 컴파일드 코드량
- 힙 크기
=> 탐색은 단일 스레드로 수행하므로 작업 훔쳐오기는 불가능하다. 따라서 극단적으로는 이 단일 스레드의 탐색 시간이 전체 마킹 시간을 결정짓게 된다.<br>
=> 애플리케이션 스레드가 너무 많아도 스택 프레임을 더 많이 탐색해야 하고 세이프포인트에 도달하는 시간도 길어지는 등 GC 시간에 영향을 끼친다.<br>
 
<h2>Parallel GC</h2>

수집기의 목표와 트레이드오프<br>

- 풀 STW
- GC 처리율이 높고 계산 비용이 싸다.
- 부분 수집이 일어날 가능성은 없다.
- 중단 시간은 힙 크기에 비례하여 늘어난다.


<h2>CMS 튜닝</h2>

CMS 성능 개선 <br>

CMF 발생 직전의 수집기 상태를 살펴본다.<br>
백투백 수집 현상은 동시 수집기가 얼마 못 가 고장날 거라는 신호이다.<br>
=> 애플리케이션의 메모리 할당 속도가 회수 속도를 능가하면서 결국 CMF가 일어난다.<br>

백투백 현상으로 인해 실행 처리율이 50% 떨어진다.<br>
1. 호스트에 코어 수를 늘리는 해결 방안을 모색한다.<br>
2. CMS 수집 중 GC에 할당된 코어 수를 줄인다.<br>

할당률에 따른 설정 플래그<br>

![KakaoTalk_20230821_203440224](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/6d666e1c-c82b-4d26-9254-1830c9ff09d3)<br>


전자는  CMS가 언제 수집을 시작할지 설정하는 플래그이다.<br>
=> cms가 실행되면 영 수집을 통해 올드 영역으로 승격되는 객체들을 수용할 여유 공간이 필요하다.<br>
(디폴트는 cms 풀 gc는 힙이 75% 찼을 때 시작)<br>

후자와 함께 플래그를 설정하면 초기 점유 공간을 동적 크기 조정하는 기능이 꺼짐(조심!)<br>

할당률이 심하게 튀는 cms애플리케이션이라면 여유 공간을 늘리고 능동적 크기 조정기능을 끄는 전략을 구사!<br>




<h2>G1 튜닝</h2>

G1 튜닝의 최종 목표는 엔드 유저가 최대 힙 크기와 최대 GC 중단 시간을 간단히 설정하면 나머지는 수집기가 알아서 처리하는 것이다.<br>
-XX:+UnlockExperimentalVMOptions 플래그 : Java Virtual Machine(JVM)의 실험적인 옵션을 활성화하기 위해 사용되는 옵션 중 하나입니다. 이 옵션을 활성화하면 JVM에서 실험적인 기능 및 설정을 사용할 수 있게 됩니다. <br>

위 플래그를 설정해야 <br>
-XX:+G1NewSizePercent=<n>,  -XX:G1MaxNewSizePercent=<n>를 설정할 수 있음.<br>

-XX:+G1NewSizePercent:<br>

이 옵션은 Young 세대의 초기 크기를 지정하는 데 사용됩니다.<br>
<n>에는 0부터 100까지의 값을 지정할 수 있으며, 이 값은 전체 힙 크기의 퍼센트를 나타냅니다. 예를 들어, -XX:+G1NewSizePercent=30을 설정하면 Young 세대가 전체 힙 크기의 30%로 초기화됩니다.<br>
이 값을 조정하여 Young 세대의 초기 크기를 설정할 수 있으며, 애플리케이션의 메모리 요구에 따라 조절할 수 있습니다.<br>
-XX:G1MaxNewSizePercent:<br>

이 옵션은 Young 세대의 최대 크기를 지정하는 데 사용됩니다.<br>
<n>에는 0부터 100까지의 값을 지정할 수 있으며, 이 값은 전체 힙 크기의 퍼센트를 나타냅니다. 예를 들어, -XX:G1MaxNewSizePercent=50을 설정하면 Young 세대가 전체 힙 크기의 50%를 초과하지 않도록 유지됩니다.<br>

G1에서 어떤 애플리케이션에서 할당률이 계속 높은 상태로 대부분 단명 객체가 생성되고 있다면 고려해볼 것들<br>
1. 영 세대를 크게 설정
2. 테뉴어드 한계치를 최대 15 정도로 늘려 잡는다.
3. 애플리케이션에서 수용 가능한 최장 중단 시간 목표를 정한다.



   


   



