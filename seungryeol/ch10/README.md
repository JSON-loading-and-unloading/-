<h2>JITWatch</h2>
오픈 소스 자바FX 툴</br>
JITWatch가 하는 일은, 실행 중인 자바 애플리케이션이 생성한 핫스팟 컴파일 상세 로그를 파싱/분석하여 그 결과를 자바FX GUI 형태로 보여주는 것이다.</br>

```
-XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading -XX:+LogCompppliation
```
사용 시 켜야할 스위치
</br>
JITWatch는 실행시킨 프로그램에서 로그를 적재하는 일뿐만 아니라, jit작동을 시험해볼 수 있는 샌드박스라는 환경을 제공한다.</br>
샌드박스를 이용하면 작은 프로그램을 신속히 프로토타이핑하여 jvm이 어떤 jit결정을 내렸는지 확인할 수 있다.</br>

또한, 샌드박스 워크플로를 이용하면 로그파일 대신, 자바/jvm을 지원하는 언어로 작성된 프로그램을 생성하거나 로드할 수 있다.
또한, 샌드박스는 jit 서브 시스템을 조정하는 vm 스위치를 시험해볼 수 있는 환경을 제공한다.
예를 들어, 샌드박스 설정 값으로 JVM JIT 로직을 다음과 같이 변경할 수 있다.
   - 역어셈블된 네이티브 메서드를 출력하고 어셈블리 구문을 선택한다.
   - jvm에서 단계별 컴파일에 맞게 설정된 디폴트를 오버라이드한다.
   - 압축 oop 사용을 오버라이드한다.
   - OSP을 해제한다.
   - 인라이닝 디폴트 한계치를 오버라이드한다.

샌드박스가 일반 jvm 애플리케이션 실행과 다른 점은, 풀 사이즈 애플리케이션에서 jvm이 단지 샌드박스 한 조각이 아닌, 훨씬 광범위한 코드를 대상으로 최적화를 조합할 수 있다는 것이다.
=> jit 컴파일러는 단순 인라이닝만 수행하는 샌드박스에서 실행한 토이 애플리케ㅔ이션과, 진짜 인라이닝을 수행하는 실제 애플리케이션에 있는 메서드를 전혀 다르게 취급한다.
=> JITWatch는 3단뷰라는 다재다능한 뷰를 메인으로 제공한다.


자바9부터는 분할 코드 캐시가 새로 생겨서 네이티브 코드 유형마다 별도의 영역에 저장할 수 있다.
덕분에 단편화 및 스위퍼 시간을 단축하고 풀 컴파일드 코드의 지역성을 높일 수 있게됐다.

<h2>JIT 컴파일 개요</h2>

핫스팟은 프로파일 기반 최적화(PGO)를 이용해 JIT 컴파일 여부를 판단한다.</br>
내부적으로는 핫스팟 실행 프로그램 정보를 메서드 데이터 객체(MDO)라는 구조체에 저장한다.</br>
MDO의 역할 : 바이트 코드 인터프리터와 c1 컴파일러에서 jit 컴파일러가 언제, 무슨 최적화를 할지 결정하는 데 필요한 정보를 기록하는 것이다.</br>
(어떤 메서드가 호출됐고, 어느 분기문으로 갈라졌는지, 또 호출부에서는 무슨 타입이었는지 등의 정보가 담겨있다.)</br>

컴파일의 시작</br>
1. 프로파일링된 프로퍼티의 '사용 빈도'를 카운터에 계속 기록하고 그렇게 기록한 값들은 프로파일링을 거치면서 차츰 사라진다. 이로 컴파일 큐 맨 앞에 이르렀을 때도 아직 핫한 메서드만 컴파일된다.
2. 프로파일링 데이터가 모이고 컴파일 결정을 내린 후에ㅔ 컴파일러별 세부 처리 절차로 넘어간다.
3. 컴파일러는 컴파일할 코드의 내부 표현형을 빌드한다.
4. 컴파일러는 이 내부 표현형을 토대로 코드를 컴파일한다.
   핫스팟 jit 컴파일러는 다양한 최신 컴파일 최적화 기법을 총 동원</br>
    - 인라이닝
    - 루프 펼치기
    - 탈출 분석
    - 락 생략/확장
    - 단일형 디스패치
    - 인트린직
    - 온-스택 치환
5. 컴파일 c1은 추측성 최적화를 안한다. 따라서 실행 성격이 어떨지 확실하지 않은 가정하에 최적화를 하지 않는다.
6. c2는 런타임 실행을 주시한 결과를 토대로 추정을 하고 그에 따른 최적화를 수행


   실제로 돌려보면 미리 추정한 것과 엉뚱하게ㅔ 츨러가 무용지물되는 경우도 있다.</br>
   => 추측성을 최적화를 하기 전에 항상 가드라는 타당성 검사를 함.</br>
   가드는 앞서 추정한 내용이 여전히 유효한지 최적화된 코드를 실행할 때마다 확인한다.</br></br>

가드마저 실패하면 더 이상 컴파일드 코드는 안전하지 않으므로 제거한다.</br>
※핫스팟은 혹여 부정확한 코드가 실행되는 불상사를 막기 위해 즉시 해당 메ㅔ서드를 인터프리티드 모드로 강등시켜 역최적화한다.</br>



<h2>인라이닝</h2>
인라이닝은 호출된 메서드의 콘텐츠를 호출한 지점에 복사하는 것이다.</br>
이로 메서드 호출 시 다음과 같은 오버헤드를 제거할 수 있다.</br>
 - 전달할 매개변수 세팅
 - 호출할 메서드를 정확하게 룩업
 - 새 호출 프레임에 맞는 런타임 자료 구조 생성
 - 새 메서드로 제어권 이송
 - 호출부에 결과 반환

인라이닝은 JIT 컴파일러가 제일 먼저 적용하는 최적화라서 관문 최적화라고도 한다.</br>
```
 int reulst = add(a,b);

private int add(int x, int y){
  return x+y;
}

int result = a + b;
```
인라이닝 최적화 덕분에 재사용 가능한 코드를 작성할 수 있고, 무엇보다 손수 마이크로 최적화를 할 필요가 없어 좋다.</br>
※핫스팟은 자동으로 통계치를 분석해서 관련된 코드를 어느 시점에 하나로 모을지 결정한다.</br>
=> 인라이닝은 다른 최적화의 범위를 확장시키는 역할을 한다.</br>
 - 탈출 분석
 - DCE
 - 루프 펼치기
 - 락 생략


<h5>인라이닝 제한</h5>

VM 차원에서 인라이닝 서브시스템에 제한을 걸어야 할 경우도 있다.</br>
 - JIT 컴파일러가 메서드를 최적화하는 데 소비하는 시간
 - 생성된 네이티브 코드 크기

   => 제약 조건이 하나도 없으면 컴파일러는 아주 깊은 호출 체인까지 파헤치며 인라이닝할 것이다.</br>

   핫스팟은 다음 항목을 따져보며 어떤 메서드를 인라이닝할지 결정한다.</br>
    - 인라이닝할 메서드의 바이트코드 크기
    - 현재 호출 체인에서 인라이닝할 메서드의 깊이
    - 메서드를 컴파일한 버전이 코드 캐시에서 차지하는 공간

<h5>인라이닝 서브시스템 튜닝</h5>


![KakaoTalk_20230905_114959414](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/2a228681-54af-47aa-b0c2-b12c48875aec)

-XX:MaxInlineSize나 -XX:FreqInlineSize 값을 바꿔보면서 성능이조금이라도 나아지는지 확인</br>
=> 이렇게 매개변수를 바꿔가며 튜닝할 때에는 반드시 측정 데이터를 근거로 삼아야한다.</br>

<h2>루프 펼치기</h2>

루프 내부의 메서드 호출을 전부 인라이닝하면, 컴파일러는 루프를 한번 순회할 때마다 비용이 얼마나 드는지, 반복 실행되는 코드는 크기가 얼마나 되는지 더 분명해진다.</br>
이 정보를 토대로 컴파일러는 매번 순회할 때마다 루프 처음으로 되돌아가는 횟수를 줄이기 위해 루프를 펼칠 수 있다.</br>

백 브랜치가 일어나면 그때마다 cpu는 유입된 명령어 파이프라인을 덤프하기 때문에 성능상 바람직하지 않는다.</br>

백 브랜치 비용은 상대적으로 높다.</br>
 - 루프 카운터 변수 유형(대부분 객체 아닌 int나 long형을 사용)
 - 루프보폭(한 번 순회할 때마다 루프 카운터 값이 얼마나 바뀌는가)
 - 루프 내부의 탈출 지점 개수(return, break)


루프를 돌며 배열 원소에 액세스할 때 핫스팟은 루프를 세 구역으로 나누어 배열 경계 검사를 제거</br>


![KakaoTalk_20230905_114959414_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/efb3c16b-8c10-48f4-93c6-d820c3d890b8)


<h5>루프 펼치기 정리</h5>

핫스팟은 다양한 최적화 기법으로 루프 펼치기를 한다.</br>
 - 카운터가 int, short, char형일 경우 루프를 최적화한다.
 - 루프 바디를 펼치고 세이프 포인트 폴을 제거한다.
 - 루프 펼치면 백 브랜치 횟수가 줄고 그만큼 분기 예측 비용도 덜 든다.
 - 세이프포인트 폴을 제거하면 루프를 순회할 때마다 하는 일이 줄어든다.


<h2>탈출 분석</h2>

탈출 분석 :  핫스팟은 어떤 메서드가 내부에서 수행한 작업을 그 메서드 경계 밖에서도 볼 수 있는지, 또는 부수 효과를 유발하는지는 않는지 범위 기간 분석을 통해 판별한다.</br>
=> 메서드 내부에서 할당된 객체를 메서드 범위 밖에서 바라볼 수 있는지를 알아보는 용도로 쓰인다.</br>
※탈출 분석 최적화는 반드시 인라이닝을 수행한 이후 시도한다. 인라이닝을 해서 피호출부 메서드 바디를 호출부에 복사하면 호출부에 메서드 인수로 전달된 객체는 더 이상 탈출 객체로 표시되지 않기 때문
</br>
핫스팟은 탈출 분석 단계 도중, 잠재적으로 탈출한 객체를 세 가지 유형으로 분류</br>

1. NoEscape : 객체가 메서드/스레드를 탈출하지 않고 호출 인수로 전달되지 않으며, 스칼라로 대체 가능
2. ArgEscape : 객체가 메서드/스레드를 탈출하지 않지만 호출 인수로 전달되거나 레퍼런스로 참조되며, 호출 도중에는 탈출하지 않는다.
3. GlobalEscape : 객체가 메서드/스레드를 탈출


<h5>힙 할당 제거</h5>

핫스팟의 탈출 분석 최적화는 개발자가 객체 할당률을 신경 쓰지 않고도 자바 코드를 자연스레 작성할 수 있도록 설계됐다.</br>
=> 할당된 객체가 메서드를 탈출하지 않는다는 사실을 밝히면(NOEscape) VM 스칼라치환이라는 최적화를 적용해 객체 필드를 마치 처음부터 객체 필드가 아닌 지역 변수였던 것처럼 스칼라 값으로 바꿈
그 다음 레지스터 할당기라는 핫스팟 검포넌트에 의해 cpu 레지스터 속으로 배치된다.</br>

![KakaoTalk_20230905_114959414_02](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/d0502df6-ba84-4b0f-a432-cfe203dacf79)




탈출분석 직전, extBar()이 루프 바디 안으로 인라이닝되면 MyObj은 NoEscape으로 닷 ㅣ 분류되어 힙 할당을 막을 수 있다.</br>

주로 인라이닝과 탈출분석은 JIT 컴파일 c2부분에서 이뤄진다.

<h5>락과 탈출 분석</h5>

핫스팟은 탈출 분석 및 관련 기법을 통해 락 성능도 최적화한다.</br>

 - 비탈출객체에 있는 락은 제거한다.(락 생략)
 - 같은 락을 공유한, 락이 걸린 연속된 영역은 병합한다.(락 확장)
 - 락을 해제하지 않고 같은 락을 반복 획득한 블록을 찾아낸다.(중첩 락)

   핫스팟은 동일한 객체에 연속적으로 락이 걸려 있을 경우, 락이 걸린 영역을 넓힐 수 있는지 체크한다.</br>
   => 핫스팟은 락을 발견하면 반대 방향으로 거슬러 올라가 동일한 객체에 언락이 있는지 찾아보고, 만약 언락이 발견되면 두 락 영역을 더 큰 단일 영역으로 합할 수 있는지 살핀다.</br>


   락 확장 최적화는 기본 활성화되어 있지만, VM 스위치 -XX:-EliminateLocks로 해제하여 영향도를 확인할 수 있다.</br>

   또 핫스팟은 같은 객체에 걸린 중첩 락을 감지해 해당 스레드가 이미 그 락을 획득한 상태라면 내부 락을 제거한다.</br>

   중첩 락 최적화도 기본 활성돼있지만, VM 스위치 -XX:-EliminateNestedLocks로 끌 수 있다.</br>
   
<h5>탈출 분석의 한계</h5>

기본적으로 원소가 64개 이상인 배열은 핫스팟에서 탈출 분석의 혜택을 볼 수 없다.</br>
=> -XX:EliminateAllocationArraySizeLimit=<n></br>

배열이 메서드 범위를 탈출하지 않으면 탈출 분석을 해서 힙 할당을 막을 수 있지만, 배열 길이가 64를 초과하면 무조건 힙에 저장되고 이 코드의 할당률은 빠르게 상승할 수 있다.</br>
![KakaoTalk_20230907_102149780](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/5c937707-3088-4f46-aeac-43eb3ecdb762)

이미지에서 64를 넘으면 성능이 쭉 떨어진다.</br>
이로 VM에게 더 큰 배열도 최적화하도록 지시한다.</br>

※핫스팟이 부분 탈출 분석을 지원하지 않는다.</br>
객체가 어느 분기에서건 메서드 범위를 탈출하면 힙에 객체를 할당하지 않는 최적화는 적용되지 않는다.</br>

![KakaoTalk_20230907_103323938](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/f1d3ca0e-0030-459d-bbf0-24195c151fc4)

위 사진을 보면 아래 코드처럼 메서드 범위를 탈출 않하므로 탈출 분석의 덕을 볼 수 있다.</br>
