<h1>자바 언어의 성능 향상</h1>

<h2>컬렉션 최적화</h2>

- 순차 컨테이너 : 수치 인덱스로 표기한 특정 위치에 객체를 저장한다.
- 연관 컨테이너 : 객체 자체를 이용해 컬렉션 내부에 저장할 위치를 결정한다.

컨테이너에서 메서드가 정확히 작동하려면 저장할 객체가 호환성과 동등성 개념을 지니고 있어야한다.</br>
모든 객체가 반드시 hashcode()및 equals() 메서드를 구현해야 한다고 표현한다.</br>

참조형 필드는 힙에 레퍼런스로 저장된다. 객체가 순차적으로 저장된다고 대충 말하지만, 사실 컨테이너에 저장되는 건 객체 자신이 아니라, 객체ㅔ를 가리키는 레퍼런스이다.</br></br>

자바는 메모리 서브시스템이 알아서 가비지 수집을 해주는 대신, 저수준의 메모리 제어를 포기할 수 밖에 없다. 메모리 수동 할당/해제는 물론, 저수준 메모리 레이아웃 제어까지 단념해야한다.</br>


![KakaoTalk_20230912_113924840_02](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/c0e4b5ed-a36c-4be7-8f93-c3dc048b33ec)

<h2>LIST 최적화</h2>

리스트는 ArrayList와 LinkedList 두 가지로 나뒨다.(Vector는 더 이상 쓰이지 않음)</br>

<h4>ArrayList</h4>

배킹 배열의 최대 크기만큼 원소를 추가할 수 있고 이 배열이 꽉 차면 더 큰 배열을 새로 할당한 다음 기존 값을 복사한다.</br>
따라서 크기 조정 작업 비용과 유연성을 잘 저울질해야한다.</br></br>

밴치마킹에 의하면 처음 리스트의 크기를 정해놓고 작업을 돌리는것이 정하지 않고 돌리는 것보다 성은이 더 뛰어난다.</br>

<h4>LinkedList</h4>

LinkedList는 동적으로 증가하는 리스트이다.(이중 연결 리스트)</br>

![KakaoTalk_20230912_113924840_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/ed997a35-44bb-400b-94f1-2e3505f223e1)


<h4>ArrayList vs LinkedList</h4>

둘 중 어느 것을 쓸지는 데이터 접근/수정 패턴에 따라 다르다.</br>

그러나 ArrayList의 특정 인덱스에 원소를 추가하려면 다른 원소들을 모두 한 칸씩 우측으로 이동시켜야한다.</br>
반면, LinkedList는 삽입 지점을 찾기 위해 노드 레퍼런스를 죽 따라가는 수고는 있지만, 삽입 작업은 노드 하나 생성한 다음 두 레퍼런스(first,next)를 세팅하면 간단히 끝난다.</br></br>

리스트를 주로 랜덤 엑세스하는 경우라면 ArrayList가 정답이다.</br>
=> LinkedList는 처음부터 인덱스 카운트만큼 원소를 방문해야한다.</br>

벤치마크에 따르면, 랜덤 엑세스가 필요한 알고리즘을 구사할 때는 ArrayList를 권장한다. ArrayList는 가급적 미리 크기를 지정해서 중간에 다시 조정하는 일이 없도록 하는게 좋다.</br>


<h2>Map 최적화</h2>

자바는 java.util.Map<K,V> 인터페이스를 제공하면 키/값 모두 반드시 참조형이어야 한다.</br>

<h4>HashMap</h4>


![KakaoTalk_20230912_113924840](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/04aecc95-3cf0-4cb4-8c26-1123349efe81)

처음에는 버킷 엔트리를 리스트에 저장한다. 값을 찾으려면 키 해시값을 계산하고 equals()메서드로 리스트에서 해당 키를 찾는다. 키를 해시하고 동등성을 기준으로 리스트에서 값을 찾는 메커니즘이므로 키 중복은
허용되지 않는다. </br>

자바 최근 버전에서는 HashMap이 키 해시값을 계산할 때 상위비트를 무조건 반영하도록 설계한 것이다.</br>
=> 인덱스 계산 시 상위비트가 누락될 수 있기 때문에 여러가지 문제가 생김</br>

HashMap 생성자에 전달하는 initialCapacity와 loadFactor 두 매개변수는 HashMap의 성능에 큰 영향을 미친다. HashMap 용량은 현재 생성된 버킷 개수를, loadFactor는 버킷 용량을 자동 증가(2배)시키는 한계치이다.
용량을 2배 늘리고 저장된 데이터를 다시 배치한 다음, 해시를 다시 계산하는 과정을 재해시라고 한다.</br>

intialCapacity와 loadFactor를 높게 잡으면 순회 시 성능에 상당한 영향을 받는다.</br></br>

initialCapacity는 HashMap이 내부 해시 테이블을 생성할 때 초기로 할당되는 버킷 (해시 버킷)의 수를 나타냅니다.</br>
loadFactor는 해시 맵이 언제 내부 해시 테이블을 재조정할지를 결정하는 요소입니다.</br>

ex)</br>
HashMap<String, Integer> hashMap = new HashMap<>(16, 0.75f);</br>
initialCapacity는 16이고 loadFactor는 0.75로 설정되었습니다. 이러한 매개변수를 조절하여 HashMap의 성능과 메모리 사용량을 조절할 수 있습니다.</br>

최근 HashMap에는  새로운 장치가 달려 있어서 비용이 크기에 비례하여 늘지 않습니다.</br>
하나의 버킷에 TREEIFY_THRESHOLD에 설정한 개수만큼 키/값 쌍이 모이면 버킷을 TreeNode로 바꿔버린다.</br>

※아예 처음부터 바꿔버려?</br>
TreeNode는 리스트 노드보다 약 2배 더 커서 그만큼 공간을 더 차지한다.</br>

<h6>LinkedHashMap</h6>

LinkedHashMapdms HashMap의 서브클래스로, 이중 연결 리스트를 사용해 원소의 삽입 순서를 관리한다.</br>
(LinkeHashMap의 기본 관리 모드는 삽입 순서이지만, 액세스 순서모드로 바꿀 수 있다.)</br>
</br>
LinkedHashMap은 순서가 중요한 코드에서 많이 쓰이지만 TreeMap처럼 비용이 많이 들지는 않는다.</br>

<h5>TreeMap</h5>

TreeMap은 다양한 키가 필요할 때 아주 유용하며, 서브맵에 신속히 접근할 수 있다.</br>
TreeMap이 제공하는 get(), put(), containsKey(), remove() 메서드는 log(n) 작업 성능을 보장한다.</br>
(HahsMap만으로도 충분하지만, 스트림이나 람다로 Map일부를 처리해야 할 때 쓰인다.)</br>


<h4>Set 최적화</h4>

HashSet은  HashMap(LinkedHashSet은 LinkedHashMap)으로 구현되어 있다.


![KakaoTalk_20230918_224009773](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/a69ba3cd-3796-400c-8b29-263dc04e51e5)
![KakaoTalk_20230918_224009773_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/f3538ec2-667c-408b-86bc-1eb95436629f)


- Set은 중복값을 허용하지 않는다.(Map의 키 원소와 똑같다.)
- HashSet의 add() 메서드가 내부적으로 사용하는 HashMap은 키가 원소 E, 값이 PRESENT라는 더미 객체로 구성된다.
- HashSet의 두 번째 protected생성자는 LinkedHashMap 객체를 받는데, 이로써 삽입 순서를 유지하는 LinkedHashMap 로직을 그래도 따라할 수 있다.
- HashSet의 삽입/삭제, Contains 작업은 복잡도가 O(1)이고 원소 순서는 유지하지 않으며 순회비용은 initialCapacity, loadFactor에 따라 달라진다.
- TreeSet 역시 앞서 배운 TreeMap을 활용한다. (TreeSet은 Comparator에 정의한 순서대로 정렬된 키 순서를 유지하므로 TreeSet에 더 알맞게 범위 기반 작업 및 순회 작업을 할 수 있다. TreeSet의 삽입/삭제 복잡도는 log(n)이며 원소 순서는 유지된다.)


 <h4>도메인 객체</h4>

 도메인 객체는 애플리케이션에 유의미한 비즈니스 컨셉트를 나타낸 코드이다.(Order, Item 등)</br>

 도메인 객체는 애플리케이션에서 일차적인 비즈니스 관심사를 나타내고 어느 정도 유일한 상태값을 지니고 있기 때문에 메모리 누수 같은 버그를 찾는 과정에서 쉽게 눈에 띈다.</br>
 자바 힙에 관한 기본적인 팩트</br>
  - 가장 흔히 할당되는 자료 구조는 스트링, char배열, byte배열, 자바 컬렉션 타입의 인스턴스이다.
  - jmap에서 누수되는 데이터는 비정상적으로 비대한 데이터셋으로 나타낸다.

즉 메모리 점유량과 인스턴스 개수 모두 보통 코어 jdk에 있는 자료 구조가 상위권을 형성하는 게 보통이다.</br>

메모리 누수를 일으키는 도메인 객체의 또 다른 특징은 '전체 세대' 효과이다.</br>
=> 특정 타입의 객체가 응당 수집돼야 할 시점에 수집되지 않을 경우, 결국 여러 차례 수집 사이클을 꿋꿋이 견뎌내고 별의별 세대 카운트 값을 지닌 채 테뉴어드 세대까지 살아남는다.</br>

대처법 : 도메인 객체에 대응 되는 데이터셋의 크기를 살피고 그 수치가 온당한지, 그리고 작업 세트에 존재하는 도메인 객체 수가 예상 범위 내에 들어있는지를 확인(??)</br>

부유 가비지 문제를 일으키는 또 다른 원인은 SATB기법이다. (얼마나 짧게 살다가 가든지 마킹 사이클 시작 이후 할당된 객체를 모두 살아 있는 것을 간주한다는 발상)</br>

사실 도메인 객체는 비즈니스 관심사를 가장 분명하게, 자연스럽게 나타낸 객체라서 메모리 누수에 더 취약합니다.</br>
성능을 중요시하는 개발자는 도메인 객체의 도메인을 인식하고 그에 알맞은 크기의 작업세트가 배정되도록 해야한다.</br>


 <h4>종료화 안 하기</h4>

 자바 finalize() 메서드는 리소스 획득은 초기화(RALL)패턴에서는 객체를 해체할 때 자동으로 리소스를 해제/정리하는 해체기 메서드가 있다.</br>
 => 어떤 객체가 생성되면 이 객체ㅔ는 리소스를 소유하고 그 소유권은 객체가 살아 있는 한 지속된다. 그러다 객체가 죽음을 맞이하면 리소스 소유권을 자동으로 내어준다.</br>


![KakaoTalk_20230919_112214924](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/f30a547d-3b3b-49d7-9adc-8c064f974fe0)


어떤 타입이 존재하는 의미를 파일, 네트워크 소켓 같은 리소스의 '소유자'역할을 담당하는 것으로 한정짓는 것이 바람직한 설계이다.</br>

<h5>왜 종료화로 문제를 해결하지 않는까?</h5>

자바 문서 : </br>
어떤 객체가 더 이상 자신을 참조하지 않느다고 가비지 수집기가 판단하면 그 객체에 있는 finalize()메서드를 호출한다.</br>
서브클래스는 finalize()메서드를 오버라이드해서 시스템 리소스를 처분하는 등 기차 정리 작업을 수행한다.</br></br>

※종료화 가능한 개별 객체는 java.lang.Object생성자 바디에서 성공 반환되는 시점에 해당 객체를 등록하는 식으로 jvm에 구현돼 있다.</br>

핫스팟의 구현 상세는, vm에는 표준 자바 명령어 외에도 구현체에 종속된 바이트코드가 있다는 사실이다.</br>
이런 특수한 바이트코드는 어떤 특별한 상황에 맞게 표준 바이트코드를 재작성하기 위해 사용한다.</br></br>

표준 자바 바이트코드 및 핫스팟 전용 바이트코드 전체 목록은 hotspot/share/interpreter/bytecode.cpp 파일에 있고, 그중 return_register_finalizer가 위에 설명한 내용에 해당하는 바이트 코드이다.</br>
return_register_finalizer는 Object.<init>()이 (재작성 없이) 완료되는 정확한 지점을 식별해야 하는데 사용된다.</br>

실제로 종료화가 필요한 객체로 등록하는 코드는 핫스팟 인터프리터에 있다.(등록 코드는  return_register_finalizer에 있다.)</br>

가비지 수집 중 즉시 회수되지 않고 종료화 대상으로 등록된 객체는 다음과 같이 수명의 연장이된다.</br>
- 종료화가 가능한 객체는 큐로 이동
- 애플리케ㅔ이션 스레드 재시작 후, 별도의 종료화 스레드가 큐를 비우고 각 객체마다 finalize()메서드를 실행한다.
- finalize()가 종료되면 객체는 다음 사이클에 진짜 수집될 준비를 마친다.

   종료화할 객체는 모두 gc마킹을 해서 도달 불가능한 객체로 인식시키고 종료화한 다음엔 반드시 gc를 재실행해서 데이터를 다시 수집해야한다. 즉, 종료화 가능한 객체는 적어도
  한 번의 gc사이클은 더 보존된다.</br>

  종료화를 구현한 코드는 대부분 자바로 작성돼 있다. jvm은 대부분의 필요한 작업을 처리하는 애플리케이션 스레드와 함께 별도의 스레드를 만들어 종료화를 수행한다.
  핵심 기능은 패키지-프라이빗 클래스 java.lang.ref.Finalizer에 구현돼 있고 코드가 직관적이라서 알아보기 쉽다.

  또 종료화 구현체는 FinalReference클래스에 크게 의존한다. 이 클래스의 슈퍼 클래스가 바로 런타임이 특별한 경우로 인식하는 java.lang.ref.Reference클래스이다.
  FinalReference객체 역시 gc서브시스템이 특별하게 처리하며, vm과 자바 코드 사이에 흥미진진한 상호작용을 제공하는 메커니즘으로 이뤄져있다.

  가비지 수집은 딱 정해진 시간에 실행되는 법이 없으므로 종료화를 통해 자동으로 리소스를 관리한다는 것 자체가 어불성설이다.
  리소스 해제와 객체 수명을 엮는 장치가 따로 없으니 항상 리소스가 고갈될 위험에 노출돼 있는 셈이다.

  종료화는 당초 의도했던 목적과는 잘 맞지 않는다. 그래서 오래전부터는 일반 애플리케이션 코드에 종료화를 사용하지 말라고 개발자들에게 권고해왔다.
  자바 9부터 Object.finalize()는 없어졌다.

  
  
<h5>try-with-resources</h5>

자바7부터 언어 자체에 추가된 try-with-resources 생성자를 이용하면 try키워드 다음의 괄호의 안에 리소스를 지정해서 생성할 수 있다.</br>
close() 메서드 호출을 깜빡 잊고 빠뜨려도 자동으로 호출됨.</br>

종료화와 try-with-resources 각 바이트 코드를 보면 비슷하지만 메커니즘은 다른다.</br></br>

종료화는 런타임 내부 깊숙한 곳에 있는 어셈블리 코드에ㅔ 기반해 객체ㅔ를 미리 등록하고 특별한 gc작업을 수행한다. 그런 다음 가비지 수집기를 이용해 레퍼런스 큐와 별도의 전용 종료화
스레드를 동원해 정리 작업을 한다.</br>

try-with-resources는 순수한 컴파일 타임 기능이다. 컴파일하면 평범한 바이트 코드로 바뀌는 다른 런타임 로직과는 무관한 일종의 간편 구문이다. try-with-resources는 상당히 큰 바이트 코드를 
변환되므로 JIT컴파일러가 인라이닝하고 메서드를 컴파일하는 과정에 좋지 않은 영향을 끼칠 가능성이있다.</br>


=> 종료화는 GC에 의존하고 GC는 그 자체로 불확정적인 프로세스라서 리소스 관리를 비롯한 대부분의 경우에 원래 의도와는 맞지 않다. 즉, 종료화에 의존하는 객체는 리소스가 해제될지 아무런 보장이 없다.</br>

 <h4>메서드 핸들</h4>

 invokedynamic 명령어는 호출부에서 실행할 메서드를 유연하게 결정해주는 명령어이다.</br>
 핵심은 invokedynamic 호출부가 실제로 어느 메서드를 호출할지 런타임 전까지 결정되지 않는다는 점이다.</br>

 호출부가 인터프리터에 이르면 특수한 보조 메서드(BSM)가 호출되고, 이 BSM은 호출부에서 호출됐어야 할 실제 메서드를 가리키는 객체를 반환한다.</br>
 이 객체를 호출 대상이라고 한다.</br>

 메서드 핸들은 invokedynamic 호출부에 의해 호출되는 메서드를 나타낸 객체이다.</br>



 메서드를 재귀 호출하는 단순 코드에서</br>


 ![KakaoTalk_20230922_201926954](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/de0fc63f-3bbb-4328-881b-6e7104be9f3e)

 메서들 핸들은 두 부분으로 나누어 호추하고 있다.</br>
 메서드 핸들을 룩업하고 그 다음에 호출한다.</br>
실제 시스템에서는 이 두 부분이 시점 또는 위치 측면에서 멀찍이 분리되어 있을 수도 있다. 메서드 핸들은 안정된 불변 객체라서 나중에 쓸 목적으로 보관, 캐시하기가 쉽다.</br>

클래스가 처음 로딩되면 vm은 바이트코드를 전수 검사한다. 이 과정에서 액세스 권한이 없는 메서드를 클래스가 악의적으로 호출하려고 시도하는지 검사한다.</br>
한 번 로딩된 클래스는 성능 문제가 있어서 두번 다시 검사하지 않는다.</br>

메서드 핸들 API는 룩업 컨텍스트라는 방식으로 접근한다.</br>
MethodHadles.lookup() 메서드를 호출해 컨텍스트 객체를 생성하는데, 이 메서드가 반환한 불변 객체에는 컨텍스트 객체를 생성한 지점에서 액세스 가능한 메서드 및 필드를 기록한 상태 정보가 있다.
따라서 컨텍스트 객체를 바로 사용해도 되고 저장했다가 나중에 써도 된다.</br>


![KakaoTalk_20230922_201926954_02](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/354dcb72-3638-45cd-ad99-c394b1dd0f5d)
![KakaoTalk_20230922_201926954_02](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/341ab817-eb43-4415-ba89-da2ea1b62f66)



lookup을 정적 호출한 지점에서 액세스 가능한 메서드를 모두 바라볼 수 있는 컨텍스트 객체가 생성된다.</br>
이로써 FindVirtual()메서드를 이용해 그 지점에서 보이는 모든 메서드의 핸들을 가져올 수 있다.</br>

