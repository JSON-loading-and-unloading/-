<h1>자바 9와 미래</h1>

<h2>자바 9에서 소소하게 개선된 성능</h2>

<h3>코드 캐시 세그먼트화</h3>

자바9부터 코드 캐시 성능을 개선코자 다음 항목별 영역으로 분리했다.</br>
 - 인터프리터 등의 논메서드 코드
 - 프로파일드 코드
 - 논프로파일드 코드
=> 스위퍼 가동 시간이 짧아지고 풀 최적화 코드에 대한 코드 지역성이 향상</br>

<h3>콤팩트 스트링</h3>
char는 16비트 타입이라서 ASCLL 스트링을 저장하면 실제로 필요한 공간의 2개 정도를 더 차지한다.</br>
자바 9이후 콤팩트스트링덕분에 스트링 단위로 최적화할 수 있다.</br>
char[] => byte[]</br></br>

※콤팩트 스트링 기능은 -XX:-CompactStrings, -XX:+CompactStrings스위치로 각각 끄고 켤 수 있다.</br>

<h3>새로운 스트링 연결</h3>

이전에는 방대한 바이트코드가 있었지만</br>
자바 9부터는 invokedynamic을 활용하여</br>
StringConcatFactory.makeConcatWithConstants()라는 팩토리 메서드로 스트링 연결 레시피를 제공한다.</br></br>

<h3>c2컴파일러 개선</h3>
cpu가 SIMD확장 기능을 응용하며 컴파일러 성능 개선을 기대할 수 있다.</br>
SIMD에 따른 기존 인트린직 개선 및 추가</br>
 - 마스킹된 벡터 포스트루프</br>
 - 슈퍼워드 루프 펼치기 분석</br>
 - 멀티비저닝으로 범위 체크 제거</br>
 - 배정도 제곱근 벡터화 지원</br>
 - 병렬 스트링의 벡터화 개선</br>
 - 슈퍼워드를 개선하여 인텔 AVX CPU상에서 벡터 조건부 이동지원</br></br>


 <h3>G1 새 버전</h3>

 G1은 중단 시간을 쉽게 튜닝하고 더 효과적으로 제어하는 특정을 지닌, 여러 가지 문제를 한꺼번에 해결하고자 설계된 수집기이다.</br>
 (자바9부터는 디폴트 수집기가 되었다.)</br>

 <h2>자바 10과 그 이후 버전</h2>

 <h3>자바 10</h3>
자바 10의 주요 특성</br>
 - 286 : 지역 변수 타입 추론</br>
 - 296 : JDK 포레스트를 단일 리파지터리로 통합</br>
 - 304 : 가비지 수집기 인터페이스</br>
 - 307 : G1에서 풀 병렬 GC 구현</br>
 - 310 : 애플리케이션 클래스 데이터 공유</br>
 - 312 : 스레드 로컬 핸드쉐이크</br>

 283 : </br>
 지역 변수를 선언할 때 반복되는 코드를 줄여 쓸 수 있다.</br>
 ```
  var list = new ArrayList<String>();
  var stream = list.stream();
```
</br>
296 :</br>
완전히 내부적인 문제이다.</br></br>

304 : </br>
 서로 다른 가비지 수집기의 코드를 더 분리해서 동일한 jdk빌드에서 가비지 수집기 인터페이스를 깔끔하게 하자는 아이디어.(성능 무관)</br></br>

307 : </br>
  G1 가비지 수집기의 문제점을 해결</br>
  자바 9 G1에 구현된 풀 GC는 싱글 스레드인 마크-스위프-컴팩트 알고리즘을 사용한다</br>
  => 알고리즘을 병렬화해서 G1에서 풀 GC가 발생할 경우, 같은 개수의 스레드를 그대로 동시 수집에 사용하자는 발상</br></br>

310 :</br>
  자바 5에서 도입된 클래스 데이터 공유 특성을 확장시키는 제안.</br>
  jvm이 일습의 클래스를 기록해서 공유 아카이브 파일 하나로 처리</br>
  => 파일을 메모리에 매핑하면 실행할 때 시작 시간을 아낄 수 있고, 여러 jvm이 공유할 수도 있어 같은 호스트에서 멀티 jvm을 실행하는 환경은 전체 메모리 사용량이 줄어든다.</br>
312 :</br>
  전역 vm 세이프포인트를 수행하지 않고 애플리케이션 스레드에 콜백을 실행할 수 있게 해서 vm 성능을 개선하는 토대를 제공하는 것</br>
  => jvm이 스레드 전체가 아니라, 개별 스레드 단위로 멈출 수 있게 하자는 것</br>
  위 효과로</br>
  - 스택 트레이스 샘플을 획득하는 영향도를 낮출 수 있다.</br>
  - 신호 의존도가 줄어들어 스택 트레이스 샘플링을 더 잘할 수 있다.</br>
  - 바이어스를 취소할 때 개별 스레드만 중단시킬 수 있어서 바이어스 락킹 작업이 향상된다.</br>
  - jvm에서 일부 메모리 배리어를 제거</br></br>


 <h2>자바 9 Unsafe 그 너머</h2>

 Unsafe에 다양한 안전 기능이 버무려져 있다.</br>
 cas하드웨어에 액세스하는 메서드는 기본적으로 완전히 안전하지만 비표준이다.</br>
 다른 메서드는 전혀 안전하지 않은 데다 포인터 연산과 동등한 코드가 들어 있다.</br>
 이를 핵심 내부 API라고 부른다.(위 기능들을 다른 방법으로 얻을 수 없어서)</br>
 자바9 에서는 --illegal-access라는 스위치가 추가돼서 이 API에 대한 런타임 액세스를 조정할 수 있다.</br>

 <h3>자바9의 VarHandle</h3>

 자바9부터 메서드 핸들은 가변 핸들까지 포괄하도록 확장됐다.</br>
 이 제안서의 의도는 Unsafe에 있는 API일부를 안전하게 대체하여 간극을 메우는 것이다.</br>
 CAS 기능도 있고 volatile 필드 및 배열에 액세스하는 대체 코드도 있다.</br>
 다른 목적으로는 jdk9에서 jmm업데이트 중 하나도 가능해진 메모리 순서 모드로 저수준 액세스를 하는 것이다.</br></br>



 <h2>발할라 프로젝트와 값 타입</h2>

 발할라 프로젝트의 사명은 이 프로젝트가 고급자바 vm 및 언어의 특성 후보를 탐구/배양하는 장이다.</br>
 주요 목표</br>
  - jvm 메모리 레이아웃을 최신 하드웨어의 비용 모델에 맞게 조정한다.
  - 제네릭스가 기본형, 값, 심지어 void까지 포함하도록 모든 타입에 추상화한다.
  - 기본 라이브러리, 특히 jdk가 이러한 특성을 최대한 활용하는 방향으로 호환성을 유지하며 진화하도록 한다.</br>

jvm에서 값 타입의 사용 가능성을 모색하는 것이 이 프로젝트에서 가장 역점을 둔 연구 분야이다.</br>

자바 9버전 이전까지는 값 타입은 기본형, 참조형 두가지 였다.</br>
 - int 기본형 타입 배열
 - Integer 객체 배열(레퍼런스 배열)
</br>
상상</br>
</br>
프로그래머들이 타입을 직접 정의할 수 있다면 복합 데이터 원소마다 풀 객체 헤더가 필요한 오버헤드를 줄일 수 있다.</br>
예로 3차원 공간의 한 점을 나타내는 클래스에서 공간 좌표 3개로만 구성될 때,</br>

![KakaoTalk_20231017_115759361](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/d10bf970-6a6f-41ae-991f-562d0839c031)


이 개념을 jvm에서 구현할 수 있으면 공간 좌표같은 단순 타입 객체를 메모리에 배치할 수 있기 때문에 효율적이다.</br>

또한, 내장 기본형과 비슷하게 동작하는 사용자 정의 타입 등 다른 가능성도 모색할 수 있다.</br>
끝</br></br>

하지만 제네릭스가 자바5에서 등장하며 이전 처럼 설계된 이유도 있다.</br>
자바는 최상위 타입이 따로 없기 때문에 Object와 int 모두의 슈퍼타입은 존재하지 않는다.</br>
자바 제네릭스는 참조형에만 적용된다.</br>
자바는 타입 소거를 이용해 참조형에 하위 호환성이 보장되는 제네릭 타입을 구현했지만, 최상위 타입의 부재와 그로 인한 기본형 컬렉션의 부재라는 문제를 이 불쾌하기 짝이 없는 메커니즘으로 해결할 수 있는 것도 아니다.</br></br>

따라서 값 타입은 반드시 제네릭스를 개선한 형태에서 타입 매개변수 값으로 유요하다는 전제하에 설계해야한다.</br>

<h2>그랄과 트러플</h2>

자바 c2컴파일러는 c++로 구현돼있어 심각한 문제를 일으킬 소지가 있다.</br></br>

이로 그랄을 사용한다.</br>
jvm용 jit컴파일러를 자바언어로 개발하는 것이다.</br>

 - 자바를 자바로 접근하는 방식은 단순함, 메모리 보안 등 여러 면에서 좋다.
 - c2가 아닌 그랄로 부분 탈출 분석 등의 새로운 최적화 기법을 구현할 수 있게 됐다.
 - 개발자가 커스텀 인트린직 또는 최적화패스 개발 등 자신의 애플리케이션에 맞게 그랄의 일부를 수정할 수 있는 유연성도 있다.
</br>
트러플은 jvm에 기반한 언어 전용 인터프리터를 개발하는 프레임워크로, 입력 언어에 대한 고성능 jit 컴파일러를 인터프리터에서 자동 생성하는 라이브러리다.</br>
(그랄과 찰떡 궁합!!ㅋㅋ)</br>

    
 

