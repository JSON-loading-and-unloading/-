
![KakaoTalk_20230714_164531507](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/9c7f2f56-e378-4652-a8f2-3c86603e94c0)
(기억장치 계층 구조)<br>
위 계층 구조에서 cpu와 캐시를 보고 이들이 데이터를 주고 받을 때,<br>
찾고 있는 데이터의 메모리 주소는 먼저 캐시 메모리에서 이용된다. 메모리 주소를 이용하여 찾고 있는 데이터가 캐시 블록에 있는지 여부를 식별하는데 사용한다.<br>
Cache Hit(캐시 히트)는 캐시 메모리에 찾는 데이터가 존재하였을 때를 나타내며,<br>
Cache Miss(캐시 미스)는 캐시 메모리에 찾는 데이터가 존재하지 않음을 나타낸다.<br>
Cache Miss가 발생하면, 메모리 저장소로부터 필요한 데이터를 찾아 캐시 메모리에 로드한다
<br>
<br>
L1 캐시 (Level 1 Cache): <br>

L1 캐시는 CPU 코어에 가장 가까운 레벨의 캐시입니다.<br>
명령어 캐시와 데이터 캐시로 나누어질 수 있으며, 각각 L1I (Instruction) 캐시와 L1D (Data) 캐시로 알려져 있습니다.<br>
명령어 캐시는 CPU가 실행할 명령어를 저장하고, 데이터 캐시는 CPU가 처리할 데이터를 저장합니다.<br>
L1 캐시는 매우 작지만 매우 빠르며, 일반적으로 몇 KB에서 몇 MB 사이의 용량을 가집니다.<br><br><br>

L2 캐시 (Level 2 Cache):<br>

L2 캐시는 L1 캐시보다 느리지만 크기는 더 큰 캐시입니다.<br>
여러 개의 CPU 코어가 공유하는 공유 캐시(shared cache)로 사용될 수도 있습니다.<br>
L1 캐시의 데이터를 보조하고, L1 캐시에서 놓친 데이터를 검색하는 역할을 수행합니다.<br>
L2 캐시는 용량이 L1 캐시보다 크며, 몇 십 KB에서 몇 MB 사이의 용량을 가질 수 있습니다.<br><br><br>

L3 캐시 (Level 3 Cache):<br>

L3 캐시는 여러 개의 CPU 코어 또는 프로세서 간에 공유되는 큰 용량의 캐시입니다.<br>
L3 캐시는 L1, L2 캐시보다 더 느리지만 크기는 더 큽니다.<br>
주로 멀티코어 프로세서에서 사용되며, 코어 간 데이터 공유와 캐시 일관성 유지를 지원합니다.<br>
L3 캐시는 몇 MB에서 몇십 MB에 이를 수 있는 용량을 가질 수 있으며, 프로세서에 따라 다를 수 있습니다.<br><br><br>


<h4>캐시 일관성 프로토콜</h4>
ex) 디렉토리 프로토콜, 스누핑 프로토콜

캐시 일관성이란<br>
공유 메모리 시스템에서 각 클라이언트(혹은 프로세서)가 가진 로컬 캐시 간의 일관성을 의미함.<br>

각 클라이언트가 자신 만의 로컬 캐시를 가지고<br>
다른 여러 클라이언트와 메모리를 공유하고 있을 때<br>
캐시의 갱신으로 인한 데이터 불일치 문제가 발생함.<br>
![캡처](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/242ca2d9-622d-46d8-a2f2-5fbf75e86fe5)

예를 들어 변수 X에 대해서 두 클라이언트가 변수 X를 공유하고 있고 그 값이 0이라고 하자.<br>

이때 클라이언트 1(그림의 윗쪽)이 X에 1을 대입하였고<br>
클라이언트 2(그림의 아래쪽)가 변수 X를 읽어들이게 되면<br>
클라이언트 2는 클라이언트 1에 의해 수정된 값인 1을 받아들이는 것이 아니라<br>
현재 자신의 로컬 캐시에 있는 0을 읽어들이게 된다.<br>

따라서 캐시 1, 2는 같은 X라는 변수에 대해 다른 값을 가지게 되므로 데이터 불일치 문제가 발생한다.<br>

따라서 하드웨어 차원에서 항상 최신내용을 읽을 수 있게 캐시 일관성(Cache Coherence)을 지원해야함.<br>

캐시 일관성을 유지한다고 하는 것은<br>
이러한 데이터 불일치 현상을 없애는 것을 의미함.<br>

캐시 일관성을 유지하기 위해서는<br>
다른 프로세서가 갱신한 캐시 값을 곧바로 혹은 지연하여<br>
다른 프로세서에서 사용할 수 있도록 해주어야 함.<br>
https://goodgid.github.io/Cache-Coherence/
(참고 자료)<br>

<h4>디렉토리 프로토콜</h4>
 1.락 획득 (Acquiring Lock):<br>
   클라이언트가 데이터를 수정하기 전에 해당 데이터에 대한 락을 획득합니다.<br>
   이 락은 다른 클라이언트들이 해당 데이터를 동시에 수정하는 것을 방지하여 데이터의 일관성을 유지합니다.<br>
 2.쓰기 작업 (Write Operation):            ✅쓰기 작업은 해당 클라이언트 캐시가 아닌 메인 메모리에 쓰기 작업이 일어난다.<br>
   클라이언트가 데이터를 수정하는 쓰기 작업을 수행합니다.<br>
   이때, 락을 획득한 클라이언트만 해당 데이터를 수정할 수 있으며, 다른 클라이언트들은 기다리게 됩니다.<br>
 3.락 해제 (Releasing Lock):<br>
   쓰기 작업이 완료되면, 클라이언트는 해당 데이터에 대한 락을 해제합니다.<br>
   이로써 다른 클라이언트들이 해당 데이터에 접근하여 수정할 수 있게 됩니다.<br>
 4.일관성 유지 (Maintaining Consistency):<br>
   디렉토리 포로토콜은 여러 클라이언트들의 쓰기 작업을 적절하게 조율하여 데이터의 일관성을 유지합니다.<br>
   일관성을 유지하기 위해 락을 사용하여 동시에 하나의 클라이언트만 쓰기 작업을 수행하도록 합니다.<br><br>

<strong>쓰기 작업이후 각 클라이언트의 캐시에는 어떻게 변형된 데이터를 적용시킬까?</strong>
1.캐시 무효화 (Cache Invalidation):<br>
   캐시 무효화는 메인 메모리에 쓰기 작업이 발생하면 해당 데이터를 사용하는 모든 클라이언트의 캐시를 무효화하는 방법입니다.<br>
   메인 메모리에 쓰기 작업이 발생하면, 디렉토리 포로토콜은 해당 데이터를 가진 모든 클라이언트의 캐시에 무효화 메시지를 보내어 캐시를 갱신하도록 유도합니다.<br>
   이후 클라이언트들이 해당 데이터를 다시 필요로 할 때, 캐시 무효화로 인해 메인 메모리에 있는 최신 데이터를 다시 가져옵니다.<br>
2.캐시 갱신 (Cache Update):<br>
   캐시 갱신은 메인 메모리에 쓰기 작업이 발생하면 해당 데이터를 사용하는 클라이언트의 캐시를 직접 갱신하는 방법입니다.<br>
   메인 메모리에 쓰기 작업이 발생하면, 디렉토리 포로토콜은 해당 데이터를 사용하는 클라이언트들에게 캐시 갱신 메시지를 보내어 캐시를 최신 데이터로 갱신하도록 유도합니다.<br>
   이후 클라이언트들은 자신의 캐시를 갱신하여 최신 데이터를 사용합니다.<br><br><br>


<h3>TLB</h3>

1. 가상 메모리의 필요성
   
물리 메모리의 용량이 부족하여 결국 새로운 프로세스를 실행하려면 다른 프로세스를 빼고 실행해야함 <br>
=> A작업 도중 B작업이 들어와 A가 내려가고 다시 A를 작업하려고 할 때, <br>
A작업을 중간부터 해야하는데 처음부터 해야하는 지옥이 시작됨. 그래서 가상 메모리를 각 프로세스마다 지급해줌.<br>
https://wpaud16.tistory.com/288<br>
(참고자료)<br><br>

⌗페이지 테이블은 가상 메모리(Virtual Memory)를 관리하기 위한 자료 구조이다.<br>
page table는 메인 메모리에 존재하는데 그렇다면 CPU는 메인 메모리에 최소 2번은 접근해야 원하는 데이터를 얻을 수 있다.<br>

1. page table에 한번 접근<br>
2. page table을 기반으로 실제 메모리로 접근<br><br>

이런 메모리의 접근을 줄이고자 나온 게 TLB ( Translation Look-aside Buffer )다. <br>
하드웨어적으로 지원하여 page table의 임시저장 cache 역할을 한다. <br>
TLB는 최근에 읽었던 page table을 매핑하여 저장하는데 굉장히 작다. 64 ~ 1024 entry정도다. <br>
왜냐면 TLB에 있으면 메모리에 접근하기 전에 막아야 하기 때문에 크기를 작게 하여 속도를 높인다.<br>

![캡처](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/611d24ef-3026-4c83-ae10-2e7074988323)

CPU에서 나온 정보를 가지고 TLB를 탐색하고, 있다면 바로 물리 주소에 접근하고, 없다면 page table로 들어간다. 
https://wpaud16.tistory.com/286
(참고자료)<br>


![KakaoTalk_20230715_140658823_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/b3b260d2-37c0-4721-a93c-c6b62c20b18a)


![KakaoTalk_20230715_152529804](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/b7c225bb-271f-4339-a193-67e71de67093)

생성(Created): 프로세스가 생성되었지만 아직 실행되기 전인 상태입니다. 운영 체제는 프로세스를 생성하고 초기화 작업을 수행한 후에 이 상태로 전환됩니다.<br>

준비(Ready): 프로세스가 실행될 준비가 완료된 상태입니다. 프로세서가 사용 가능하고 프로세스가 필요한 모든 리소스를 할당받았으나 아직 실행되지 않은 상태입니다. 이 상태에서는 다른 프로세스가 실행 중인 동안 프로세스 스케줄러에 의해 선택될 때까지 대기합니다.<br>

실행(Running): 준비 상태에서 선택된 프로세스가 현재 프로세서에서 실행 중인 상태입니다. 프로세스는 중앙 처리 장치(CPU)를 사용하여 작업을 실행합니다.<br>

대기(Waiting 또는 Blocked): 프로세스가 어떤 이벤트를 기다리거나 특정 조건이 충족될 때까지 실행을 중지한 상태입니다. 예를 들어, 프로세스가 입출력 작업이 완료될 때까지 대기하는 동안 이 상태로 전환될 수 있습니다.<br>

종료(Terminated 또는 Exit): 프로세스의 실행이 완료되어 종료된 상태입니다. 이 상태에서는 할당된 리소스가 해제되고, 운영 체제에 의해 프로세스의 최종 상태와 실행 결과가 정리됩니다.<br>





