<h1>마이크로벤치마킹과 통계</h1>


<h2>자바 성능 측정 기초</h2>

벤치마크 : 컴퓨터 시스템, 프로그램, 알고리즘 등의 성능을 측정하고 비교하는 데 사용되는 기술 또는 절차<br>

- 가급적 시스템의 어느 한 곳만 변경하고 다른 외부 요인은 벤치마크 안에 두고 통제하면 좋다.
- 시스템에서 가변적인 부분은 테스트 간에 불변성을 유지해야 하면 좋다.

  자바 플랫폼을 벤치마크할 때에는 자바 런타임의 정교함이 문제이다. => 선택지가 제한적이다.<br>
  => 최적화가 미치는 영향을 구체적으로 완전히 이해하고 설명하기 불가능하다.<br>
  
  ※ 큰 단위 벤치마킹으로 처리하여 상쇄시킬 수 있지만 마이크로벤치마크를 할 때는 코드를 떼어놓기가 어렵다.<br>

  벤치마크 할 때의 실수<br>

  1. JVM웜엄을 전혀 고려하지 않은 채 그냥 코드를 테스트한다.<br>

  Jit 컴파일러는 코드를 조금이라도 효율적으로 작동시키려고 호출 계층을 최적화하므로 벤치마크 성능은 캡처 타이밍에 따라 달라짐.<br>

   - 타이밍을 캡처하기 전에 JVM이 가동 준비를 마칠 수 있게 웜업 기간을 두는게좋다.( 충분히 jit컴파일러가 작동하여 캐시 역할 수행)
   - 타이밍 캡처 도중에 GC가 안 일어나게 설정한 다음 가동시키면 좋다.
 

2. 테스트하려는 코드에서 생성된 결과를 실제로 사용하지 않는다.<br>

  -  jit컴파일러가 죽은 코드로 식별하고 벤치마크하려던 것을 최적화해버릴 가능성이 있다.<br>
  -  
3. 한번 측정한 결과로는 평균을 내도 벤치마크가 어떻게 수행됐는지 전체 사정을 알 수 없다.<br>

   - 허용 오차를 구해 수집한 값의 신뢰도를 파악하면 좋다.<br>
     => 허용 오차가 큰 것은 통제불능 변수가 있거나, 개발된 코드 자체가 성능 기준에 미치지 못한다.<br>


엉뚱한 벤치마크 결과를 피하는 법<br>
  1. 시스템 전체를 벤치마크한다. ( 저수준 수치는 수집하지 않는다.)<br>
  2. 연관된 저수준의 결과를 의미있게 비교하기 위해 앞서 언급한 많은 문제를 공통 프레임워크를 이용해 처리한다.<br>

<h2>JHM 소개</h2>

<h4>휴리스틱:마이크로벤치마킹은 언제 하나?</h4>

마이크로벤치마킹을 하는 주요 유스케이스<br>
 - 사용 범위가 넓은 범용 라이브러리 코드를 개발한다.<br>
 - OpenJDK 또는 다른 자바 플랫폼 구현제를 개발한다.<br>
 - 지연에 극도로 민간한 코드를 개발한다.<br>

=> 마이크로벤치마크는 가장 극단적인 애플리케이션에 한하여 사용하는 것이 좋다<br>

<h4>JHM 프레임워크</h4>
jmh는 자바를 비롯해 jvm을 타깃으로 하는 언어를 적성된 나노/마이크로/밀리/매크로/ 벤치마크를 제작,실행,분석하는 자바 도구이다.<br>
=> jvm릴리즈마다 맞는 jmh도 함께 진화해왔다.<br>

 - 리플렉션을 써서 작성한 벤치마크를 실행하는 우회 방법도 있지만, 벤치마크 실행 경로에 복잡한 jvm 서브 시스템이 하나 더 끼어든다.<br>
 - JMH는 벤치마크 코드에 애너테이션을 붙여 자바 소스를 추가 생성하는 식으로 작동한다.<br>

<h4>벤치마크 실행</h4>

JMH 프레임워크는 상태를 제어하는 기능을 제공한다.<br>
=> 멀티스레드 코어 역시 상태를 제대로 관리되지 않아 벤치마크가 편향되지 않게 조심해야한다.<br>

🎇JVM은 메서드 내에서 실행된 코드가 부수효과를 전혀 일으키지 않고 그 결과를 사용하지 않을 경우 해당 메서드를 삭제 대상으로 삼는다.<br>
=> 이때,  JMH는 이런 일이 없도록 벤치마크 메서드가 반환한 단일 결괏값을 암묵적으로 블랙홀에 할당한다.<br>

블랙홀은 네 가지 장치를 이용해 벤치마크에 영향을 줄 수 있는 최적화로부터 보호한다.<br>
 - 런타임에 죽은 코드를 제거하는 최적화를 못 하게 한다.
 - 반복되는 계산을 상수 폴딩하지 않게 만든다.
 - 값을 읽거나 쓰는 행위가 현재 캐시 라인에 영향을 끼치는 잘못된 공유 현상을 방지한다.
 - 쓰기 장벽으로부터 보호한다.

장벽 : 일반적으로 리소스가 포화돼서 사실상 애플리케이션에 병목을 초래하는 지점<br>

![KakaoTalk_20230729_161322604](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/5066c60d-b5ef-446c-a2f7-d89c9e04f124)

![KakaoTalk_20230729_161322604_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/8f82b5d1-3944-4dc2-9cc7-df70e83dbe72)

![KakaoTalk_20230729_161327010](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/ecba62b2-a12c-40e8-8f6d-43536873ffaa)

하지만, GC가 작동됐다...ㅠㅠ<br>
=> 잘살펴야한다..<br><br>


<h2>JHM 성능 통계</h2>

랜덤 오차 : 측정 오차 또는 무관계 요인이 어떤 상관관계 없이 결과에 미친다.<br>
계통 오차 : 원인을 알 수 없는 요인이 상관관계 있는 형태로 측정에 영향을 미침.<br><br>

※정확도가 높으면 계통 오차가 낮다.<br>
※정밀도가 높으면 랜덤 오차가 낮다.<br>

<h4>계통오차</h4>

  ![KakaoTalk_20230729_164354413](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/6094832f-e035-48dd-9b41-9460d383615b)

  1. 제일 위의 그래프를 볼 경우 선형 패턴이 증가되어 서버 리소스가 조금씩 소모되고 있다.<br>
  이는 메모리 누수가 발생하거나, 어떤 스레드가 요청 처리 도중 다른 리소스를 점유하여 놔주질 않는 상황에서 주로 나타난다.<br>

 2. 다른 서비스 대부분 180밀리초 안팎의 일정한 응답 시간을 보인다.<br>
     => 잘못된 테스터 설정으로 인한 발생<br>

    
  
<h4>랜덤오차</h4>

![KakaoTalk_20230729_164354413_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/e400dbfa-6951-4e02-9283-e0e0c0e7c1a4)

랜덤 오차의 근원은 오직 운영환경의 이유이다.<br>


<h4>허위상관</h4>

![KakaoTalk_20230730_122634177](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/344a99e1-fc1d-49b9-969b-16f1b908a671)

두 변수가 비슷하게 움직인다고 해서 이들 사이에 연결고리가 있다고 볼 수는 없다.<br>
JVM과 성능 분석 영역에서는 그럴싸해 보이는 연결고리와 상관관계만 보고 측정값 간의 인과 관계를 넘겨짚지 않도록 조심해야한다.<br>


<h2>비정규 통계학</h2>

HdrHistogram을 통해 정교한 분석이 가능하다.<br>
pom.xml에 의존성 추가<br>

![KakaoTalk_20230730_122634177_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/72cec2b0-18c0-4379-aa78-87244b3e97f9)

자바 성능 튜닝 중 측정한 값은 대부분 통계적으로 심한 비정규 분포를 나타낸다.<br>


<h2>통계치 해석</h2>

![KakaoTalk_20230730_124420136](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/1823f0ef-92c3-42c5-af3f-c098b420b543)

빨간선 : 클라이언트 오류로 매핑되지 않은 URL을 클라이언트가 요청하면 웹 서버는 곧장 응답을 준다.<br>
파란선 : 서버 에러로 장시간 처리하다가 (백엔드 리소스가 장시간 부하를 받거나 타임아웃에 걸려) 발생하는 편이다.<br>
주황선 : 성공 요청으로 긴 꼬리형 분포를 보이지만, 실제로는 극댓값이 여럿인 다봉분포를 나타낸다.<br>

=> 위 그래프처럼 측정값을 보다 유의미한 하위 구성 요소들로 분해하는 개념은 아주 유용하다.<br><br>

