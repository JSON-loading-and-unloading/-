<h1>JVM의 코드 실행</h1>

JVM이 제공하는 가장 중요한 서비스는 메모리 관리와 사용하기 쉬운 애플리케이션 코드 실행 컨테이너이다.</br>

JVM 인터프리터는 일종의 스택 머신처럼 작동하므로 물리적 CPU와는 달리 계산 결과를 바로 보관하는 레지스터는 없다. 대신 작업할 값은 모두 평가 스택에ㅔ 넣고 스택 머신 명령어로 스택 최상단에
위치한 값을 변환하는 식으로 작동한다.</br>

JVM은 다음 세 공간에ㅔ 주로 데이터를 담아 놓는다.</br>
- 평가 스택 : 메서드 별로 하나씩 생성된다.
- 로컬 변수 : 결과를 임시 저장한다.
- 객체 힙 : 메서드끼리, 스레드끼리 공유된다.

  JVM에서 각 스택 머신 작업 코드는 1바이트로 나타낸다.</br>
  따라서 옵코드는 0부터 255까지 지정 가능하며, 그중에서 약 200개를 사용하고 있다.(자바 10버전 기준)</br>

  바이트코드 명령어는 스택 상단에 위치한 두 값의 기본형을 구분할 수 있게 표기한다.</br>
  ex) iadd와 dadd는 각각 int 값과 double 값)</br>

  자바는 이식성을 염두에 두고 설계된 언어이다.</br>
  JVM은 빅 엔디언, 리틀 에네디언 하드웨어 아키텍처 모두 바이트코드 변경없이 실행 가능하도록 명세에 규정되어 있다.</br>
  따라서, JVM 바이트 코드는 둘 중 어느 엔디언을 따를지 결정해야한다.</br>


  단축어 명령어, 타입별 명령어를 쓰다보니 필요한 옵코드 개수가 급증했고 여러 옵코드가 개념상 동일한 작업을 나타내는 경우도 있다.</br>
  그래서 사실 바이트코드는 개념적으로는 아주 단순하지만, 바이트 코드로 나타낼 수 있는 기본 작업보다 훨씬 많은 옵코드가 할당되어 있다.</br>


  스택에 데이터를 넣고 빼는 옵코드로 구성된 로드/스토어 카테고리이다.</br>
  상수 풀에서 데이터를 로드하거나 스택 상단을 힙에 있는 객체 필드에 저장하는 등의 작업을 한다.</br>

![KakaoTalk_20230827_191536065_04](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/2a3ffa70-532e-45c6-8738-a0f54578e305)</br>


산술 바이트코드이다. 기본형에만 적용되며 순수하게 스택 기반으로 연산을 수행하므로 인수는 없다.</br>


![KakaoTalk_20230827_191536065_03](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/204d2d44-2d8b-4421-8dd2-3442967c5bf1)</br>


흐름제어 바이트 코드. 소스 코드의 순회, 분기문을 바이트 코드 수준으로 표현하는 옵코드들이다.</br>


![KakaoTalk_20230827_191536065_02](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/cdb9aa5b-fcbe-46ec-9777-a8a50bc78d46)</br>


메서드 호출 바이트코드. 자바 프로그램에서 새 메서드롤 제어권을 넘기는 유일한 장치. 자바 플랫폼은 지역 흐름 제어와 다른 메서드로 제어권을 넘기는 행위를 분명히 구분함.</br>


![KakaoTalk_20230827_191536065_01](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/30d9d4da-0108-4472-adb9-397337cdf4fc)</br>


플랫폼 옵코드. 객체별로 힙 저장 공간을 새로 할당하거나, 고유 락을 다루는 명령어</br>

![KakaoTalk_20230827_191536065](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/d39c347e-19bb-4fee-a092-f8ec4845a6d1)</br>


<h3>핫스팟에 특정한 내용</h3>

핫스팟은 템플릿 인터프리터라서 시작할 때마다 동적으로 인터프리터를 구축한다.</br>
=> 인터프리터 소스 코드조차 분석하기 어렵다.</br>
   핫스팟은 단순한 VM 작업을 구현하고 네이티브 플랫폼의 스택 프레임 레이아웃을 최대한 활용하여 성능을 조금이라도 높이기 위해 상당히 많은 어셈블리어 코드로 작성돼있다.</br>
   여기서 핫스팟 전용 바이트코드까지 정의해서 쓴다.</br>
=> 특정 옵코드의 일반적인 유스케이스와 핫하게 쓰는 경우를 차별화하려는 의도이다.</br>
이 설계방식은 다양한 특이 사례를 다루는데 도음이 된다.</br>
ex)</br>
 
![KakaoTalk_Photo_2023-08-28-19-41-15](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/c1a53f7e-d6de-4fb3-99cb-5b67a1062dfe)
</br>


 이미지에서 A클래스에서 fMethod() 메서드를 논final 메서드로 바꾸면 이 메서드는 서브클래스에서 오버라이드 가능하다.</br>
 이제 B인스턴스를 otherMethod() 메서드의 인수로 넘기면 바이트 코드 수준에서는 invokespecial 명령어가 실행되어 메서드를 잘못 호출한다.</br>

 => 이는 리스코프 치환 원칙에도 맞지 않는다.</br>

 리스코프 치환 원칙 : 서브 클래스의 인스턴스는 슈퍼클래스의 인스턴스가 올 수 있는 곳이면 어디라도 사용 가능하다.</br>

 그러므로 final 메서드 호출은 반드시 invokeviertual 명령어로 컴파일돼야하지만, final메서드는 오버라이드가 안된다는 점을 jvm도 알고 있기 때문에 핫스팟 인터프리터에는 final 메서드를 디스패치하는 전용 프라이빗 바이트코드가 준비돼 있다.</br>

 <h2>AOT와 JIT 컴파일</h2>

 <h4>AOT 컴파일</h4>

사람이 읽을 수 있는 프로그램 소스 코드를 외부 프로그램에 넣고 바로 실행 가능한 기계어를 뽑아내는 과정이다.</br>
AOT의 목표는 프로그램을 실행한 플랫폼과 프로세서 아키텍처에 딱 맞는 실행코드를 얻는 것이다.</br>
(프로세서별로 특수한 기능을 십분 활용해 프로그램 속도를 높인다.)</br>

하지만, 대부분의 실행 코드는 자신이 어떤 플랫폼에서 실행될지 모르는 상태에서 생성되므로 AOT컴파일은 자신이 사용 가능한 프로세서 기능에 대해 가장 보수적인 선택을 해야한다.</br>
 <h4>JIT 컴파일</h4>

 JIT 컴파일은 런타임에 프로그램을 고도로 최적화한 기계어로 변환하는 기법이다.</br>
 => 프로그램 런타임 실행 정보를 수집해서 어느 부분이 자주 쓰이고, 어느 부분을 최적화해야 가장 효과가 좋은지 프로파일을 만들어 결정을 내리는 것이다.</br>

 jit컴파일은 바이트 코드를 네이티브 코드로 컴파일하는 비용은 런타임에 지불한다. </br>
이 과정에서 프로그램 실행에만 온전히 동원됐을 일부 리소스가 소비되므로 jit컴파일은 산발적으로 수행된다.</br>
또한, VM은 최적화하면 가장 좋은 지점을 파악하기 위해 각종 프로그램 관련 지표를 수집한다.</br>


컴파일 코드를 디스크에 저장했다가 다음 애플리케이션 시작할 때 그대로 꺼내쓰면 안되나?, 애플리케이션을 실행할 때마다 이렇게 최적화를 재수행하고 컴파일 결정을 하는 건 낭비 아닌가?</br>
=> 미리 계산된 최적화를 이용한 시스템이 PGO를 활용한 시스템보닫 경쟁력이 떨어진다.</br>
=> 애플리케이션을 실행할 때마다 성능이 심한 편차를 보이는 현상은 아주 흔하다.</br>
=> 핫스팟은 프로파일링 정보를 보관하지 않고 VM이 꺼지면 일체 폐기한다. 따라서 프로파일은 처음부터 다시 만들어진다.</br>





