<h1>고성능 로깅 및 메시징</h1>
자바는 개발자가 신경 써서 처리해야 하는 저수준 관심사를 대폭 줄임으로써 생산성을 엄청나게 끌어올렸다.</br>
고수준 언어로 추상화해서 개발자 생산성은 향상시켰지만, 대신 저수준 제어를 포기하고 성능 자체를 직접 다룰 수 없는 단점을 남겼다.</br></br>


저지연, 고성능 시스템에서 핵심적인 고려 사항 두 가지는 로깅, 메시징이다.</br>

<h2>로깅</h2>

로거 중 바람직하지 않는 안티패턴

<h4>10년짜리 로거</h4>
누군가 이미 로거를 잘설정해놨다. 뭐 하러 다시 만드나? 그냥 편하게 갖다 쓰면 되지.

<h4>프로젝트 전체 로거</h4>
누군가 프로젝트 각 파트마다 따로 로거를 재구성하지 않아도 되게끔 로거를 감싸놓았다.

<h4>전사 로거</h4>
누군가 전사적으로 사용 가능한 로거를 만들었다.

<h3>로깅 벤치마크</h3>

<h4>로깅 없음</h4>
현재 로거가 켜져 있고 어떤 한계치 이하로 메시지가 로깅되고 있는 상태에서 무동작로그의 비용을 측정하는 벤치마크 테스트이다.</br>

<h4>Logback 포맷</h4>
```
14:18:17.635 [name of thread] INFO c.e.NameOfLogger - Log message
```
</br>
<h4>java.util.logging 포맷</h4>
```
Feb 08, 2017 2:09:19 PM com.example.NameOfLogger nameOfMethod
INFO: Log message
```
</br>
<h4>Log4j 포맷</h4>
```
2017-02-08 14:16:29,651 [Name Of Thread] INFO com.example.NameOfLogger - message
```
</br>
<h4>측정</h4>

이미지
</br>
Logback이 Log4j보다 약간 더 빠르게 나왔다.</br>

<h4>로거 결과</h4>
실행 시간 측면에서 대체로 Logback 성능이 가장 좋고, 자바 유틸 로거가 제일 나빴다..</br></br>

로깅 프레임워크가 생성하는 엄청난 양의 가비지도 잘 따져보아야 한다.</br>
로깅하느라 소비한 cpu 시간만큼 핵심 업무를 병렬 처리할 기회를 잃어버리기 때문이다.</br>
로깅 라이브러리의 설계와 작동 원리 역시 직선적인 마이크로벤치마크 실행 결과만큼 중요하다.</br>

<h2>성능에 영향이 적은 로거 설계하기</h2>




