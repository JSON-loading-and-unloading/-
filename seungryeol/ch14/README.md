<h1>고성능 로깅 및 메시징</h1>
자바는 개발자가 신경 써서 처리해야 하는 저수준 관심사를 대폭 줄임으로써 생산성을 엄청나게 끌어올렸다.</br>
고수준 언어로 추상화해서 개발자 생산성은 향상시켰지만, 대신 저수준 제어를 포기하고 성능 자체를 직접 다룰 수 없는 단점을 남겼다.</br></br>


저지연, 고성능 시스템에서 핵심적인 고려 사항 두 가지는 로깅, 메시징이다.</br>

<h2>로깅</h2>

로거 중 바람직하지 않는 안티패턴

<h4>10년짜리 로거</h4>
누군가 이미 로거를 잘설정해놨다. 뭐 하러 다시 만드나? 그냥 편하게 갖다 쓰면 되지.

<h4>프로젝트 전체 로거</h4>
누군가 프로젝트 각 파트마다 따로 로거를 재구성하지 않아도 되게끔 로거를 감싸놓았다.

<h4>전사 로거</h4>
누군가 전사적으로 사용 가능한 로거를 만들었다.

<h3>로깅 벤치마크</h3>

<h4>로깅 없음</h4>
현재 로거가 켜져 있고 어떤 한계치 이하로 메시지가 로깅되고 있는 상태에서 무동작로그의 비용을 측정하는 벤치마크 테스트이다.</br>

<h4>Logback 포맷</h4>
```
14:18:17.635 [name of thread] INFO c.e.NameOfLogger - Log message
```
</br>
<h4>java.util.logging 포맷</h4>
```
Feb 08, 2017 2:09:19 PM com.example.NameOfLogger nameOfMethod
INFO: Log message
```
</br>
<h4>Log4j 포맷</h4>
```
2017-02-08 14:16:29,651 [Name Of Thread] INFO com.example.NameOfLogger - message
```
</br>
<h4>측정</h4>

이미지
</br>
Logback이 Log4j보다 약간 더 빠르게 나왔다.</br>

<h4>로거 결과</h4>
실행 시간 측면에서 대체로 Logback 성능이 가장 좋고, 자바 유틸 로거가 제일 나빴다..</br></br>

로깅 프레임워크가 생성하는 엄청난 양의 가비지도 잘 따져보아야 한다.</br>
로깅하느라 소비한 cpu 시간만큼 핵심 업무를 병렬 처리할 기회를 잃어버리기 때문이다.</br>
로깅 라이브러리의 설계와 작동 원리 역시 직선적인 마이크로벤치마크 실행 결과만큼 중요하다.</br>

<h2>성능에 영향이 적은 로거 설계하기</h2>
로깅은 모든 애플리케이션의 필수 컴포넌트이지만, 저지연 애플리케이션에서 로거는 비즈니스 로직 성능에 병목 현상을 초래해선 안된다.</br></br>

Log4j 2.6으로 실행하면 같은 시간 동안 GC사이클이 한 번도 발생하지 않았다.</br>
Log4j 2.6에서 성능이 향상된 비결은, 각 로그 메시지마다 임시 객체를 생성했던 로직을 객체를 재사용하는 방향으로 수정한 것이다.</br>
객체 풀 패턴을 실천한 전형적인 사례이다.</br>
Log4j 2.6은 ThreadLocal 필드를 이용해 스트링 -> 바이트 변환 시 버퍼를 재사용하는 식으로 객체를 재사용한다.</br></br>

Logj4는 임시 배열을 생성해 로그문에 전달되는 매개변수를 담고 가변인수를 사용해 할당 횟수를 줄인다.</br>
Log4j를 SLF4J로 감싸면 퍼사드가 매개변수를 2개만 지원하기 때문에, 가비지-프리한 방식을 응용하거나 Log4j2 라이브러리를 직접 사용해서 코드 베이스를 리팩터링할 필요가 없다.</br>

<h2>리얼 로직 라이브러리를 이용해 지연 줄이기</h2>

로얼 로직은 저수준 세부의 이해가 고성능 설계에 영향을 미친다는 기계 공감 접근 방식을 주장한 마틴 톰슨이 설립한 영구 회사이다?</br>


