<h1>고성능 로깅 및 메시징</h1>
자바는 개발자가 신경 써서 처리해야 하는 저수준 관심사를 대폭 줄임으로써 생산성을 엄청나게 끌어올렸다.</br>
고수준 언어로 추상화해서 개발자 생산성은 향상시켰지만, 대신 저수준 제어를 포기하고 성능 자체를 직접 다룰 수 없는 단점을 남겼다.</br></br>


저지연, 고성능 시스템에서 핵심적인 고려 사항 두 가지는 로깅, 메시징이다.</br>

<h2>로깅</h2>

로거 중 바람직하지 않는 안티패턴

<h4>10년짜리 로거</h4>
누군가 이미 로거를 잘설정해놨다. 뭐 하러 다시 만드나? 그냥 편하게 갖다 쓰면 되지.

<h4>프로젝트 전체 로거</h4>
누군가 프로젝트 각 파트마다 따로 로거를 재구성하지 않아도 되게끔 로거를 감싸놓았다.

<h4>전사 로거</h4>
누군가 전사적으로 사용 가능한 로거를 만들었다.

<h3>로깅 벤치마크</h3>

<h4>로깅 없음</h4>
현재 로거가 켜져 있고 어떤 한계치 이하로 메시지가 로깅되고 있는 상태에서 무동작로그의 비용을 측정하는 벤치마크 테스트이다.</br>

<h4>Logback 포맷</h4>
```
14:18:17.635 [name of thread] INFO c.e.NameOfLogger - Log message
```
</br>
<h4>java.util.logging 포맷</h4>
```
Feb 08, 2017 2:09:19 PM com.example.NameOfLogger nameOfMethod
INFO: Log message
```
</br>
<h4>Log4j 포맷</h4>
```
2017-02-08 14:16:29,651 [Name Of Thread] INFO com.example.NameOfLogger - message
```
</br>
<h4>측정</h4>

이미지
</br>
Logback이 Log4j보다 약간 더 빠르게 나왔다.</br>

<h4>로거 결과</h4>
실행 시간 측면에서 대체로 Logback 성능이 가장 좋고, 자바 유틸 로거가 제일 나빴다..</br></br>

로깅 프레임워크가 생성하는 엄청난 양의 가비지도 잘 따져보아야 한다.</br>
로깅하느라 소비한 cpu 시간만큼 핵심 업무를 병렬 처리할 기회를 잃어버리기 때문이다.</br>
로깅 라이브러리의 설계와 작동 원리 역시 직선적인 마이크로벤치마크 실행 결과만큼 중요하다.</br>

<h2>성능에 영향이 적은 로거 설계하기</h2>
로깅은 모든 애플리케이션의 필수 컴포넌트이지만, 저지연 애플리케이션에서 로거는 비즈니스 로직 성능에 병목 현상을 초래해선 안된다.</br></br>

Log4j 2.6으로 실행하면 같은 시간 동안 GC사이클이 한 번도 발생하지 않았다.</br>
Log4j 2.6에서 성능이 향상된 비결은, 각 로그 메시지마다 임시 객체를 생성했던 로직을 객체를 재사용하는 방향으로 수정한 것이다.</br>
객체 풀 패턴을 실천한 전형적인 사례이다.</br>
Log4j 2.6은 ThreadLocal 필드를 이용해 스트링 -> 바이트 변환 시 버퍼를 재사용하는 식으로 객체를 재사용한다.</br></br>

Logj4는 임시 배열을 생성해 로그문에 전달되는 매개변수를 담고 가변인수를 사용해 할당 횟수를 줄인다.</br>
Log4j를 SLF4J로 감싸면 퍼사드가 매개변수를 2개만 지원하기 때문에, 가비지-프리한 방식을 응용하거나 Log4j2 라이브러리를 직접 사용해서 코드 베이스를 리팩터링할 필요가 없다.</br>

<h2>리얼 로직 라이브러리를 이용해 지연 줄이기</h2>

로얼 로직은 저수준 세부의 이해가 고성능 설계에 영향을 미친다는 기계 공감 접근 방식을 주장한 마틴 톰슨이 설립한 영구 회사이다?</br>

<h2>아그로나</h2>
아그로나 프로젝트는 저지연 애플리케이션 전용 구성 요소를 담아놓은 라이브러리이다.</br></br>

아그로나는 진정한 저지연 애플리케이션 라이브러리 세트를 제공한다.</br>
=> 표준 라이브러리만으로 유스케이스를 충족시키기 어렵다는 사실이 밝혀졌다면 아그로나 라이브러리를 한 번 검토해보자!</br>

<h4>버퍼</h4>
자바에는 다이렉트/논다이렉트 버퍼를 추상화한 ByteBuffer클래스가 있다.</br>
다이렉트 버퍼는 자바 힙 밖에 있기 때문에 온-힙 버퍼보다 할당/해제율은 낮은  편이다.</br>
다이렉트 버퍼의 장점은 중단 단계의 매핑 없이 직접 구조체에 명령어를 실행하는 것이다</br></br>

ByteBuffer는 일반화한 유스케이스가 가장 큰 문제로, 버퍼 타입별로 최적화를 적용할 수 없다.</br>
가령, ByteBuffer는 아토믹 연산을 지원하지 않으므로 생산자/소비자 방식의 버퍼를 구축할 때 제약이 따른다.</br>
또 ByteBuffer를 사용하려면 매번 다른 구조체를 감쌀 때마다 하부 버퍼를 새로 할당해야한다.</br>
아그로나는 복사를 지양하며 저마다 독특한 특정을 지닌 버퍼를 네 가지 지원한다.</br></br>

 - DirectBuffer 인터페이스 : 버퍼에서 읽기만 가능하며 최상위 상속 계층에 위치한다.
 - MutableDirectBuffer 인터페이스 : DirectBuffer를 상속하며 버퍼 쓰기도 가능하다.
 - AtomicBuffer 인터페이스 : MutableDirectBuffer를 상속하며 메모리 액세스 순서까지 보장한다.
 - UnsafeBuffer 클래스 : Unsafe를 이용해 AtomicBuffer를 구현한 클래스이다.

아그로나 버퍼 클래스의 상속 계층도</br>

이미지
</br>
아그로나 버퍼를 이용하면 다양한 get메서드를 통해 하부 데이터를 가져올 수 있다.</br>
put메서드를 이용하면 버퍼의 특정 위치에 long값을 넣을 수 있다.</br>
경계 검사 기능은 설정/해제가 가능하므로 불필요한 코드는 JIT 컴파일러로 최적화하면서 들어낼 수 있다.</br>

<h4>리스트,맵,세트</h4>
아그로나는 int 또는 long형 배열에 기반한 리스트 구현체를 여럿 제공한다.</br>
아그로나 ArrayListUtil을 이용하면 리스트 순서는 안 맞지만 ArrayList에서 신속하게 원소를 제거할 수 있다.</br>
아그로나 맵, 세트 구현체 키/값을 해시 테이블 자료 구조에 나란히 저장된다.</br>
키와 충돌하면 다음 값은 해시 테이블의 해당 위치 바로 다음에 저장된다.</br>
(동일한 캐시 라인에 있는 기본형 매핑을 재빠르게 액세스할 때 좋은 자료구조이다.)</br>

<h4>큐</h4>

아그로나의 동시성 패키지에는 큐, 링 버퍼를 비롯해 쓸만한 자료 구조 및 동시성 유틸리티가 있다.</br></br>

아그로나 큐는 표준 java.util.Queue 인터페이스를 준수하므로 표준 큐 구현체 대신 쓸 수 있고, 순차 처리용 컨테이너 지원 기능이 부각된</br>
org.agrona.concurrent.Pipe인터페이스도 함께 구현되어 있다. </br>
특히, Pipe는 원소를 카운팅하고, 수용 가능한 최대 원소 개수를 반환하고,</br>
원소를 비우는 작업을 지원하므로 큐를 소비하는 코드와 원활하게 상호작용할 수 있다.</br>
큐는 모두 락-프리하고 Unsafe를 사용하므로 저지연 시스템에 안성맞춤이다!!!</br></br>


큐 분리 구현체 종류</br>

<h5>OneToOneConcurrentArrayQueue</h5>
헤드는 큐에서 poll() 또는 drain()할 때에만, 테일은 put()할 때에만 업데이트할 수 있다.</br>
이 모드를 선택하면 나머지 두 가지 큐에서 꼭 필요한, 부수적인 조정 체크를 하느라 쓸데없이 성능 누수를 유발할 일이 없다.</br>

<h5>ManyToManyConcurrentArrayQueue</h5>
생산자가 다수일 경우에는 테일 위치를 업데이트할 때 부가적인 제어 로직이 필요하다.</br>
while루프에서 Unsafe.compareAndSwapLong를 사용하면 꼬리가 업데이트될 때까지 큐 테일을 안전하게, 락-프리하게 업데이트할 수 있다.</br>

<h5>ManyToOneConcurrentArrayQueue</h5>
생성자, 소비자가 모두 다수일 경우, 머리/테일 양쪽을 업데이트해야 한다.</br>
이 정도 수준으로 조정/제어하려면 compareAndSwap을 감싼 while 루프가 필요하다.</br>

<h4>링 버퍼</h4>

아그로나가 제공하는 org.agrona.concurrent.RingBuffer는 프로세스 간 통신용 바이너리 인코딩 메세지를 교환하는 인터페이스이다.</br>
RingBuffer는 DirectBuffer를 이용해 메시지 오프-힙 저장소를 관리한다.</br>
소스 코드에 주석으로 포함된 다음 아스키 아트 덕분에 메시지가 RecordDescriptor 자료 구조에 저장된다는 사실을 알 수 있다.</br></br>

아그로나에 내장된 링 버퍼 구현체는 OneToOneConcurrentArrayQueue, ManyToOneConcurrentArrayQueue 두 가지이다.</br>
쓰기 작업은 소스 버퍼를 전달받아 그 메시지를 별도의 버퍼에 써넣는 반면, 읽기 작업은 메시지 핸들러의 onMessage() 메서드로 콜백된다.</br>
ManyToOneConcurrentArrayQueue에서 여러 생산자가 쓰기하고 있는 상황에서 Unsafe.storeFence() 메서드를 호출하면 수동으로 메모리 동기화를 통제할 수 있다.</br>

<h2>단순 바이너리 인코딩</h2>

단순 바이너리 인코딩(SBE)는 저지연 성능에 알맞게 개발된 바이너리 인코딩 방식으로, 금융시스템에서 쓰이는 FIX 프로토콜에 특화되어 있다.</br></br>

버퍼는 아그로나에서 빌려쓴다.</br>
SBE는 GC를 유발하지 않고 메모리 액세스 같은 문제를 최적화하지 않고도 효율적인 자료 구조를 통해 저지연 메시지를 전달할 수 있다.</br></br>

저지연 애플리캐이션의 목표는 수단과 방법을 가리지 않고 애플리케이션 성능을 최대한 짜내는 것이다.</br>
그래서 거래 애플리케이션의 임계 경로를 거치는 지연을 줄이고자 경쟁 거래사 간에 군비 경쟁을 방불케 하는 노력이 치열하다.</br></br>

<h5>카피-프리, 네이티브 타입 매핑</h5>
복사는 비용이 든다. 조그마한 객체는 별로 안비싸지만, 크기가 커질수록 복사 비용도 함께 증가한다.</br>
SBE의 카피-프리 기술은 중간 버퍼를 쓰지 않고 메시지를 인코딩/디코딩하도록 설계됐다.</br>

하지만, 하부 버퍼에 직접 쓰는 작업은 설계 비용이 든다. 버퍼에 집어넣지 못할 정도로 큰 메시지를 지원할 수 없기 때문에 메시지를 조각조각 나누어 다시 조립하는 프로토콜을 구축해야</br>
이런 메시지도 지원 가능하다.</br>

<h5>정상 상태 할당</h5>
저지연 애플리케이션 설계 시 자바의 객체 할당 방식은 문제가 된다.</br>
할당 작업 자체도 cpu사이클을 소모하지만 사용을 마친 후 객체를 지우는 것도 문제이다</br>
GC는 STW, 즉 중단을 자주 일으키다.</br>
SBE는 하부 버퍼에 플라이트웨이트 패턴을 사용하므로 할당-프리한다.</br>

<h5>스트리밍/단어 정렬 액세스</h5>
자바에서 메모리 액세스는 범접할 수 없는 대상이다.</br>
자바 배열은 보통 레퍼런스 배열 형태라서 메모리 순차 읽기는 불가능하다.</br>
SBE는 메시지를 진행 방향으로 인코딩/디코딩하도록 설계되어 있어서 정확하게 단어를 정렬할 수 있는 틀이 잡혀있다.</br>



