<h1>동시 성능 기법</h1>

<h2>병렬성이란?</h2>

순차 실행 파트를 S, 총 태스크 소요 시간은 T라고 표기한다. 필요한 프로세서는 얼마든지 자유롭게 쓸 수 있다는 가정하에 프로세서 개수가 N이라고 하면,</br>
T는 프로세서 개수의 함수, 즉 T(N)으로 표기할 수 있다</br>
동시 작업은 T - S이고 N개 프로세스에 태스크를 고루 분배한다고 가정하면 전체 태스크 소요시간은 다음과 같다.</br>
```
T(N)  = S + (1/N) * (T - S)
```
프로세서를 무한히 증가시켜도 총 소요시간은 순차 작업 시간 이상 줄일 수가 없다.</br>
즉, 순차 오버헤드가 전체의 5%라고 하면 아무리 코어를 늘려도 20배 이상 속도를 높이는 건 불가능하다.</br>

이미지

더 빠른 코어를 장착하여 싱글 스레드 성능을 개선하면 S값을 줄일 수는 있겠지만, 아쉽게도 최신 하드웨어는 cpu클록 스피드를 높여도 그만한 속도 향상을 체감하기 어렵다.</br>


암달의 법칙에 따르면, 병렬 태스크나 다른 순차 태스크 간에 소통할 필요가 전혀 없을 경우 이론적으로 속도는 무한히 높일 수 있다.</br>
이런 부류의 워크로드를 낯간지러운 병렬이라고한다.</br>

보통 데이터 공유없이 워크로드를 나누어 여러 워커 스레드에 분산시킨다.</br>
스레드끼리 상태나 데이터를 공유하기 시작하면 워크로드는 점차 복잡해지면서 결국 어쩔 수 없이 일부 태스크를 순차 처리하게 되고 통신 오버헤드가 발생한다.</br>
=> 상태를 공유하는 워크로드는 무조건 정교한 보호/제어 장치가 필요하다. 자바 플랫폼은 jvm에서 실행되는 워크로드에 jmm이라는 메모리 보증 세트를 제공한다.</br>


이미지


두 스레드가 A, B가 있고 둘 다 같은 객체의 increment()메서드를 호출한다.</br>

각 스레드는 메서드 개별 진입 시 각자 전용 평가 스택을 소유하므로 필드에 대한 작업은 서로 간섭이 일어날 수 있다.</br>
=> A나 B가 실행되기 전 i의 초기 상태가 7이고 정확히 위 순서대로 실행된다고 하면, 두 차례 호출 결과 모두 8이 반환되고 필드는 i는 8이 될 것이다.</br>
※volatile을 추가하면 안전하게 증분 연산을 할 수 있을 것처럼 보이지만 그건 오산이다.(무조건 값을 캐시에서 다시 읽어들여 다른 스레드가 수정된 값을 바라보게 할 수는 있지만,증분 연산자의 복합적인 특성 탓에 방금 전 업데이트 소실 문제를 막을 수는 없다.)
</br></br>

다음은 두 스레드가 동일한 카운터의 레퍼런스를 공유하는 코드이다.</br>

이미지

synchronized나 락으로 감싸지 않은 채 카운터로 무방이가 노출돼 있어서 프로그램을 돌릴 때마다 두 스레드는 갖가지 형태로 셔로 엮일 공간이 크다.</br>

동기화를 사용할 때는 아주 신중하게 설계하고 미리 잘 따져봐야 한다는 부담이 따른다.</br>
아무 생각 없이 synchronized만 달랑 추가했다간 프로그램이 빨라지기는커녕 더 느려질 수도 있다.</br>
이처럼 처리율 향상은 동시성을 부여하는 전체 목표와 상충된다. 따라서 코드 베이스를 병렬화하는 작업을 진행할 때에는 복잡도가 늘어난 대가로 얻은 혜택을 충분히 입증할 수 있도록
성능 테스트가 수반되어야한다.</br></br>






