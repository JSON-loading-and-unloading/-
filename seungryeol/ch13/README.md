<h1>프로파일일</h1>

프로파일링 : 애플리케이션의 성능과 동작을 분석하고 측정하여 병목 현상을 식별하고 최적화하는 프로세스를 나타낸다.</br>
샘플링 : 애플리케이션의 실행 중간에 일정한 간격으로 샘플 데이터를 수집하는 기술을 나타낸다.</br></br>

- 실행
- 할당

  위 장에서 프로파일링을 집중적으로 살펴보면서 애플리케이션을 프로파일링하는 데 사용 가능한 툴을 소개하고, 뒷부분에서는 메모리 프로파일링 및 관련 기능을 제공하는 다양한 툴 사용법을 알아본다.</br>
</br>
  내용의 핵심은, 자바 개발자와 성능 엔지니어가 일반적인 프로파일러의 작동 방시을 이해하는 겍 얼마나 중요한일인각, 하는 것이다.</br>

  <h2>프로파일링 개요</h2>

  jvm 프로파일링/모니터링 툴은 보통 저수준의 인스트루먼테이션을 이용해서 작동하며, 수집한 데이터는 그래픽 콘솔에 피드백하거나 추후 분석 용도로 로그에 저장한다.</br>
  저수준 인스트루먼테이션은 대부분 애플리케이션 시작 시 로드되는 에이전트나 실행 중인 jvm에 동적으로 부착하는 컴포넌트 형태로 구현한다.</br></br>

  명확히 구분해야 할 것들</br>
   - 모니터링 툴(시스템과 그 현재 상태를 살피는 것)
   - 경고 시스템(비정상적/변칙적인 움직임을 감지하는 것)
   - 프로파일러(실행 중인 애플리케이션의 심층 정보를 제공하는 것)

</br>
프로파일링의 목표는 리팩터링 및 성능 최적화 대상 코드를 식별하는 것이다.</br></br>
=> 성능 문제를 진단하고 바로 잡는 첫걸음은 문제를 일으키는 리소스를 찾아내는 것</br>

성능 엔지니어는 프로파일링을 수행하기 전에 성능 문제를 밝혀내야 한다.</br>
또한, 성능 문제의 원인이 애플리케이션 코드라는 사실 역시 입증해야 한다.</br></br>


CPU가(커널 시간이 아닌) 유저 모드에서 최고조에 달해 완전 탈진한 상태라면, 프로파일링을 하기 전에ㅔ GC STW같은 요소는 원인 후보군에서 제외시켜야 한다.</br>
(성능이 중요한 애플리케이션이라면 GC 이벤트를 로깅하고 있을 테니 간단히 확인 해볼 수 있다.)</br>

머신에 남아있는 GC 로그 및 애플리케이션 로그를 뜯어보고 GC 로그는 잠잠한데 애플리케이션 록그는 난리법석인지 알아보면 된다.</br>
난리 피운 쪽이 GC로그라면 다음 수순은 실행 프로파일링이 아닌, GC 튜닝이다.
</br>

<h2>샘플링과 세이프포인팅 편향</h2>

실행 프로파일링에서 기억해야 할 사실은, 실행 중인 코드의 자료점을 대부분 샘플링을 통해 획득한다는 점이다.</br>
측정하는 행위 자체도 공짜는 아니므로 데이터 수집 비용을 조금이라도 줄이고자 메서드 입출구는 보통 추적하지 않는다.</br>
대신, 스레드 실행 스냅샷을 찍는데, 비교적 낮은 빈도로 찍으면 오버헤드가 그리 크지 않다.</br></br>

샘플링 주기는 성능 엔지니어의 갈등을 일으키는 문제이다.</br>
성능에 예민한 애플리케이션에서 너무 자주 샘플링하면 오버헤드를 감당키 어려울 테고, 그렇다고 너무 뜸하게 샘플링하면</br>
중요한 장면을 놓칠 가능성이 커서 기껏 샘플링을 해도 애플리케이션의 실제 성능을 제대로 반영하지 못하게 된다.</br>

샘플링은 문제점이 데이터에 가려지게 만들 빌미를 제공할 뿐만 아니라, 대부분의 샘플링이 세이프 포인트에서만 일어난다는 점도 문제가 된다.</br>
두 가지 중요한 결과</br>
- 모든 스레드는 샘플을 뜨기 전에 세이프포인트에 다다라야 한다.
- 세이프포인트 지점에 있는 애플리케이션 상태만 샘플링할 수 있다.

  실행 중인 프로세스를 샘플링하기 전에 모든 스레드가 세이프포인트에 있어야 하므로 그만큼 오버헤드가 가중되며, 세이프포인트 지점에 있는 애플리케이션 상태만 샘플링하기 때문에 표본점 분포가 왜곡될 소지가 있다.
</br></br>
  실행 프로파일러는 대부분 핫스팟 c++ API에 있는 GetCallTrace()함수를 이용해 각 애플리케이션 스레드의 스택 샘플을 수집한다.</br>
  하지만, GetCallTrace()는 적잖은 오버헤드를 일으킨다. (애플리케이션 활성 스레드가 n개일 때 스택 샘플을 수집하려면 결국 jvm이 세이프포인트를 n번 해야한다.)</br>

  성능 엔지니어라면 애플리케이션에서 세이프포인팅 시간이 얼마나 되는지 예의주시해야할 것이다.</br>
  세이프 포인트에 너무 많은 시간을 소비하면 애플리케이션 성능은 나빠지고 부정확한 데이터에 튜닝 에너지를 낭비하게 될지 모른다.</br></br>

  jvm플래그를 이용하면 세이프 포인팅 시간이 높은 경우를 추적하는데에 도움이 된다.</br>
  ```
  -XX:+PrintGCApplicationsStoppedTime
  ```
  이 플래그는 GC로그에 세이프포인팅 시간에 관한 추가 정보를 로깅한다.</br>


  세이프포인팅 편향이 일으키는 문제는 카운티드 루프로 설명 가능하다.</br>
  다음과 같은 단순루프가 있다.</br>
  ```
  for(int i = 0; i < LIMIT; i++){
    // 루프 바디에서 '단순' 작업만 있다.
  }
  ```




단순 작업은, 이를 테면 가본형의 값의 산술 연산이나 완전히 인라이닝된 메서드 호출등이 해당된다.</br>
LIMIT 값이 클 경우, JIT컴파일러는 자바 코드를 루프 처음으로 되돌리는 백 브랜치를 포함해서 즉시 동등한 컴파일드 코드로 옮길 것이다.</br>
JIT컴파일러는 루프 백 끝부분에 세이프 포인트 체크를 삽입하므로, 루프가 커질수록 한 번 루프가 반복될 때마다 세이프포인트를 할 기회가 주어지게 된다.</br></br>

반대로 LIMIT값이 충분히 작을 경우에는 그런 일은 일어나지 않고, 대신 jit컴파일러가 루프를 펼칠 것이다.</br>
즉 충분히 작은 카운팅 루프를 실행하는 스레드는 루프가 완료될 때까지 세이프포인트를 하지 않는다.</br></br>

따라서, 세이프포인트에서만 샘플링하면 루프 크기와 우리가 그 안에서 하려는 작업 성격에 크게 좌우되는, 편향된 작동 모습을 보이게 된다.</br>


  <h2>개발자용 프로파일링 툴</h2>

  <h3>VisualVM 프로파일러</h3>
  VisualVm은 실행 프로파일러, 메모리 프로파일러가 모두 들어있고 사용하기 쉬운 무료 둘이다.
  <h3>JProfiler</h3>
  ej-테크롤러지스사가 제작한 JProfiler는 에이전트에 기반한, 유명한 사용 프로파일러이다.
 <h3>YourKit</h3>
 YourKit은 유어킷 사가 개발한 상용 프로파일러이다.
 <h3>JFR/JMC</h3>
 자바 비행 기록기/자바 관제 센터는 오라클이 BEA 시스템즈사를 인수하면서 손에 넣은 프로파일링/모니터링 기술이다.</br>
 (자바 8기준으로는 JFR/JMC는 오라클 JVM에서만 쓸 수 있는 상용 툴이어서 OpenJDK를 비롯한 다른JVM에서는 못쓴다.)</br></br>

 JFR을 사용하려면 오라클 jvm을 시동할 때 다음 스위치를 전달한다.</br>
 ~~~
-XX:+UnlockCommericialFeatures -XX:+FlightRecorder
 ~~~
 <h3>운영 툴</h3>
  프로파일러는 개발자가 문제점을 진단하거나 애플리케이션이 런타임에 저수준에서 어떻게 작동하는지 파악하려고 사용하지만, 운영계 모니터링 툴로도 많이 쓰인다.</br>
  현재 시스템 상태를 한눈에 보기 좋게 나타내고 전반적인 시스템 상황이 정상/비정상인지 알려주는 툴이다.</br>

  <h4>레드햇 서모스택</h4>
  서모스탯은 레드햇 사가 개발한 핫스팟 기반의 jvm전용 오픈 소스 서비서빌리티/모니터링 솔루션이다.</br>
  openJKD와 사용라이선스가 같고 단일 머신, 클러스터 모두 모니터링할 수 있다. 이력 데이터와 특정 시점별 상태 정보는 몽고DB에 저장한다.</br></br>

  서모스탯 아키텍처는 확장이 가능해 다음과 같은 용도로도 쓸 수 있다.</br>
  - 유저가 직접 만든 커스텀 지표를 수집,분석한다.
  - 필요 시 인스트루먼테이션용 커스텀 코드를 주입한다.
  - 커스텀 플러그인을 작성하고 툴링을 통합한다.

  <h4>뉴 렐릭</h4>
  뉴 렐릭은 클라우드 기반 애플리케이션용 SaaS제품이다.</br>
  따라서 비단 jvm뿐만 아니라 사용범위가 넓은 범용 툴 세트이다.</br></br>

  뉴 렐릭은 종합 모니터링, 풀스택 지원 기능이 아주 돋보이는 운영/데스옵스 툴이지만, 범용 툴인 까닭에 jvm기술만 특별히 초점을 두지는 않는다.</br>

  <h4>jClarity 일루미네이트</h4>
  일루미네이트는 기존 샘플링프로파일러와는 다르며, 메인 자바 애플리케이션을 관찰하는 별도의 외부 데몬 프로세스를 이용한 모니터링 모드로 작동한다.</br></br>

  일루미네이트의 머신 러닝 알고리즘은 OS,GC 로그, JVM에서 긁어모은 데이터를 분석해서 성능 문제를 야기한 근본 원인을 밝힌다.</br>
  상세 보고서를 작성해 유저에게 알리고 문제 해결에 필요한 다음 조치 방안을 제시한다.</br>
  머신 러닝 알고리즘은 jClarity 창립 멤버인 커크 페퍼다인이 처음 개발한 성능 모델에 기반한다.</br>

  <h2>최신 프로파일러</h2>

  <h6>어니스트 프로파일러</h6>

  리차드 워버튼이 주도한 오픈 소스 프로젝트이다.</br>

  어니스트 프로파일러의 주목표</br>
  - 다른 대부분의 프로파일러에 있느 세이프포인트 편향을 없앤다.
  - 오버헤드가 아주 낮은 상태로 작동시킨다.

  어니스트 프로파일러는 핫스팟 내부의 AsyncGetCallTrace라는 프라이빗 API를 활용한다.</br>
  핫스팟 jvm을 비롯해 오라클,레드햇, 아줄 줄루 jvm에서는 잘 작동하지만, 당연히 논-OpenJDK 계열 jvm에서는 사용할 수 없다.</br></br>

  위 프로파일러의 구현체는 SIGPROF라는 유닉스 OS 시그널을 전송해 실행 스레드를 인터럽트한다.</br>
  그러면 AsyncGetCallTrace() 프라이빗 메서드를 통해 호출 스택을 수집할 수 있다.</br>
  스레드만 따로 인터럽트하므로 전역 동기화 이벤트 따위는 없다.</br></br>

  어니스트 프로파일러의 단점은, 일부 스레드 제일 위에 'Unknown'이라고 표시되는 현상이다.</br>

  다음과 같이 프로파일러 에이전트르 설치해 사용한다.</br>
  ~~~
  -agentpath:<liblagent.so 파일경로>=interval=<n>, logpath=<log.hpl 파일경로>
  ~~~

 실무에서 어니스트 프로파일러 같은 툴은 보통 헤드리스 모드로 실행시켜 데이터 수집 용도로 쓴다.</br>
 시각화는 다른 툴을 쓰거나 커스텀 스크립트로 제공한다.</br>

  <h6>perf</h6>

  perf는 리눅스 애플리케이션의 경량급 프로파일링 툴이다. 특정 자바/jvm 애플리케이션에 구애받지 않으며, 하드웨어 성능 카운터를 읽는다.</br>
  리눅스 커널 tools/perf에 포함돼 있다.</br></br>

  성능 카운트는 성능 분석자가 관심있는 하드웨어 이벤트를 카운팅하는 물리 레지스터이다.</br>
  실행된 명령어, 캐시미스, 분기 예측 실패 등 애플리케이션 프로파일링의 근본을 형성하는 이벤트들이다.</br>

<h6>Async 프로파일러</h6>

Async 프로파일러는 어니스트 프로파일러를 대체할 만한 툴이다.</br>
어니스트 프로파일러와 같은 내부 API를 쓰며 핫스팟 JVM에서만 실행 가능한 오픈 소스 툴이다.</br>
perf에 전적으로 의존하는 툴이라서 perf를 실행할 수 있는 OS에서만 작동한다.</br></br>
  
 
<h2>할당 프로파일링</h2>

전체 프로파일링에서 실행 프로파일링이 차지하는 비중이 크긴 하지만 이것만 있는것은 아니다.</br>
대부분의 애플리케이션은 일정 수준의 메모리 프로파일링도 병행해야한다.</br>
할당 프로파일링은 애플리케이션의 할당 동작을 살피는 표준 메모리 프로파일링이다.</br></br>

할당 프로파일링 접근 방식 = > HeapVisitor방식, VisualVM 메모리 프로파일링 뷰, YourKit</br></br>

 jvm에서 메모리 할당을 지시하는 바이트코드는 세가지이다.</br>

 <h6>NEW</h6>
 주어진 타입의 객체를 생성할 공간을 할당한다.

<h6>NEWARRAY</h6>
기본형 배열 공간을 할당한다.
<h6>ANEWARRAY</h6>
주어진 타입의 객체 배열 공간을 할당한다.

할당을 일으키는 옵코드는 이 셋뿐이므로 인스트루먼테이션할 바이트코드도 이들뿐이다.</br>

가장 단순한 인스트루먼테이션은, 할당 옵코드를 지닌 인스턴스를 하나하나 찾아내 실제 할당 옵코드가 실행되기 직전에 로깅하는 정적 메서드 호출부를 사입한다.</br>

![KakaoTalk_20231003_162928535](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/d425e59a-40a8-4de1-870e-17c0aa94901e)

MethodVisitor는 NEW, NEWARRAY, ANEWARRAY 바이트코드가 위치한 각 인스턴스보다 먼저 기록 메서드를 호출하는 코드를 끼워 넣는다.</br>
=> 변환 장치를 장착하면 이제 앞으로 객체 또는 배열이 생성될 때마다 기록 메서드가 호출될 것이다.</br></br>

바이트코드 수준의 기법은 많은 메모리가 스레드에 할당 되는지 간단히 측정하는 코드 작성 시 참고하면 도움이 된다.</br>
단위 테스트 용도로도 좋고, 회귀 테스트를 할 때 밖군 코드를 적용해도 메모리가 추가 할당되는 일은 없다는 사실을 검증하는 쓰임새로도 쓰인다.</br></br>

위 방법은 운영계에서는 비추된다. </br>
=> 메모리가 할당될 때마다 부가적인 메서드 호출이 발생하면 호출 횟수가 상당히 증가한다.</br>
=> jit 컴파일을 하면 인스트루먼테이션한 호출부가 인라이닝되겠지만, 그래도 전체 성능에 무시 못 할 영향도 끼칠 수 있다.</br></br>

TLAB을 이용해 할당 프로파일링을 하는 방법도 있다.</br>
Async프로파일러는 핫스팟 전용 콜백을 이용해 다음 시점에 알림을 수신하는 TLAB샘플링 기능을 지원한다.</br></br>

 - 새로 만든 TLAB에 객체가 할당될 때
 - TLAB 밖에 객체가 할당될 때
객체 할당을 일일이 전부 다 세지 않고, 매 n킬로바이트 단위로 뭉뚱그려 할당을 기록하는 것이다.</br>
(여기서 n은 TLAB의 평균 크기이다.)</br>


<h2>힙 덤프 분석</h2>

전체 힙의 스냅샷을 툴로 자세히 뜯어보면서 어떤 객체가 살아 있는지, 그 개수와 타입은 어떤지 등의 중요한 팩트와 객체 그래프의 형상/구조를 파악하는 일이다.
</br>
하지만 힘 덤프는 크기가 문제이다. 덤프한 메모리 크기가 300~400%에 달하는 경우도 흔하다.</br>
=> 디스크에 쓰는 것도 문제지만, 운영계에서는 네트워크를 통해 가져와야한다.</br>
=> 가져오더라도 리소스가 빵빵한 워크스테이션에 로드해야 하고, 작업 흐름에 과도하게 지연을 일으키지 않는 선에서 덤프를 처리해야한다.</br></br>

힙 파일 생성은 힙을 샅샅이 뒤져 덤프 파일을 쓰는 과정이므로 STW 이벤트도 불가피하다.</br></br>

YourKit은 메모리 스냅샷 갭처 기능을 hprof 및 전용 포맷, 두 가지 방식으로 지원한다.</br>
YourKit은 상용 툴 중에서 비교적 괜찮은 필터와 힙 덤프 뷰를 제공한다.</br>
또 클래스로더와 웹 애플리케이션 용도로 분류할 수 있어서 힙 문제를 신속하게 진단할 수 있다.</br></br>

JMC/JFR 할당 뷰도 쓸만하다. Async 프로파일러도 사용하는 TLAB할당 뷰를 표시할 수 있다.</br>

※hprof 자바9 이후로 JDK에서 사라졌다.</br>






  
