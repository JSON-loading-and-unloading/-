<h1>프로파일일</h1>

프로파일링 : 애플리케이션의 성능과 동작을 분석하고 측정하여 병목 현상을 식별하고 최적화하는 프로세스를 나타낸다.</br>
샘플링 : 애플리케이션의 실행 중간에 일정한 간격으로 샘플 데이터를 수집하는 기술을 나타낸다.</br></br>

- 실행
- 할당

  위 장에서 프로파일링을 집중적으로 살펴보면서 애플리케이션을 프로파일링하는 데 사용 가능한 툴을 소개하고, 뒷부분에서는 메모리 프로파일링 및 관련 기능을 제공하는 다양한 툴 사용법을 알아본다.</br>
</br>
  내용의 핵심은, 자바 개발자와 성능 엔지니어가 일반적인 프로파일러의 작동 방시을 이해하는 겍 얼마나 중요한일인각, 하는 것이다.</br>

  <h2>프로파일링 개요</h2>

  jvm 프로파일링/모니터링 툴은 보통 저수준의 인스트루먼테이션을 이용해서 작동하며, 수집한 데이터는 그래픽 콘솔에 피드백하거나 추후 분석 용도로 로그에 저장한다.</br>
  저수준 인스트루먼테이션은 대부분 애플리케이션 시작 시 로드되는 에이전트나 실행 중인 jvm에 동적으로 부착하는 컴포넌트 형태로 구현한다.</br></br>

  명확히 구분해야 할 것들</br>
   - 모니터링 툴(시스템과 그 현재 상태를 살피는 것)
   - 경고 시스템(비정상적/변칙적인 움직임을 감지하는 것)
   - 프로파일러(실행 중인 애플리케이션의 심층 정보를 제공하는 것)

</br>
프로파일링의 목표는 리팩터링 및 성능 최적화 대상 코드를 식별하는 것이다.</br></br>
=> 성능 문제를 진단하고 바로 잡는 첫걸음은 문제를 일으키는 리소스를 찾아내는 것</br>

성능 엔지니어는 프로파일링을 수행하기 전에 성능 문제를 밝혀내야 한다.</br>
또한, 성능 문제의 원인이 애플리케이션 코드라는 사실 역시 입증해야 한다.</br></br>


CPU가(커널 시간이 아닌) 유저 모드에서 최고조에 달해 완전 탈진한 상태라면, 프로파일링을 하기 전에ㅔ GC STW같은 요소는 원인 후보군에서 제외시켜야 한다.</br>
(성능이 중요한 애플리케이션이라면 GC 이벤트를 로깅하고 있을 테니 간단히 확인 해볼 수 있다.)</br>

머신에 남아있는 GC 로그 및 애플리케이션 로그를 뜯어보고 GC 로그는 잠잠한데 애플리케이션 록그는 난리법석인지 알아보면 된다.</br>
난리 피운 쪽이 GC로그라면 다음 수순은 실행 프로파일링이 아닌, GC 튜닝이다.
</br>

<h2>샘플링과 세이프포인팅 편향</h2>

실행 프로파일링에서 기억해야 할 사실은, 실행 중인 코드의 자료점을 대부분 샘플링을 통해 획득한다는 점이다.</br>
측정하는 행위 자체도 공짜는 아니므로 데이터 수집 비용을 조금이라도 줄이고자 메서드 입출구는 보통 추적하지 않는다.</br>
대신, 스레드 실행 스냅샷을 찍는데, 비교적 낮은 빈도로 찍으면 오버헤드가 그리 크지 않다.</br></br>

샘플링 주기는 성능 엔지니어의 갈등을 일으키는 문제이다.</br>
성능에 예민한 애플리케이션에서 너무 자주 샘플링하면 오버헤드를 감당키 어려울 테고, 그렇다고 너무 뜸하게 샘플링하면</br>
중요한 장면을 놓칠 가능성이 커서 기껏 샘플링을 해도 애플리케이션의 실제 성능을 제대로 반영하지 못하게 된다.</br>

샘플링은 문제점이 데이터에 가려지게 만들 빌미를 제공할 뿐만 아니라, 대부분의 샘플링이 세이프 포인트에서만 일어난다는 점도 문제가 된다.</br>
두 가지 중요한 결과</br>
- 모든 스레드는 샘플을 뜨기 전에 세이프포인트에 다다라야 한다.
- 세이프포인트 지점에 있는 애플리케이션 상태만 샘플링할 수 있다.

  실행 중인 프로세스를 샘플링하기 전에 모든 스레드가 세이프포인트에 있어야 하므로 그만큼 오버헤드가 가중되며, 세이프포인트 지점에 있는 애플리케이션 상태만 샘플링하기 때문에 표본점 분포가 왜곡될 소지가 있다.
</br></br>
  실행 프로파일러는 대부분 핫스팟 c++ API에 있는 GetCallTrace()함수를 이용해 각 애플리케이션 스레드의 스택 샘플을 수집한다.</br>
  하지만, GetCallTrace()는 적잖은 오버헤드를 일으킨다. (애플리케이션 활성 스레드가 n개일 때 스택 샘플을 수집하려면 결국 jvm이 세이프포인트를 n번 해야한다.)</br>

  성능 엔지니어라면 애플리케이션에서 세이프포인팅 시간이 얼마나 되는지 예의주시해야할 것이다.</br>
  세이프 포인트에 너무 많은 시간을 소비하면 애플리케이션 성능은 나빠지고 부정확한 데이터에 튜닝 에너지를 낭비하게 될지 모른다.</br></br>

  jvm플래그를 이용하면 세이프 포인팅 시간이 높은 경우를 추적하는데에 도움이 된다.</br>
  ```
  -XX:+PrintGCApplicationsStoppedTime
  ```
  이 플래그는 GC로그에 세이프포인팅 시간에 관한 추가 정보를 로깅한다.</br>


  세이프포인팅 편향이 일으키는 문제는 카운티드 루프로 설명 가능하다.</br>
  다음과 같은 단순루프가 있다.</br>
  ```
  for(int i = 0; i < LIMIT; i++){
    // 루프 바디에서 '단순' 작업만 있다.
  }
  ```




단순 작업은, 이를 테면 가본형의 값의 산술 연산이나 완전히 인라이닝된 메서드 호출등이 해당된다.</br>
LIMIT 값이 클 경우, JIT컴파일러는 자바 코드를 루프 처음으로 되돌리는 백 브랜치를 포함해서 즉시 동등한 컴파일드 코드로 옮길 것이다.</br>
JIT컴파일러는 루프 백 끝부분에 세이프 포인트 체크를 삽입하므로, 루프가 커질수록 한 번 루프가 반복될 때마다 세이프포인트를 할 기회가 주어지게 된다.</br></br>

반대로 LIMIT값이 충분히 작을 경우에는 그런 일은 일어나지 않고, 대신 jit컴파일러가 루프를 펼칠 것이다.</br>
즉 충분히 작은 카운팅 루프를 실행하는 스레드는 루프가 완료될 때까지 세이프포인트를 하지 않는다.</br></br>

따라서, 세이프포인트에서만 샘플링하면 루프 크기와 우리가 그 안에서 하려는 작업 성격에 크게 좌우되는, 편향된 작동 모습을 보이게 된다.</br>





  
