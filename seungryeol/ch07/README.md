<h1>가비지 수집 고급</h1>

가비지 수집기 선정 시 고민해봐야 할 항목</br>
 - 중단시간
 - 처리율
 - 중단 빈도
 - 회수 효율
 - 중단 일관성
   
<h2>동시 GC 이론</h2>

범용 가비지 수집기는 중단 결정을 효과적으로 내리는 데 참고할 만한 도메인 지식이 없다.(메모리 할당은 불확정성을 유발하는 직접적인 원인)</br>

GC 기술의 가장 큰 걸림돌인 swt 중단 문제를 해결하려고 한다.</br>
=> 동시 수집기를 써서 애플리케이션 스레드의 실행 도중 수집에 필요한 작업 일부를 수행해서 중단 시간을 줄이는 방법이 있다.</br>
=> 그만큼 실제 애플리케이션 작업에 투입 가능한 처리 역량을 빼앗기고 수집하는 코드 로직은 더 복잡해짐</br>

<h3>JVM 세이프포인트</h3>


스레드 작업을 하던 중 중간에 요청이 들어와 스레드를 조정할 필요가 있는데 이때 세이프포인트를 사용한다. 이로 인해, 스레드는 잠시 중단될 수 있다.</br>

JVM은 다음과 같은 규칙에 따라 세이프포인트를 처리한다.</br>
 - JVM은 강제로 스레드를 세이프포인트 상태로 바꿀 수 없다.
 - JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.

따라서, 세이프포인트 요청을 받았을 때 그 지점에서 스레드가 제어권을 반납하게 만드는 코드가 VM 인터프리터 구현체에 있어야한다.</br>
       JIT컴파일한 메서드에도 생선된 기계어 안에 배리어가 꼭 들어가 있어야한다.</br>
  세이프포인트 상태로 바뀌는 과정</br>
  - JVM이 전역 '세이프포인트 시간 플래그를 세팅한다.
  - 각 애플리케이션 스레드는 폴링하면서 이 플래그가 세팅됐는지 확인한다.
  - 애플리케이션 스레드는 일단 멈췄다가 다시 깨어날 때까지 대기한다.

◎세이프포인트 시간 플래그를 세팅하면 모든 애플리케이션 스레드는 반드시 멈춰야한다.</br>

스레드가 자동으로 세이프포인트 상태가 되는 경우
 - 모니터에서 차단된다.
 - JNI 코드를 실행

<h3>삼색 마킹</h3>

동작 원리

- GC루트를 회색 표시한다.
- 다른 객체는 모두 흰색 표시한다.
- 마킹 스레드가 임의의 회색 노드로 이동한다.
- 마킹 스레드가 흰색 표시된 자식노드가 있는 노드를 만나면, 먼저 그 자식 노드를 모두 회색 표시한 뒤, 해당 노드를 검은색으로 표시한다.
- 회색 노드가 하나도 남지 않을 때까지 위 과정을 되풀이한다.
- 검은색 객체는 모두 접근 가능한 것이므로 산다.
- 흰색 노드는 더 이상 접근 불가한 객체이므로 수집 대상이 된다.

단점 : 
  1. 변경자 스레드가 수집을 하는 도중에는 검은색 상태, 수집을 안 하는 동안에는 흰색 상태로 새 객체를 생성할 수 있다.
  2. 검은색으로 표시한 객체를 마킹 스레드가 나중에 백색 객체를 참조하도록 바꾸는 상황 연출

해결 방법 : 
   1. 객체 색깔을 검은색 -> 회색으로 바꾸고 변경자 스레드가 업데이트하며 처리할 노드 세트에 도로 추가하면 된다.
   2. 삼색 불변의 원칙을 위배할지 모를 모든 변경 사항을 큐 형태로 넣어두고, 주 단계가 끝난 다음 부차적인 '조정'단계에서 바로잡는 방법.

https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/#Tri-color-Marking-Algorithm
    (쉽게 이해하기)

<h2>CMS</h2>

CMS 수집기는 중단 시간을 아주 짧게 하려고 설계된, 테뉴어드 공간 전용 수집기이다.(stw에 의한 병렬 수집기의 한계를 극복하기 위해)
마킹은 삼색 마킹 알고리즘에 따라 수행하므로 수집기가 힙을 탐색하는 도중에도 객체 그래프가 변경될 수 있다.(문제임)

동작 방식
 - 초기 마킹(stw)
 - 동시 마킹
 - 동시 사전 정리
 - 재마킹(stw)
 - 동시 스위프
 - 동시 리셋


   초기 마킹 단계의 목적 : 해당 영역 내부에 위치한 확실한 GC 출발점을 얻는 것
   => 마킹 단계에서 다른 메모리 영역은 신경 쓸 필요 없이 하나의 GC 풀에만 집중할 수 있다.

   초기 마킹이 끝나면 동시 마킹 단계 시행(삼색 마킹 알고리즘)

   동시 사전 정리 단계 목표 : 재마킹 단계에서 가능한 한 stw시간을 단축
   재마킹 단계는 카드 테이블을 이용해 변경자 스레드가 동시 마킹 단계 도중 영향을 끼친 마킹을 조정한다.

   CMS를 적용하면 얻는 효엄
   1. 애플리케이션 스레드가 오랫동안 멈추지 않는다.
   2. 단일 풀 GC사이클 시간이 더 길다.
   3. CMS GC사이클이 실행되는 동안, 애플리케이션 처리율은 감소
   4. GC가 객체를 추적해야하므로 메모리를 더 많이 쓴다.
   5. GC 수행에 훨씬 더 많은 cpu 시간이 필요.
   6. CMS는 힙을 압착하지 않으므로 테뉴어드 영역은 단편화된다.
  

  cms의 동시 도중 에덴 공간이 꽉 차버린다면?</br>
  1. 애플리케이션 스레드가 중단되고 cms 도중 영GC가 일어난다.</br>
  =>이때, cms와 같이 진행되므로 코어의 절반만 사용하므로 병렬 수집기의 영 gc보다 더 오래 걸린다.</br>
  2. 영 수집이 끝나면 일부객체는 테뉴어드로 승격된다.</br>
   =>(cms가 실행되는 동안에 승격된 객체는 테뉴어드로 이동시켜탸 하는데, 두 수집기 간에 긴밀한 조정이 필요한 부분이다. 이 이유로 cms는 조금 다른 영 수집기를 쓴다.)</br>
  3. 하지만, 할당률이 급증하면 영 수집 시 조기 승격이 일어난다.</br>
   => 승격 객체가 많아지며 테뉴어드 공간조차 부족해진다. 동시 모드 실패(cmf) => jvm은 풀 stw를 유발하는 ParallelOld GC 수집 방식으로 돌아간다.</br></br>

 cmf 해결법</br>
   1. cms가 수집 사이클을 개시 => 테뉴어드 힙 점유 수준에 사이클이 달라(디폴트 테뉴어드 75%) 이를 설정해주거나 스위치로 지정해준다.</br>
   2. CMS 내부적으로 해결</br>
        - cms 내부적으로 프리 리스트를 이용해 사용 가능한 빈 공간을 관리</br>
        - 동시 스위프 단계에서 스위퍼 스레드가 여유 공간을 더 큰 덩어리로 만들고 단편화로 인해 CMF가 발생하지 않도록 연속된 빈 블록들을 하나로 뭉친다.</br>
          🗡주의!! :  스위퍼 변경자와 동시에 작동하므로 스레드가 서로 적절히 동기화되지 않는 한 새로 할당된 블록이 잘못 스위프될 가능성이 있다.</br>
                       => 이런 일이 없겎끔 스위퍼 스레드는 작업 도중 프리 리스트를 잠금</br>
또 다른 cmf의 원인</br>
  1. 힙 단편화 : ParallelOld GC와 달리 cms는 테뉴어드를 압착하지 않는다.</br>
 해결법 : ParallelOld GC로 풀 수집해서 객체를 승격시켜 연속 공ㄱ간을 확보</br></br>

  이 처럼 튜닝이 주요 이슈이다!</br>


  https://velog.io/@winckey0/Java-Optimizing-7.-가비지-수집-고급


<h2>G1</h2>

💉G1은 병렬 수집기, CMS와는 전혀 스타일이 다른 수집기이다.</br>

GC의 특징</br>
 - CMS보다 훨씬 튜닝하기 쉽다.
 - 조기 승격에 덜 취약하다.
 - 대용량 힙에서 확장성이 우수하다.
 - 풀 STW 수집을 없앨 수 있다.
🎓병렬/CMS 수집기와는 달리 세대마다 경계가 뚜렷한, 연속됨 메모리 공간이 없고 반구형 힙 레이아웃 방식과도 무관하다.</br>

![KakaoTalk_20230812_155516518](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/98d3ffa6-b722-49d0-8267-f0b06ba59b79)</br>

G1 힙은 영역으로 구성된다. 영역은 디폴트 크기가 1mB인 메모리 공간이다.</br>
영역을 이용하면 세대를 불연속적으로 배치할 수 잇고, 수집기가 매번 실행될 때마다 전체 가비지를 수집할 필요가 없다.</br>

G1 수집기가 하는 일</br>
1. 동시 마킹 단계를 이용</br>
2. 방출 수집기</br>
3. 통계적으로 압착</br>

G1 수집기는 워밍업을 하는 동안, GC 사이클이 한 번 돌 때마다 얼마나 많은 '일반' 영역에서 가비지를 수집할 수 있는지 그 수치를 보관한다.</br>
🎨거대 영역은 테뉴어드 세대에 속한, 연속된 빈 공간이다.</br>
📢G1에서도 에덴, 서바이버 영역으로 어루어진 영 세대 개념은 같지만, 세대를 구성하는 영역이 연속되어 있지 않다는 차이점이 있다. 영 세대의 크기는 전체 중단 시간 목표에 따라 조정된다.</br>

G1 수집기에도 기억세트(RSet)라는 비슷한 장치로 영역을 추적한다.(영역별로 하나씩, 외부에서 힙 영역 내부를 참조하는 래퍼런스를 관리하기 위한 장치)</br>
=> G1은 영역 내부를 바라보는 레퍼런스를 찾으려고 전체 힙을 다 뒤질 필요없이 RSet만 꺼내 보면 된다.</br></br>

※RSet, 카드 테이블은 모두 부유 가비지라는 GC문제를 해결하는 데 유용하다.</br>
부유 가비지 : 현재 수집 세트 외부에서 죽은 객체가 참조하는 바람에 이미 죽었어야 할 객체가 계속 살아 있는 현상</br>

<h4>G1 단계</h4>

1. 초기마킹(stw)
2. 동시 루트 탐색
3. 동시 마킹
4. 재마킹(stw)
5. 정리(stw)

동시 루트 탐색은 촉기 마킹 단계의 서바이버 영역에서 올드 세대를 가리키는 래퍼런스를 찾는 동시 단계(반드시 다음 영 GC 탐색을 시작하기 전에 끝내야함)</br>
마킹 작업은 재마킹 단계에서 완료(레퍼런스를 처리하고 SATB방식으로 정리하는 작업도 재마킹 단계에서 함)</br>
정리 단계는 어카운팅 및 RSet태스크를 수행하며 대부분 STW를 일으킴</br>
   어카운팅은 이제 완전히 자유의 몸이 되어 재사용 준비를 마친 영역을 식별하는 작업</br></br>

<h2>셰난도아</h2>

셰난도아는 G1처럼 주목표는 중단 시간 단축이다.</br>

수집단계</br>
1. 초기 마킹(stw)
2. 동시 마킹
3. 최종 마킹(stw)
4. 동시 압착

cms, G1과의 차이점 </br>
 셰난도아의 가장 두드러진 특징은 브룩스 포인터이다.</br>
 이 포인터는 객체당 메모리 워드를 하나 더 써서 이전 가비지 수집 단계에서 객체가 재배치됐는지 여부를 표시하고 새 버전 객체 콘텐즈의 위치를 가리킨다.</br>

 ![KakaoTalk_20230812_163616739](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/689acfb9-6cfc-4037-8fed-85cabe1ca241)</br>

 위 메커니즘을 '포워딩 포인터'라고도 부른다.</br>
 재배치되지 않은 객체의 브룩스 포인터는 그냥 메모리 다음 워드를 가리킨다.</br>
 
![KakaoTalk_20230812_163934392](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/dafffd0c-4064-41bc-93dd-a6f433ffce15)</br>

 동시 마킹 단계 : 힙을 죽 훑어 살아 있는 객체를 모두 마킹 => 포워딩 포인터가 있는 oop를 가리키는 객체 레퍼런스가 있으면 새 oop위치를 직접 참조하도록 레퍼런스를 수정</br>
 최종 마킹 단계 : 셰난도아는 stw하고 루트 세트를 재탐색한 후, 방출한 사본을 가리키도록 루트를 복사하고 수정함.</br>

 동시 압착</br>
 => GC 스레드는 다음과 같이 방출</br>

 1. 객체를 TLAB복사한다.
 2. CAS로 브룩스 포인터가 추측성 사본을 가리키도록 수정한다.
 3. 이 작업이 성공하면 압착 스레드가 승리한 것으로 이후 이 버전의 객체를 모두 브룩스 포인터를 경유해서 엑세스하게 된다.
 4. 이 작업이 실패하면 압착 스레드가 실패한 것으로 추측성 사본을 원상복구하고 승리한 스레드가 남긴 브룩스 포인터를 따라간다.

    셰난도아는 동시 수집기라서 수집 사이클 동안에는 애플리케이션 스레드가 생성하는 가비직가 더 많다. 그래서 애플리케이션 실행 중에 수집을 할당 페이스에 맞춰야한다.</br>


<h2>C4</h2>

징은 셰난도아처럼 동시 압착 알고리즘을 사용하지만, 징은 브룩스 포인터 대신 64비트 워드 하나로 이루어진 객체 헤더를 쓴다.</br>
(단일 워드 헤더에는 klass 포인터 대신 kid가 들어있다.</br></br>

![KakaoTalk_Photo_2023-08-13-18-05-10 001](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/9eaf6ade-a7c6-4d99-a08f-376c0cd5d4e0)


주소비트 대신, 로드값 배리어용 oop 레퍼런스 비트 일부를 사용한다.</br>
◉ 징은 처음부터 64비트 아키텍처 전용으로 설계된 까닭에 메타데이터를 32베트에 끼워 맞출 필요가 없다.</br>


<h4>로드값 배리어</h4>

로드값 배리어는 로드한 레터런스 각자의 로딩이 끝나자마자 현재 객체 위치를 직접 가리키게 만들자는 아이디어이다.(자가 치유 배리어)</br>



수집기가 재배치한 객체 레퍼런스를 징이 따라가면 무엇보다 해당 객체의 새 위치를 먼저 바라보도록 애플리케이션 스레드가 레퍼런스를 수정함</br>
=> 각 레퍼런스가 최대 한 번만 수정되기 때문에 다시 쓸 일이 없는 레퍼런스에는 아무 작업도 하지 않는다.</br>

C4 단계</br>
1. 마킹
2. 재배치
3. 재매핑

c4는 교대 압착 기술로 연속적으로 압착한다.</br>
(가상 메모리 서브 시스템은 프로세스 주소 공간에 가상 페이지와 하부 물리 페이지 사이의 매핑 정보를 관리)</br>

징의 방출 기법에 따라 객체는 다른 페이지에 복사되는 형태로 재배치된다.</br>
=> 서로 다른 물리 주소에 대응( 어떤 페이지에 있는 객체를 모두 복사한 다음, 물리 페이지를 싹 다 비우고 os에 반납한다.)</br>

아직 매핑되지 않은 가상 페이지를 가리키는 애플리케이션 레퍼런스가 남아 있겠지만, 메모리 폴트가 발생하기 전에 LVB가 이런 레퍼런스를 도맡아 처리</br>
징의 c4 수집기는 항상 두 가지 수집 알고리즘(영 객체, 올드 객체)을 실행한다.</br>
=> 오버헤드가 발생하지만 cms보다는 낫다</br></br>


<h2>J9</h2>

밸런스드 수집기는 밸런스드 영역 기반 수집기로, 64비트 j9 jvm에서 사용할 수 있고 4기가바이트 이상의 힙에 맞게 설계됐다.</br>

![KakaoTalk_Photo_2023-08-13-18-05-10 002](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/3427eb01-01d1-4539-b440-5a17e50bc988)


j9 수집기 목표</br>
 - 대용량 잦바 힙에서 중단 시간이 길어지는 현상을 개선
 - 중단 시간이 최악인 경우를 최소화
 - 불균일 기억 장치 액세스 성능을 인지하여 활용

첫번째 목표를 달성하기 위해 힙을 여러 개의 영역으로 분할해 각자 독립적으로 관리/수집한다.</br>

밸런스드도 세대별 영역 기반의 수집기이므로 영역별로 나이가 있고 새 객체를 나이가 0인 영역에 할당한다.</br>
(에덴이 꽉 차면 수집이 일어나는데 이를 부분 가비지 수집(pgc)라고 한다.)</br>

😶pgc는 에덴 영역을 모두 수집하는 STW 작업으로, 나이가 더 많이 든 영역도 그럴만한 가치가 있다고 판단되면 추가로 수집한다.</br>
이점 : 밸런스드 수집기는 PGC 도중 현재 수집 대상의 일부인 클래스 로더를 수집할 수 있다.</br>
단점 : PGC는 스스로 수집하기로 결정한 영역만 바라볼 수 있으므로 부유 가비지가 생길 수 있다.</br>
=> 전역 마킹 단계(GMP)를 따로 두고 전체 자바 힙을 탐색하면서 수집할 죽은객체를 표시하는, 부분적인 동시 작업을 수행한다.</br>
=> GMP가 끝난 후, 해당 데이터에 PGC를 수행한다.</br></br>

🫥전역 가비지 수집(GGC) : 힙을 압착하는 풀 stw수집으로, 핫스팟에서 CMF 발생 시 일어나는 풀 수집과 비슷</br>

j9 객체 헤더는 64비트  클래스 슬롯이다</br>
객체유형에 따라 헤더에 슬롯이 추가 될 수 있다.</br>
 - 동기화한 객체에는 모니터 슬롯이 있다.
 - JVM 내부 구조에 편입된 객체에는 해시 슬롯이 있다.

클래스 슬롯의 최상위 24비트는 클래스 구조를 가리키는 포인터로, 자바 8의 메타 공간과 비슷한 오프-힙 메모리이다.</br>

밸런스드 수집기는 불연속된 여러 덩이에 큰 배열을 할당할 수 있도록 어레이릿형태로 나타낸다.(힙 객체가 여러 영역에 걸쳐있는 유일한 상황이다.)</br>

여러 영역에 걸쳐 부분 gc를 수앻아면 참조 객체, 피참조 객체 영역 정보를 관리하는 오버헤드가 발생하므로 전체 gc소요 시간은 더 걸리지만 평균 중단 시간은 줄어든다.</br>
👹이로 인해, 힙이 꽉 찼을 때 최후의 수단으로 동원하는 풀 stw 수집이나 압착이 필요한 경우가 현저히 줄어든다</br>
=></br>
밸런스드 수집기는 영역 및 불연속된 큰 배열을 관리하는 오버헤드가 있으므로 중단 시간을줄이는 일이 직접적인 처리율을 높이는 것보다 더 중요한 애플리케이션이 적합.</br>

<h4>NUMA와 밸런스드</h4>

NUMA는 일반적으로 중대형 서버용 멀티프로세스 시스템에서 사용하는 메모리 아키텍처이다.</br>
![KakaoTalk_Photo_2023-08-13-18-05-10 003](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/2e324d28-b189-47e7-81a1-229e8271fe99)



위 시스템에서는 프로세스와 메모리를 노드로 묶는다.</br>
여러 NUMA노드에 걸쳐 실행되는 JVM에서 밸런스드 수집기는 노드별로 자바 힙을 분리할 수 있다.</br>
애플리케이션 스레드 자신이 선호하는 특정 노드에서 실행되고 그 노드에 속한 메모리 영역에 객체를 할당하도록 조정된다.</br>











    





    


    

