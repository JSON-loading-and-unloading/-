<h1>가비지 수집 고급</h1>

가비지 수집기 선정 시 고민해봐야 할 항목</br>
 - 중단시간
 - 처리율
 - 중단 빈도
 - 회수 효율
 - 중단 일관성
   
<h2>동시 GC 이론</h2>

범용 가비지 수집기는 중단 결정을 효과적으로 내리는 데 참고할 만한 도메인 지식이 없다.(메모리 할당은 불확정성을 유발하는 직접적인 원인)</br>

GC 기술의 가장 큰 걸림돌인 swt 중단 문제를 해결하려고 한다.</br>
=> 동시 수집기를 써서 애플리케이션 스레드의 실행 도중 수집에 필요한 작업 일부를 수행해서 중단 시간을 줄이는 방법이 있다.</br>
=> 그만큼 실제 애플리케이션 작업에 투입 가능한 처리 역량을 빼앗기고 수집하는 코드 로직은 더 복잡해짐</br>

<h3>JVM 세이프포인트</h3>


스레드 작업을 하던 중 중간에 요청이 들어와 스레드를 조정할 필요가 있는데 이때 세이프포인트를 사용한다. 이로 인해, 스레드는 잠시 중단될 수 있다.</br>

JVM은 다음과 같은 규칙에 따라 세이프포인트를 처리한다.</br>
 - JVM은 강제로 스레드를 세이프포인트 상태로 바꿀 수 없다.
 - JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.

따라서, 세이프포인트 요청을 받았을 때 그 지점에서 스레드가 제어권을 반납하게 만드는 코드가 VM 인터프리터 구현체에 있어야한다.</br>
       JIT컴파일한 메서드에도 생선된 기계어 안에 배리어가 꼭 들어가 있어야한다.</br>
  세이프포인트 상태로 바뀌는 과정</br>
  - JVM이 전역 '세이프포인트 시간 플래그를 세팅한다.
  - 각 애플리케이션 스레드는 폴링하면서 이 플래그가 세팅됐는지 확인한다.
  - 애플리케이션 스레드는 일단 멈췄다가 다시 깨어날 때까지 대기한다.

◎세이프포인트 시간 플래그를 세팅하면 모든 애플리케이션 스레드는 반드시 멈춰야한다.</br>

스레드가 자동으로 세이프포인트 상태가 되는 경우
 - 모니터에서 차단된다.
 - JNI 코드를 실행

<h3>삼색 마킹</h3>

동작 원리

- GC루트를 회색 표시한다.
- 다른 객체는 모두 흰색 표시한다.
- 마킹 스레드가 임의의 회색 노드로 이동한다.
- 마킹 스레드가 흰색 표시된 자식노드가 있는 노드를 만나면, 먼저 그 자식 노드를 모두 회색 표시한 뒤, 해당 노드를 검은색으로 표시한다.
- 회색 노드가 하나도 남지 않을 때까지 위 과정을 되풀이한다.
- 검은색 객체는 모두 접근 가능한 것이므로 산다.
- 흰색 노드는 더 이상 접근 불가한 객체이므로 수집 대상이 된다.

단점 : 
  1. 변경자 스레드가 수집을 하는 도중에는 검은색 상태, 수집을 안 하는 동안에는 흰색 상태로 새 객체를 생성할 수 있다.
  2. 검은색으로 표시한 객체를 마킹 스레드가 나중에 백색 객체를 참조하도록 바꾸는 상황 연출

해결 방법 : 
   1. 객체 색깔을 검은색 -> 회색으로 바꾸고 변경자 스레드가 업데이트하며 처리할 노드 세트에 도로 추가하면 된다.
   2. 삼색 불변의 원칙을 위배할지 모를 모든 변경 사항을 큐 형태로 넣어두고, 주 단계가 끝난 다음 부차적인 '조정'단계에서 바로잡는 방법.

https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/#Tri-color-Marking-Algorithm
    (쉽게 이해하기)

<h3>CMS</h3>

CMS 수집기는 중단 시간을 아주 짧게 하려고 설계된, 테뉴어드 공간 전용 수집기이다.(stw에 의한 병렬 수집기의 한계를 극복하기 위해)
마킹은 삼색 마킹 알고리즘에 따라 수행하므로 수집기가 힙을 탐색하는 도중에도 객체 그래프가 변경될 수 있다.(문제임)

동작 방식
 - 초기 마킹(stw)
 - 동시 마킹
 - 동시 사전 정리
 - 재마킹(stw)
 - 동시 스위프
 - 동시 리셋


   초기 마킹 단계의 목적 : 해당 영역 내부에 위치한 확실한 GC 출발점을 얻는 것
   => 마킹 단계에서 다른 메모리 영역은 신경 쓸 필요 없이 하나의 GC 풀에만 집중할 수 있다.

   초기 마킹이 끝나면 동시 마킹 단계 시행(삼색 마킹 알고리즘)

   동시 사전 정리 단계 목표 : 재마킹 단계에서 가능한 한 stw시간을 단축
   재마킹 단계는 카드 테이블을 이용해 변경자 스레드가 동시 마킹 단계 도중 영향을 끼친 마킹을 조정한다.

   CMS를 적용하면 얻는 효엄
   1. 애플리케이션 스레드가 오랫동안 멈추지 않는다.
   2. 단일 풀 GC사이클 시간이 더 길다.
   3. CMS GC사이클이 실행되는 동안, 애플리케이션 처리율은 감소
   4. GC가 객체를 추적해야하므로 메모리를 더 많이 쓴다.
   5. GC 수행에 훨씬 더 많은 cpu 시간이 필요.
   6. CMS는 힙을 압착하지 않으므로 테뉴어드 영역은 단편화된다.
  

  cms의 동시 도중 에덴 공간이 꽉 차버린다면?
  1. 애플리케이션 스레드가 중단되고 cms 도중 영GC가 일어난다.
  =>이때, cms와 같이 진행되므로 코어의 절반만 사용하므로 병렬 수집기의 영 gc보다 더 오래 걸린다.
  2. 영 수집이 끝나면 일부객체는 테뉴어드로 승격된다.
   =>(cms가 실행되는 동안에 승격된 객체는 테뉴어드로 이동시켜탸 하는데, 두 수집기 간에 긴밀한 조정이 필요한 부분이다. 이 이유로 cms는 조금 다른 영 수집기를 쓴다.)
  3. 하지만, 할당률이 급증하면 영 수집 시 조기 승격이 일어난다.
   => 승격 객체가 많아지며 테뉴어드 공간조차 부족해진다. 동시 모드 실패(cmf) => jvm은 풀 stw를 유발하는 ParallelOld GC 수집 방식으로 돌아간다.

 cmf 해결법
   1. cms가 수집 사이클을 개시 => 테뉴어드 힙 점유 수준에 사이클이 달라(디폴트 테뉴어드 75%) 이를 설정해주거나 스위치로 지정해준다.
   2. CMS 내부적으로 해결
        - cms 내부적으로 프리 리스트를 이용해 사용 가능한 빈 공간을 관리
        - 동시 스위프 단계에서 스위퍼 스레드가 여유 공간을 더 큰 덩어리로 만들고 단편화로 인해 CMF가 발생하지 않도록 연속된 빈 블록들을 하나로 뭉친다.
          🗡주의!! :  스위퍼 변경자와 동시에 작동하므로 스레드가 서로 적절히 동기화되지 않는 한 새로 할당된 블록이 잘못 스위프될 가능성이 있다.
                       => 이런 일이 없겎끔 스위퍼 스레드는 작업 도중 프리 리스트를 잠금
또 다른 cmf의 원인
  1. 힙 단편화 : ParallelOld GC와 달리 cms는 테뉴어드를 압착하지 않는다.
 해결법 : ParallelOld GC로 풀 수집해서 객체를 승격시켜 연속 공ㄱ간을 확보

  이 처럼 튜닝이 주요 이슈이다!


  https://velog.io/@winckey0/Java-Optimizing-7.-가비지-수집-고급


<h3>G1</h3>







    


    

