<h1>가비지 수집 고급</h1>

가비지 수집기 선정 시 고민해봐야 할 항목</br>
 - 중단시간
 - 처리율
 - 중단 빈도
 - 회수 효율
 - 중단 일관성
   
<h2>동시 GC 이론</h2>

범용 가비지 수집기는 중단 결정을 효과적으로 내리는 데 참고할 만한 도메인 지식이 없다.(메모리 할당은 불확정성을 유발하는 직접적인 원인)</br>

GC 기술의 가장 큰 걸림돌인 swt 중단 문제를 해결하려고 한다.</br>
=> 동시 수집기를 써서 애플리케이션 스레드의 실행 도중 수집에 필요한 작업 일부를 수행해서 중단 시간을 줄이는 방법이 있다.</br>
=> 그만큼 실제 애플리케이션 작업에 투입 가능한 처리 역량을 빼앗기고 수집하는 코드 로직은 더 복잡해짐</br>

<h3>JVM 세이프포인트</h3>


스레드 작업을 하던 중 중간에 요청이 들어와 스레드를 조정할 필요가 있는데 이때 세이프포인트를 사용한다. 이로 인해, 스레드는 잠시 중단될 수 있다.</br>

JVM은 다음과 같은 규칙에 따라 세이프포인트를 처리한다.</br>
 - JVM은 강제로 스레드를 세이프포인트 상태로 바꿀 수 없다.
 - JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.

따라서, 세이프포인트 요청을 받았을 때 그 지점에서 스레드가 제어권을 반납하게 만드는 코드가 VM 인터프리터 구현체에 있어야한다.</br>
       JIT컴파일한 메서드에도 생선된 기계어 안에 배리어가 꼭 들어가 있어야한다.</br>
  세이프포인트 상태로 바뀌는 과정</br>
  - JVM이 전역 '세이프포인트 시간 플래그를 세팅한다.
  - 각 애플리케이션 스레드는 폴링하면서 이 플래그가 세팅됐는지 확인한다.
  - 애플리케이션 스레드는 일단 멈췄다가 다시 깨어날 때까지 대기한다.

◎세이프포인트 시간 플래그를 세팅하면 모든 애플리케이션 스레드는 반드시 멈춰야한다.</br>

스레드가 자동으로 세이프포인트 상태가 되는 경우
 - 모니터에서 차단된다.
 - JNI 코드를 실행

<h3>삼색 마킹</h3>

동작 원리

- GC루트를 회색 표시한다.
- 다른 객체는 모두 흰색 표시한다.
- 마킹 스레드가 임의의 회색 노드로 이동한다.
- 마킹 스레드가 흰색 표시된 자식노드가 있는 노드를 만나면, 먼저 그 자식 노드를 모두 회색 표시한 뒤, 해당 노드를 검은색으로 표시한다.
- 회색 노드가 하나도 남지 않을 때까지 위 과정을 되풀이한다.
- 검은색 객체는 모두 접근 가능한 것이므로 산다.
- 흰색 노드는 더 이상 접근 불가한 객체이므로 수집 대상이 된다.

단점 : 
  1. 변경자 스레드가 수집을 하는 도중에는 검은색 상태, 수집을 안 하는 동안에는 흰색 상태로 새 객체를 생성할 수 있다.
  2. 검은색으로 표시한 객체를 마킹 스레드가 나중에 백색 객체를 참조하도록 바꾸는 상황 연출

해결 방법 : 
   1. 객체 색깔을 검은색 -> 회색으로 바꾸고 변경자 스레드가 업데이트하며 처리할 노드 세트에 도로 추가하면 된다.
   2. 삼색 불변의 원칙을 위배할지 모를 모든 변경 사항을 큐 형태로 넣어두고, 주 단계가 끝난 다음 부차적인 '조정'단계에서 바로잡는 방법.

https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/#Tri-color-Marking-Algorithm
    (쉽게 이해하기)

<h2>CMS</h2>

CMS 수집기는 중단 시간을 아주 짧게 하려고 설계된, 테뉴어드 공간 전용 수집기이다.(stw에 의한 병렬 수집기의 한계를 극복하기 위해)
마킹은 삼색 마킹 알고리즘에 따라 수행하므로 수집기가 힙을 탐색하는 도중에도 객체 그래프가 변경될 수 있다.(문제임)

동작 방식
 - 초기 마킹(stw)
 - 동시 마킹
 - 동시 사전 정리
 - 재마킹(stw)
 - 동시 스위프
 - 동시 리셋


   초기 마킹 단계의 목적 : 해당 영역 내부에 위치한 확실한 GC 출발점을 얻는 것
   => 마킹 단계에서 다른 메모리 영역은 신경 쓸 필요 없이 하나의 GC 풀에만 집중할 수 있다.

   초기 마킹이 끝나면 동시 마킹 단계 시행(삼색 마킹 알고리즘)

   동시 사전 정리 단계 목표 : 재마킹 단계에서 가능한 한 stw시간을 단축
   재마킹 단계는 카드 테이블을 이용해 변경자 스레드가 동시 마킹 단계 도중 영향을 끼친 마킹을 조정한다.

   CMS를 적용하면 얻는 효엄
   1. 애플리케이션 스레드가 오랫동안 멈추지 않는다.
   2. 단일 풀 GC사이클 시간이 더 길다.
   3. CMS GC사이클이 실행되는 동안, 애플리케이션 처리율은 감소
   4. GC가 객체를 추적해야하므로 메모리를 더 많이 쓴다.
   5. GC 수행에 훨씬 더 많은 cpu 시간이 필요.
   6. CMS는 힙을 압착하지 않으므로 테뉴어드 영역은 단편화된다.
  

  cms의 동시 도중 에덴 공간이 꽉 차버린다면?</br>
  1. 애플리케이션 스레드가 중단되고 cms 도중 영GC가 일어난다.</br>
  =>이때, cms와 같이 진행되므로 코어의 절반만 사용하므로 병렬 수집기의 영 gc보다 더 오래 걸린다.</br>
  2. 영 수집이 끝나면 일부객체는 테뉴어드로 승격된다.</br>
   =>(cms가 실행되는 동안에 승격된 객체는 테뉴어드로 이동시켜탸 하는데, 두 수집기 간에 긴밀한 조정이 필요한 부분이다. 이 이유로 cms는 조금 다른 영 수집기를 쓴다.)</br>
  3. 하지만, 할당률이 급증하면 영 수집 시 조기 승격이 일어난다.</br>
   => 승격 객체가 많아지며 테뉴어드 공간조차 부족해진다. 동시 모드 실패(cmf) => jvm은 풀 stw를 유발하는 ParallelOld GC 수집 방식으로 돌아간다.</br></br>

 cmf 해결법</br>
   1. cms가 수집 사이클을 개시 => 테뉴어드 힙 점유 수준에 사이클이 달라(디폴트 테뉴어드 75%) 이를 설정해주거나 스위치로 지정해준다.</br>
   2. CMS 내부적으로 해결</br>
        - cms 내부적으로 프리 리스트를 이용해 사용 가능한 빈 공간을 관리</br>
        - 동시 스위프 단계에서 스위퍼 스레드가 여유 공간을 더 큰 덩어리로 만들고 단편화로 인해 CMF가 발생하지 않도록 연속된 빈 블록들을 하나로 뭉친다.</br>
          🗡주의!! :  스위퍼 변경자와 동시에 작동하므로 스레드가 서로 적절히 동기화되지 않는 한 새로 할당된 블록이 잘못 스위프될 가능성이 있다.</br>
                       => 이런 일이 없겎끔 스위퍼 스레드는 작업 도중 프리 리스트를 잠금</br>
또 다른 cmf의 원인</br>
  1. 힙 단편화 : ParallelOld GC와 달리 cms는 테뉴어드를 압착하지 않는다.</br>
 해결법 : ParallelOld GC로 풀 수집해서 객체를 승격시켜 연속 공ㄱ간을 확보</br></br>

  이 처럼 튜닝이 주요 이슈이다!</br>


  https://velog.io/@winckey0/Java-Optimizing-7.-가비지-수집-고급


<h2>G1</h2>

💉G1은 병렬 수집기, CMS와는 전혀 스타일이 다른 수집기이다.</br>

GC의 특징</br>
 - CMS보다 훨씬 튜닝하기 쉽다.
 - 조기 승격에 덜 취약하다.
 - 대용량 힙에서 확장성이 우수하다.
 - 풀 STW 수집을 없앨 수 있다.
🎓병렬/CMS 수집기와는 달리 세대마다 경계가 뚜렷한, 연속됨 메모리 공간이 없고 반구형 힙 레이아웃 방식과도 무관하다.</br>

![KakaoTalk_20230812_155516518](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/106163272/98d3ffa6-b722-49d0-8267-f0b06ba59b79)</br>

G1 힙은 영역으로 구성된다. 영역은 디폴트 크기가 1mB인 메모리 공간이다.</br>
영역을 이용하면 세대를 불연속적으로 배치할 수 잇고, 수집기가 매번 실행될 때마다 전체 가비지를 수집할 필요가 없다.</br>

G1 수집기가 하는 일</br>
1. 동시 마킹 단계를 이용</br>
2. 방출 수집기</br>
3. 통계적으로 압착</br>

G1 수집기는 워밍업을 하는 동안, GC 사이클이 한 번 돌 때마다 얼마나 많은 '일반' 영역에서 가비지를 수집할 수 있는지 그 수치를 보관한다.</br>
🎨거대 영역은 테뉴어드 세대에 속한, 연속된 빈 공간이다.</br>
📢G1에서도 에덴, 서바이버 영역으로 어루어진 영 세대 개념은 같지만, 세대를 구성하는 영역이 연속되어 있지 않다는 차이점이 있다. 영 세대의 크기는 전체 중단 시간 목표에 따라 조정된다.</br>

G1 수집기에도 기억세트(RSet)라는 비슷한 장치로 영역을 추적한다.(영역별로 하나씩, 외부에서 힙 영역 내부를 참조하는 래퍼런스를 관리하기 위한 장치)</br>
=> G1은 영역 내부를 바라보는 레퍼런스를 찾으려고 전체 힙을 다 뒤질 필요없이 RSet만 꺼내 보면 된다.</br></br>

※RSet, 카드 테이블은 모두 부유 가비지라는 GC문제를 해결하는 데 유용하다.</br>
부유 가비지 : 현재 수집 세트 외부에서 죽은 객체가 참조하는 바람에 이미 죽었어야 할 객체가 계속 살아 있는 현상</br>

<h4>G1 단계</h4>

1. 초기마킹(stw)
2. 동시 루트 탐색
3. 동시 마킹
4. 재마킹(stw)
5. 정리(stw)

동시 루트 탐색은 촉기 마킹 단계의 서바이버 영역에서 올드 세대를 가리키는 래퍼런스를 찾는 동시 단계(반드시 다음 영 GC 탐색을 시작하기 전에 끝내야함)</br>
마킹 작업은 재마킹 단계에서 완료(레퍼런스를 처리하고 SATB방식으로 정리하는 작업도 재마킹 단계에서 함)</br>
정리 단계는 어카운팅 및 RSet태스크를 수행하며 대부분 STW를 일으킴</br>
   어카운팅은 이제 완전히 자유의 몸이 되어 재사용 준비를 마친 영역을 식별하는 작업</br></br>







    


    

